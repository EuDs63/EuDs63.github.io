<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EuDs&#39;s blog</title>
  
  
  <link href="http://euds63.github.io/atom.xml" rel="self"/>
  
  <link href="http://euds63.github.io/"/>
  <updated>2023-10-07T05:32:04.521Z</updated>
  <id>http://euds63.github.io/</id>
  
  <author>
    <name>EuDs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>game of life</title>
    <link href="http://euds63.github.io/2023/game-of-life/"/>
    <id>http://euds63.github.io/2023/game-of-life/</id>
    <published>2023-10-05T08:04:39.000Z</published>
    <updated>2023-10-07T05:32:04.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>大一的时候做某次课程作业，我的选题就是life of game。从那时候就想自己实现一个。但一直搁置着没有动手，最近在学Rust，并正好看到了篇<a href="https://rustwasm.github.io/docs/book/introduction.html">很不错的教程</a>。这便是这个项目的起因。</p><h2 id="历程"><a href="#历程" class="headerlink" title="历程"></a>历程</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>我使用的环境是vecode+wsl2。整体下来除了因为机器性能限制导致内存占用过高，体验还是很可以的。</p><p>但在搭建项目环境时踩了三个坑。</p><ol><li><em>npm install 失败</em></li></ol><ul><li>解决：在Ubuntu中安装npm</li><li>参考：<a href="https://blog.csdn.net/hys__handsome/article/details/125687617">WSL无法使用npm</a></li></ul><ol start="2"><li><em>wasm-build 失败</em></li></ol><ul><li>解决 <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[package.metadata.wasm-pack.profile.release]</span><br><span class="hljs-attr">wasm-opt</span> = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure></li><li>参考：<a href="https://github.com/rustwasm/wasm-pack/issues/864">failed to download binaryen-version_90-x86-windows.tar.gz</a></li></ul><ol start="3"><li><em>wasm-pack test –chrome –headless 失败</em></li></ol><ul><li>解决: 改用<code>wasm-pack test --chrome</code></li><li>参考： <a href="https://github.com/rustwasm/wasm-pack/issues/611">Headless Chrome test fails</a></li></ul><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>编码阶段跟着教程来，还算顺利。但教程中的代码是全部堆放在一起的。这看起来不太舒服，也不太适合我后续的迭代。我花了些时间将其组件化。但教程的后面也有说明没有组件化的理由：Shrinking .wasm Size。这让我意识到还是要根据项目的特点来去做对应的优化和修改。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>开发时，我发现<a href="https://github.com/shalzz/wasm-game-of-life">shalzz&#x2F;wasm-game-of-life</a>提供了一个live demo。是使用vercel进行部署的。vercel之前我也有使用过，但只是用的别人的一键部署。我觉得蛮有意思的，于是决定也试试。着实花了些时间，踩了不少坑。这里展开说下过程。</p><ol><li>一开始参考<a href="https://betterprogramming.pub/deploying-a-wasm-powered-react-app-on-vercel-cf3cae2a75d6">Deploying a WASM-Powered React App on Vercel</a>。后来发现不需要这么麻烦，因为我已经<code>wasm-pack pulish</code>了，可以直接将<a href="https://www.npmjs.com/package/wasm-game-of-life-euds63">wasm-game-of-life-euds63 - npm</a>作为依赖引入。这样就只需要部署webpack，而不用再去安装Rust相关的内容。</li><li>对代码进行对应的修改后。我开始尝试部署。先是遇到路径问题，我将<code>Root Directory</code>修改为www。</li><li>这时候vercel显示部署成功了，但实际上是运行不了的。我因着之前的经验，惯性地以为也是路径问题。开始修改其他地方的路径。但实际上不是。反复修改几次后我发现:错误的路径会导致部署成功，而正确的路径反而会使<code>npm install</code>报错。而我一开始以为的错误路径是正确的。 这一步我觉得还是我没有好好去看log导致的。</li><li>根据相应的报错发现是node版本问题。我本地运行成功的node版本是12，而vercel只支持18和16，我一开始的想法是另外安装一个12的版本，未果。后来报着试一试的念头改为16，惊喜的是<code>npm install</code>成功了。</li><li><code>npm run build</code>后报错：Missing Public Directory。根据<a href="https://vercel.com/docs/errors/error-list#missing-public-directory">Error List | Vercel Docs</a>尝试将<code>Output Directory</code>设为dist，解决。</li></ol><h3 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h3><p>我使用了子域名的方式进行配置。之前觉得配置子域名蛮神奇的。自己尝试后发现，似乎是相当于一个redirect？</p><p>我先在我使用的DNS服务提供商处添加了一条CNAME记录。</p><table><thead><tr><th>SUBDOMAIN</th><th>TYPE</th><th>VALUE</th><th>TTL, SEC</th></tr></thead><tbody><tr><td>lifegame</td><td>CNAME</td><td>game-of-life-2hpx.vercel.app</td><td>86400</td></tr></tbody></table><p>然后在vercel的对应项目中的Domains新增域名lifegame.ds63.eu.org。</p><p>一开始设置好的是没有ssl证书。网上查了些资料，发现vercel是会自动提供ssl证书的。还以为是自己哪里设置出问题了。结果是得等一会儿才行。</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ol><li>Rust自定义宏<ul><li>步骤<ol><li>在一个模块中定义并导出自定义宏<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-comment">// utils.rs</span><br><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> log &#123;<br>   ( $( $t:tt )* ) =&gt; &#123;<br>      web_sys::console::<span class="hljs-title function_ invoke__">log_1</span>(&amp;<span class="hljs-built_in">format!</span>( $( $t )* ).<span class="hljs-title function_ invoke__">into</span>());<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>在其他模块中使用<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-comment">// lib.rs</span><br><span class="hljs-meta">#[macro_use]</span><br><span class="hljs-keyword">mod</span> utils;<br><br><span class="hljs-keyword">mod</span> universe;<br><br><span class="hljs-comment">// universe.rs</span><br><span class="hljs-keyword">use</span> crate::utils;<br><span class="hljs-comment">// 直接使用</span><br>log!(<span class="hljs-string">&quot;This is a log message: &#123;&#125;&quot;</span>, some_variable);<br></code></pre></td></tr></table></figure></li></ol></li></ul></li><li>Always let profiling guide your focus<ul><li>一些检测性能工具<ol><li>edge开发者工具 -&gt; 性能</li><li><code>cargo benchcmp</code></li><li><code>perf</code></li></ol></li><li><a href="https://rustwasm.github.io/docs/book/game-of-life/time-profiling.html">Time Profiling - Rust and WebAssembly</a>这章值得再读几次</li></ul></li><li>vercel部署</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://rustwasm.github.io/docs/book/introduction.html">Rust and WebAssembly</a></li><li><a href="https://playgameoflife.com/">Play John Conway’s Game of Life</a> 目前发现的最好的一个game of life实现</li><li><a href="https://github.com/shalzz/wasm-game-of-life">shalzz&#x2F;wasm-game-of-life: Game of Life implementation using Rust, Javascript and WebAssembly!</a></li><li><a href="https://vercel.com/docs/projects/overview#ignored-build-step">Projects Overview | Vercel Docs</a></li></ul>]]></content>
    
    
    <summary type="html">记录EuDs63/game_of_life</summary>
    
    
    
    <category term="想法" scheme="http://euds63.github.io/categories/%E6%83%B3%E6%B3%95/"/>
    
    
    <category term="记录" scheme="http://euds63.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="折腾" scheme="http://euds63.github.io/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>再想一下</title>
    <link href="http://euds63.github.io/2023/one-more-think/"/>
    <id>http://euds63.github.io/2023/one-more-think/</id>
    <published>2023-09-19T04:50:11.000Z</published>
    <updated>2023-10-07T05:32:04.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="再想一下"><a href="#再想一下" class="headerlink" title="再想一下"></a>再想一下</h1><h2 id="感受与感想"><a href="#感受与感想" class="headerlink" title="感受与感想"></a>感受与感想</h2><p>我博客有两个标签：“感受” 与“感想”。某一天我自己看到后一愣，这两有啥区别啊。好像大差不差。</p><p><em>再想一下</em></p><p>区别还是有的，“感受”偏向于看到、察觉到的某种事情的第一个瞬间时，脑子以及身体做出的第一反应；而“感想”可能是事情发生一段时间后，再去想这件事情。</p><p>这个解释是我自己瞎琢磨的，不一定对，但有用，因为这让我以为的博客标签的bug变成了一个feature。</p><h2 id="套壳国产"><a href="#套壳国产" class="headerlink" title="套壳国产"></a>套壳国产</h2><p>某天刷到个帖子，是一个程序员在吐槽自己学了MySQL，Tomcat等知识，但是甲方要求其使用国产的工具，而他觉得这些所谓国产，很多都只是套了层皮，却就要额外收取很可观的费用。</p><p>我的第一感受是觉得可耻，一下子就联想到了某款编辑器。</p><p><em>再想一下</em></p><p>从法律层面，基于开源工具所使用的许可证的不同，这种套壳行为可能合法、也可能不合法。但敢拿出来收费，我想人家肯定有去研究相关的发条，这个不是我的专业，也不了解。</p><p>从买卖双方的层面：甲方出于各种各样的考虑，有使用国产工具的需求，而乙方正适应了这种需求。周瑜打黄盖，这点也不能多说什么。</p><p>从价值层面，如果这种套壳背后附加的是一定时间的售后服务，那可以理解为是在卖服务，这也能理解。</p><p>从开源社区的层面来说，我一直以来都只是使用者，没有贡献过多少代码，也没有深度参与过。不理解的东西我也不能多说什么。</p><p>但对我来说，我还是觉得可耻。因为至少我在使用别人的代码时，最终的成品我会去删掉那些不必要的东西，但是会声明我这个项目参考了、使用了别人的代码，我觉得这是一种起码的尊重。</p><h2 id="智感支付"><a href="#智感支付" class="headerlink" title="智感支付"></a>智感支付</h2><p>某天刷到个视频，有人拿着扫码枪的照片对准某款手机，这个手机所宣传的智感支付也能起作用。下面的评论有对隐私的担忧，说是前置摄像头一直开着太恐怖啦。</p><p>我的第一感受是是诶，好像确实是这么回事。</p><p><em>再想一下</em></p><p>手机摄像头一直开着这个论断感觉是站不住脚的。我自己猜了下：第一：这应该会带来相当的耗电量，用户应该能察觉得到。第二：完全有更好的实现方法：比如加个距离传感器之类的，只有一定距离才会去检测。</p><p>但话说回来，不管怎么样的实现，肯定都会使得前置摄像头的使用率一定程度上提高。而至于隐私问题，我觉得作为一项可选功能，用户开启了也说明其接受了相应可能的风险，愿意去牺牲可能的一些东西来换取相对的便利性。</p><p><em>再再想一下</em></p><p>如果可能，我会不会去用这个功能。我想我应该不会，至少短期内不会。我现在的想法是觉得：支付不能太便捷，太便捷容易让我不知不觉就想多花钱。一定的麻烦能让我有更多的时间去打消可能的不必要的消费念头。</p><p><em>再再再想一下</em></p><p>说到支付的便捷性，我觉得扫码支付是一种为了普及度的tradeoff，而能够使用扫码机的场所，使用NFC这种碰一下就能支付的方式我觉得就挺好。</p><h2 id="手环测心跳"><a href="#手环测心跳" class="headerlink" title="手环测心跳"></a>手环测心跳</h2><p>某天看到的某个视频：有人将不同品牌的手环拿去绑在香肠还是水杯上，让其测心跳，从而比较品牌的优劣。</p><p>这个我第一眼觉得很弱智。要比较谁优谁劣更好的方式应该是在实际使用中去比较精准度、续航能力等参数。而不是像这样哗众取宠。</p><p><em>再想一下</em></p><p>我还是不太喜欢这种做法，但我觉得这个视频还是有其意义的，如果不去以此比较优劣。</p><ul><li>比如开发人员看到了，可能会想我需要加个检测功能，保证只有戴在手上的时候才去检测。</li><li>比如我这种普通消费者看到了，我会想：诶，这说明了这几款手环用的检测机制是不一样的，同样一种功能，可以不同方式去实现，还蛮有意思的。</li></ul><h2 id="预制菜"><a href="#预制菜" class="headerlink" title="预制菜"></a>预制菜</h2><p>某段时间预制菜的话题讨论度很高，我刚开始也蛮反感预制菜，觉得这个词背后代表了不健康，不卫生，不好吃。</p><p><em>再想一下</em></p><p>真的不健康吗？可能。一道菜品加工后被装袋，然后需要保证能存放相当一段时间，应该会是需要某种防腐技术。我只是个普通的消费者，我基于自身的生活经历，对这方面有一定的担忧。而这担忧可能合理，也可能不合理。</p><p>真的不好吃吗？不清楚。我没有做过预制菜和非预制菜的双盲实验，我的味蕾也不是相当灵敏。</p><p>真的不卫生吗？分情况。我自己家做饭都难保一定卫生，而那些苍蝇馆子，外卖小店我觉得更难以保证。如果预制菜是由一定规模的厂家去生产，遵照相应的合格的标准，我觉得卫生方面应该可以放心。</p><p>所以我的想法是不能去过度妖魔化预制菜。它可以是一种选择。</p>]]></content>
    
    
    <summary type="html">深思熟虑 优柔寡断 不假思索 草率行事</summary>
    
    
    
    <category term="想法" scheme="http://euds63.github.io/categories/%E6%83%B3%E6%B3%95/"/>
    
    
    <category term="感想" scheme="http://euds63.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
    <category term="感受" scheme="http://euds63.github.io/tags/%E6%84%9F%E5%8F%97/"/>
    
  </entry>
  
  <entry>
    <title>由Unity收费想到的</title>
    <link href="http://euds63.github.io/2023/reason-for-boycott-Unity/"/>
    <id>http://euds63.github.io/2023/reason-for-boycott-Unity/</id>
    <published>2023-09-15T07:59:21.000Z</published>
    <updated>2023-10-07T05:32:04.521Z</updated>
    
    <content type="html"><![CDATA[<p><em>Unity宣布收取安装费这件事自9月12日引发许多讨论，我的想法也有一定的改变</em></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>我是认可收费的，原因有：</p><ol><li>游戏开发人员使用了Unity的服务，并以此盈利，那就应该支付相应的费用。</li><li>收费是有一定门槛的，这个门槛在我看来似乎还挺高？</li></ol><h2 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h2><p>我发现反对的言论明显多于支持或者中立的言论，就决定自己去了解。</p><p>从<a href="https://blog.unity.com/news/plan-pricing-and-packaging-updates">Unity的官方网站</a>，我了解到：</p><ol><li>Unity已经有相关的收费：Unity Plus、Unity Pro等等</li><li>新的收费内容是按照New installs per month进行收费，这个我觉得很不合理。<ul><li>如何知道用户安装了几次</li><li>如何确保有人恶意安装，导致开发人员蒙受不必要的损失。</li></ul></li></ol><h2 id="游戏开发人员"><a href="#游戏开发人员" class="headerlink" title="游戏开发人员"></a>游戏开发人员</h2><p>Unity的收费标准对于person和Enterprise是有区别的，而且相当大。person是$0.2 per new install,而Enterprise甚至可以低到$0.01。所以我也分开来调查。</p><h3 id="有一定体量的公司"><a href="#有一定体量的公司" class="headerlink" title="有一定体量的公司"></a>有一定体量的公司</h3><p>以下是<a href="https://garry.net/posts/unity-can-get-fucked">Unity can get fucked</a>的部分摘抄，作者是Garry’s Mod的创作者。</p><blockquote><p>Let me be clear.. the cost isn’t a big issue to us. If everything worked out, the tracking was flawless and it was 10p per sale, no biggy really. If that’s what it costs, then that’s what it costs.</p></blockquote><p><strong>这个收费是他们可承受的，甚至似乎可以说是无伤大雅</strong></p><blockquote><p>It hurts because we didn’t agree to this. We used the engine because you pay up front and then ship your product. We weren’t told this was going to happen. We weren’t warned. We weren’t consulted.</p></blockquote><blockquote><p>We have spent 10 years making Rust on Unity’s engine. We’ve paid them every year. And now they changed the rules.</p></blockquote><p><strong>指出愤怒点：未经提前告知、商讨，就更改条款</strong></p><blockquote><p>We had 10 years to make our own engine and never did. I’m sure a lot of game companies are feeling the same today.</p></blockquote><p><strong>后悔没有做自己的引擎</strong></p><h3 id="个人制作者"><a href="#个人制作者" class="headerlink" title="个人制作者"></a>个人制作者</h3><p><a href="https://www.youtube.com/watch?v=1jKVt98fgEY">Unity Ruined Their Game Engine Forever</a>里举了这样一个例子：<br>有些独立游戏开发者制作了一些小游戏，下载量高达数百万，但游戏中的广告系统或者收费内容没办法cover所需要支付的安装费，那就会变成一个很荒谬的情况：因为游戏受欢迎而破产。</p><h2 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h2><p><a href="https://www.youtube.com/watch?v=1jKVt98fgEY">Unity Ruined Their Game Engine Forever</a>里还有一句我很喜欢”the beauty of Open Source is it’s not run by one scumbag company that can absolutely decide to bring this any time day in shape you can just download this engine and start working on your project.</p><p>这里我就想到GNU和自由软件运动，太美妙了，太高瞻远瞩了。</p><h2 id="我的收获"><a href="#我的收获" class="headerlink" title="我的收获"></a>我的收获</h2><p>我并不是一个游戏开发者，只是一个臭打游戏的，一个还没有真正踏进社会的学生。</p><p>所以刚开始看到这件事情，我也没有思考、了解太多，仅靠自己的判断就给这件事情下了定论，甚至站了立场。</p><p>但随着了解的深入，我的想法可以说是发生反转性的变化。我想很多事也是如此。</p><p>所以这件事给我最大的收获是：在不了解一件事之前不能往下定论。</p>]]></content>
    
    
    <summary type="html">Long may the Free Software Movement!</summary>
    
    
    
    <category term="想法" scheme="http://euds63.github.io/categories/%E6%83%B3%E6%B3%95/"/>
    
    
    <category term="感想" scheme="http://euds63.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
    <category term="游戏" scheme="http://euds63.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="感受" scheme="http://euds63.github.io/tags/%E6%84%9F%E5%8F%97/"/>
    
    <category term="开源" scheme="http://euds63.github.io/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>暑期项目的感悟</title>
    <link href="http://euds63.github.io/2023/Enlightenment-of-summer-project/"/>
    <id>http://euds63.github.io/2023/Enlightenment-of-summer-project/</id>
    <published>2023-09-13T08:00:12.000Z</published>
    <updated>2023-10-07T05:32:04.521Z</updated>
    
    <content type="html"><![CDATA[<p>这次暑期学校的一个月时间都是用来开发一个项目。说是一个月，但实际用来编码的时间大约在三个星期。更具体的时间是早上八点半到下午五点半。最后这一个礼拜晚上也会拿来编码。</p><p>三个礼拜的时间说多不多，但这种经历倒是少有，踩了不少坑，也有不少收获，这里记录一下。</p><h2 id="学习新技术"><a href="#学习新技术" class="headerlink" title="学习新技术"></a>学习新技术</h2><p>这次用的几个技术栈都是之前没有接触过的：前端React，后端Flask。项目后期还引入了Redux和useSWR。</p><p>我对学习新技术倒是蛮有热情，之所以选用这些也是出于想尝试些之前所没有接触过的事物。并且这次用到的技术栈，上手也都是比较容易的，除了Redux现在还是云里雾里，所以整体的开发体验下来并不会因为都是自己没接触过的技术而寸步难行。</p><p>但我还是发现了一个蛮大的问题：因为要赶最后的ddl，所以比较偏向于急于求成，看了看用法和示例就开始写了，虽然最后也确实能写出点东西，但总有种半生不熟的感觉，没有一种确确实实掌握的踏实感。</p><p>我还意识到，一个人的时间和精力是有限的，而技术却是日新月异的。所谓庄子所说的：吾生也有涯，而知也无涯。所谓贪多嚼不烂，就是这个道理。</p><h2 id="DRY与AHA"><a href="#DRY与AHA" class="headerlink" title="DRY与AHA"></a>DRY与AHA</h2><p>这次项目中，后端几乎是我在负责的。但就是这样一个自己在开发的两千行左右的代码，到第三周的时候就还是偶尔会冒出想推倒重写某个部分的想法。</p><p>尤其是action这个部分。在这个项目中，我将用户收藏、评分、评论这三个功能抽象成一个action。自己刚开始写的时候还有点沾沾自喜，认为自己是做到了合理的内聚。</p><p>但后来却发现其中的弊端：当我想单独修改其中某一部分，因为其耦合性，导致我需要修改一些本不需要修改的代码。而到了项目后期，前端已经和后端对接已经完成百分之八九十。这时候修改一个核心功能，可谓是牵一发而动全身。改是能改，但是却不敢改，因为承担不起所需的时间成本。最后的解决方式是另外又写了几个方法，这就导致代码变得很丑。这时候就真切体验到了垒屎山是一种什么样的心情了。</p><p>回顾过去，思考如何在以后能尽量避免这种情况，我想有两个原则可能会起作用：</p><ol><li>DRY<br>“Don’t repeat yourself”的缩写。我虽然有意识去将一些常用的代码封装为一个方法。但还是有不少代码，我选择了直接复制粘贴原有可用代码，并在其基础上进行些许修改。这样子固然省事，写的时候也很畅快，但后期想要修改时，却就要之前的偷懒付出相当的代价。而如若我之前多花些时间，将其封装，这样我的代码也就更方便修改。</li><li>AHA<br>“avoid hasty abstractions”的缩写。这个原则让我不禁想到一句话”premature optimization is root of all evil”。还是以action为例，如果我在将三个操作耦合成一个时多想一想，那会好许多。但话又说回来，怎么样才算是不仓促，怎么样才算不是过早。我觉得现阶段的我还是缺乏经验，所以下次遇到类似的情况时，我想我大概率还是会为自己的某个小聪明而沾沾自喜，并毫不犹豫地踏进给自己挖的又一个坑。</li></ol><h2 id="项目流程"><a href="#项目流程" class="headerlink" title="项目流程"></a>项目流程</h2><p>这次的流程是采用瀑布模式，相比于上学期所使用的Scrum总觉得不得劲。我个人感觉最大的差异是在项目前期，连续多天都是花在写一些比较虚的文档。而这些文档：需求文档，设计文档之类，我们这几个甚至连初出茅庐都还不算的新人，没办法考虑得那么周到。而且多日时间上的付出只是一些文字，这样的体验感实在不好。</p><p>总的来说，这样的经历在我的学生阶段中算是比较一个独特的经历，一个月的时间也没有怎么白白浪费掉，对自己还是较为满意的。</p>]]></content>
    
    
    <summary type="html">没有银弹</summary>
    
    
    
    <category term="想法" scheme="http://euds63.github.io/categories/%E6%83%B3%E6%B3%95/"/>
    
    
    <category term="记录" scheme="http://euds63.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="感想" scheme="http://euds63.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
    <category term="感受" scheme="http://euds63.github.io/tags/%E6%84%9F%E5%8F%97/"/>
    
    <category term="软件工程" scheme="http://euds63.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>换域名喽</title>
    <link href="http://euds63.github.io/2023/change-domain-name/"/>
    <id>http://euds63.github.io/2023/change-domain-name/</id>
    <published>2023-08-17T15:50:11.000Z</published>
    <updated>2023-10-07T05:32:04.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>我博客有相当一段时间，一直是使用默认的域名。而且我其实并不太想去修改，原因是我博客使用的是Github Page。我想信：背靠着微软，GitHub所提供的这项服务的可靠性会比我私人所申请的域名要可靠得多。而我一直秉持着这样一个观点：一个博客的死亡并不是其不再更新，而是无法访问。也就是说，我认为博客的持续性是要优先于其他很多方面的。</p><p>但今天意外发现邮箱里有封邮件，通知我说申请的域名通过了。十分惊喜，因为我已经忘了这件事了。既然手头上有一个域名，上学期也学了相关的知识，干脆就试一试，在此次梳理下相应的步骤。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>申请&#x2F;购买域名</p><p>我使用的是<a href="https://nic.eu.org/">EU.org</a>。好处是免费，但所需时间很长。我在5月27日申请的，直到昨天（8月16日）才通过。</p></li><li><p>选择域名解析服务商</p><p>我选择的是<a href="https://hostry.com/">hostry</a>,原因是免费。</p></li><li><p>Navigate to your DNS provider and create either an ALIAS, ANAME, or A record.</p><p>以下是我设置中的一部分：</p><table><thead><tr><th>SUBDOMAIN</th><th>TYPE</th><th>VALUE</th><th>TTL, SEC</th></tr></thead><tbody><tr><td>@</td><td>A</td><td>185.199.108.153</td><td>86400</td></tr><tr><td>@</td><td>AAAA</td><td>2606:50c0:8000::153</td><td>86400</td></tr><tr><td>www</td><td>CNAME</td><td>euds63.github.io</td><td>86400</td></tr></tbody></table></li></ol><p>  在Claude的帮助下，我知道：</p><ul><li>A记录(Address Record):将域名直接映射到一个IPv4地址。它是最基本的域名记录类型。GitHub提供了4个IP地址,而不是一个IP,主要出于负载均衡和容错的考虑</li><li>AAAA记录(Quad-A record):用于将域名映射到IPv6地址。   </li><li>CNAME记录(Canonical Name Record):将域名映射到另一个域名,实现域名别名的作用</li></ul><p>  值得注意的是<code>www CNAME euds63.github.io 86400</code>，我看到其他的教程有的是将SUBDOMAIN设置为<code>@</code>,但我的情况下会报错<code>Existing record &#39;SOA&#39; conflicts with the code you are trying to create Cname should not have the same name as other records</code></p><ol start="4"><li>Github配置<ul><li>Under “Custom domain”, type your custom domain, then click Save.</li><li>勾选Enforce HTTPS</li></ul></li></ol><p>  <strong>很明显，这里Github帮我们简化了许多操作。包括哪些呢?</strong></p><p>  由<a href="https://docs.github.com/en/pages/getting-started-with-github-pages/securing-your-github-pages-site-with-https">Securing your GitHub Pages site with HTTPS</a>可知，当set or change your custom domain in the Pages setting后，GitHub</p><ol><li>begin an automatic DNS check . This check determines if your DNS settings are configured to allow GitHub to obtain a certificate automatically. </li><li>If the check is successful, GitHub queues a job to request a TLS certificate from Let’s Encrypt. </li><li>On receiving a valid certificate, GitHub automatically uploads it to the servers that handle TLS termination for Pages. When this process completes successfully, a check mark is displayed beside your custom domain name.</li></ol><p>  <strong>但如果不是用的Github Page，要怎么做呢？</strong></p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ping ds63.eu.org<br>正在 Ping ds63.eu.org [185.199.108.153] 具有 32 字节的数据:<br>来自 185.199.108.153 的回复: 字节=32 时间=77ms TTL=54<br>来自 185.199.108.153 的回复: 字节=32 时间=103ms TTL=54<br>来自 185.199.108.153 的回复: 字节=32 时间=76ms TTL=54<br>来自 185.199.108.153 的回复: 字节=32 时间=77ms TTL=54<br><br>185.199.108.153 的 Ping 统计信息:<br>    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，<br>往返行程的估计时间(以毫秒为单位):<br>    最短 = 76ms，最长 = 103ms，平均 = 83ms<br><br>$ ping -6 ds63.eu.org<br><br>正在 Ping ds63.eu.org [2606:50c0:8001::153] 具有 32 字节的数据:<br>来自 2606:50c0:8001::153 的回复: 时间=74ms<br>来自 2606:50c0:8001::153 的回复: 时间=81ms<br>来自 2606:50c0:8001::153 的回复: 时间=74ms<br>来自 2606:50c0:8001::153 的回复: 时间=72ms<br><br>2606:50c0:8001::153 的 Ping 统计信息:<br>    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，<br>往返行程的估计时间(以毫秒为单位):<br>    最短 = 72ms，最长 = 81ms，平均 = 75ms<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site">Managing a custom domain for your GitHub Pages site</a></li><li><a href="https://www.yong.eu.org/detail/15112.html">GitHub Pages绑定个人域名并启用https</a></li><li><a href="https://docs.github.com/en/pages/getting-started-with-github-pages/securing-your-github-pages-site-with-https">Securing your GitHub Pages site with HTTPS</a></li></ul>]]></content>
    
    
    <summary type="html">更换域名为ds63.eu.org</summary>
    
    
    
    <category term="学习" scheme="http://euds63.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="博客" scheme="http://euds63.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="折腾" scheme="http://euds63.github.io/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>我看 LK-99</title>
    <link href="http://euds63.github.io/2023/my-opinion-about-LK-99/"/>
    <id>http://euds63.github.io/2023/my-opinion-about-LK-99/</id>
    <published>2023-08-03T02:38:46.000Z</published>
    <updated>2023-10-07T05:32:04.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我看LK-99"><a href="#我看LK-99" class="headerlink" title="我看LK-99"></a>我看LK-99</h1><p>自<a href="https://arxiv.org/abs/2307.12008">The First Room-Temperature Ambient-Pressure Superconductor</a>发表已过去十多天了。可谓是众说纷纭。</p><p>我，一个物理水平停留在大二、化学水平局限在高中的会考的普通学生，对超导完全处于是门外汉水平，连科普的内容都没有完全读过。对于这个相当惊人的发现，或者再推广出去，对于自己不懂的领域，我一直秉持着不懂就不要乱说这一原则，但我还是忍不住在十多天后，谈谈自己的想法。</p><p>这篇文章的标题是我看LK-99，但实际上更应该是我看别人怎么看LK-99。</p><p>我获取相关信息的渠道主要有：Twitter、百度贴吧、B站、同学群。平台不同，言论也不同，可以说是很精彩。</p><p>我尝试去总结归纳：</p><ol><li>无脑贬低：</li></ol><ul><li>出现地方：贴吧比较多，更精确地说应该是某些贴吧的某些人。</li><li>表现：主要是以一种戏谑的嘲讽为主。代表言论是说：“棒子怎么可能有这种发现”，主打一个瞧不起。</li><li>我的想法：我现在越来越反感对其他国家的贬称，诸如“阿三、棒子、加麻大、丑国”等等。这种言论给我一种十分自大的感觉，但实际上你的国家真的比别人的国家强上多少吗？我看不尽然。</li></ul><ol start="2"><li>攻击相关的科研人员<ul><li>出现地方：几乎都能看到些</li><li>表现：当有些实验室宣布对LK-99的复现出现问题时，LK-99的提出者就可能受到攻击，被说是哗众取宠的小丑。</li><li>我的想法：到目前已经十天过去了，还保持着很高的热度，但似乎还没有完全有力的证伪出现，并且有观点认为这可能引出新的思路。我觉得他们能做到这点就已经很值得认可了。科学本来就是在不断试错中进步。</li></ul></li><li>侃侃而谈<ul><li>出现地方：推特上似乎比较多</li><li>表现: 一些KOL追热点、尽管这并不是其领域</li><li>我的想法：能理解，但看多了我觉得厌烦。但话又说回来，我不也是个完完全全的门外汉，但我不也写了这么多。</li></ul></li><li>赛博斗蛐蛐<ul><li>出现地方： 同学群、大学贴吧</li><li>表现： 国内各大学不少都尝试去复现，并根据结果去发表看法。然后就根据这些发表的看法的准确度、实时程度去给这些大学排名。</li><li>我的想法： 我觉得去复现、并发表自己的复现结果的行为都是值得肯定的。但实验过程中可能因为各种原因会出现不同的现象，倒也能理解。为了时效性和曝光度可能会操之太急，倒也是。</li></ul></li></ol><p>最后说说我的想法；</p><ul><li>肯定是希望其能成功。</li><li>就算不成功，这也是种新材料，也可能是种新的思路。所以也是件好事，也十分值得去肯定。</li></ul>]]></content>
    
    
    <summary type="html">遥远的梦？</summary>
    
    
    
    <category term="想法" scheme="http://euds63.github.io/categories/%E6%83%B3%E6%B3%95/"/>
    
    
    <category term="感想" scheme="http://euds63.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
    <category term="感受" scheme="http://euds63.github.io/tags/%E6%84%9F%E5%8F%97/"/>
    
  </entry>
  
  <entry>
    <title>Rust_Learning</title>
    <link href="http://euds63.github.io/2023/rust-learning/"/>
    <id>http://euds63.github.io/2023/rust-learning/</id>
    <published>2023-07-18T08:25:21.000Z</published>
    <updated>2023-10-07T05:32:04.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust-Learning"><a href="#Rust-Learning" class="headerlink" title="Rust_Learning"></a>Rust_Learning</h1><p><strong>记录我的Rust学习</strong></p><h2 id="Cargo使用"><a href="#Cargo使用" class="headerlink" title="Cargo使用"></a>Cargo使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo new<br>cargo build <br>cargo run<br>cargo check<br>cargo doc --open <span class="hljs-comment">#build documentation provided by all your dependencies locally and open it in your browser</span><br></code></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://course.rs/">Rust语言圣经</a></li><li><a href="https://rust-book.cs.brown.edu/">The Rust Programming Language</a></li><li><a href="https://zh.practice.rs/">Rust语言实战</a></li><li><a href="https://picklenerd.github.io/">PNGme</a></li></ul><h2 id="Rust特点"><a href="#Rust特点" class="headerlink" title="Rust特点"></a>Rust特点</h2><ul><li>Patterns and the match construct</li><li>a strong, static type system.</li><li>type inference</li><li>shadow</li><li>Rust uses the term panicking when a program exits with an error</li><li>requiring type annotations in function definitions</li><li>Rust’s goal is to compile programs into efficient binaries that <em>require as few runtime checks as possible</em></li><li>A foundational goal of Rust is to ensure that your programs never have undefined behavior</li></ul><h2 id="Chapter3-Common-Programming-Concepts"><a href="#Chapter3-Common-Programming-Concepts" class="headerlink" title="Chapter3 Common Programming Concepts"></a>Chapter3 Common Programming Concepts</h2><ul><li>constant v.s. variable<ol><li>Constants aren’t just immutable by default;they’re always immutable.</li><li>Constants can be declared in any scope</li><li>Constants may be set only to a constant expression, not the result of a value that could only be computed at runtime.</li></ol></li><li>shadow ends until<ol><li>it itself is shadowed </li><li>the scope ends</li></ol></li><li>Integer division truncates toward zero to the nearest integer</li><li>tuple和array区别<ol><li>tuple的各类型可以不同；</li><li>array的大小固定,在定义时就指定了</li><li>tuple更灵活,可存储不同类型,一般用于临时组合数据</li><li>array大小固定,用于存储大量相同类型的数据</li></ol></li><li>expression and statement<ol><li>Expressions do not include ending semicolons</li><li>statement does not return a value</li><li>the return value of the function is synonymous with <em>the value of the final expression in the block of the body of a function</em></li></ol></li><li>Control Flow<ol><li>This means the values that have the potential to be results from each arm of the if must be the same type</li><li>Rust does not have a concept of “truthy” or “falsy” values.So <em>The condition to an if-expression must be a boolean</em></li></ol></li></ul><h2 id="Chapter4-Understanding-Ownship"><a href="#Chapter4-Understanding-Ownship" class="headerlink" title="Chapter4 Understanding Ownship"></a>Chapter4 Understanding Ownship</h2><ul><li>The stack holds data associated with a specific function, while the heap holds data that can outlive a function</li><li>Rust does not allow programs to manually deallocate memory. That policy avoids the kinds of undefined behaviors shown above.</li><li>Box deallocation principle : If a variable owns a box, when Rust deallocates the variable’s frame, then Rust deallocates the box’s heap memory.</li><li>Moved heap data principle: if a variable x moves ownership of heap data to another variable y, then x cannot be used after the move.</li><li>A reference is a kind of pointer.</li><li>Rust implicitly inserts dereferences and references in certain cases, such as calling a method with the dot operator</li><li><em>Pointer Safety Principle</em>: data should never be aliased and mutated at the same time.</li><li>Permissions are defined on <em>paths</em> and not just variables. A path is anything you can put on the left-hand side of an assignment.</li><li>Creating a reference to data (“<em>borrowing</em>“ it) causes that data to be temporarily read-only until the reference is no longer used.</li><li>Rust’s borrow checker does not contain different paths for a[0], a[1], and so on. It uses a single path a[_] that represents all indexes of a.</li><li>Slices are special kinds of references because they are “fat” pointers, or pointers with metadata. Here, the metadata is the length of the slice.</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>优势<ol><li>improving runtime performance by avoiding garbage collection</li><li>improving predictability by preventing accidental “leaks” of data.</li></ol></li><li>Pointers can be created through <ol><li>boxes (pointers owning data on the heap) </li><li>references (non-owning pointers).</li></ol></li><li>move v.s. borrow<ul><li>A move of a variable with a non-copyable type (like Box<T> or String) requires the RO permissions, and the move eliminates all permissions on the variable. That rule prevents the use of moved variables:</li><li>Borrowing a variable (creating a reference to it) temporarily removes some of the variable’s permissions<ul><li>An immutable borrow creates an immutable reference, and also <em>disables the borrowed data from being mutated or moved.</em></li><li>A mutable borrow creates a mutable reference, which* disables the borrowed data from being read, written, or moved*</li></ul></li></ul></li><li>use-after-free: <em>Immutable borrows</em> remove the W permission to avoid use-after-free,</li><li>double-frees: Dereferences of references to non-copyable data do not have the O permission to avoid double-frees</li></ul><h2 id="Chapter5-Struct"><a href="#Chapter5-Struct" class="headerlink" title="Chapter5 Struct"></a>Chapter5 Struct</h2><ul><li>Rust <em>does not have a keyword for constructor functions</em>. The idiomatic way to define a constructor function is to make an associated function called new, but that is not enforced by the language.</li><li>tuple struct. e.g. <code>struct Color (i32,i32,i32);</code></li><li>Rust will insert as many references and dereferences as needed to make the types match up for the self parameter</li><li>Rust does not auto-derive Copy for stability across API changes. <code>#[derive(Copy, Clone)]</code></li><li>when you see an error like “cannot move out of *self”, that’s usually because you’re trying to call a self method on a reference like &amp;self or &amp;mut self. Rust is protecting you from a double-free</li></ul><h2 id="Chapter6-Enum"><a href="#Chapter6-Enum" class="headerlink" title="Chapter6 Enum"></a>Chapter6 Enum</h2><ul><li>advantage to using an enum rather than a struct:</li></ul><ol><li>each variant can have different types and amounts of associated data</li><li>the name of each enum variant that we define also becomes a function that constructs an instance of the enum</li><li>you can put any kind of data inside an enum variant: strings, numeric types, or structs, for example. You can even include another enum</li></ol><ul><li><p>The Option Enum </p><ol><li>the compiler can check whether you’ve handled all the cases you should be handling</li><li>a null is a value that is currently invalid or absent for some reason.</li><li>Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent.</li><li>The function Option::unwrap expects <em>self</em>, meaning it expects <em>ownership</em> of arg. However arg is an <em>immutable reference</em> to an option, so it cannot provide ownership of the option.</li></ol></li><li><p>match</p></li><li><p>Each match is tried from top to bottom</p></li><li><p>opt is a plain enum — its type is Option<String> and not a reference like &amp;Option<String>. Therefore a match on opt will move non-ignored fields like s. </p></li><li><p>If we want to peek into opt without moving its contents, the idiomatic solution is to match on a reference:</p></li><li><p><code>if let</code></p><ul><li>if let as syntax sugar for a match that runs code when the value matches one pattern and then ignores all other values.</li><li>The block of code that goes with the else is the same as the block of code that would go with the _ case in the match expression that is equivalent to the if let and else</li></ul></li></ul><h2 id="Chapter7-Managing-Growing-Projects-with-Packages-Crates-and-Modules"><a href="#Chapter7-Managing-Growing-Projects-with-Packages-Crates-and-Modules" class="headerlink" title="Chapter7 Managing Growing Projects with Packages, Crates, and Modules"></a>Chapter7 Managing Growing Projects with Packages, Crates, and Modules</h2><h3 id="Packages-A-Cargo-feature-that-lets-you-build-test-and-share-crates"><a href="#Packages-A-Cargo-feature-that-lets-you-build-test-and-share-crates" class="headerlink" title="Packages: A Cargo feature that lets you build, test, and share crates"></a>Packages: A Cargo feature that lets you build, test, and share crates</h3><ul><li>a bundle of one or more crates that provides a set of functionality.</li><li>A package can contain as many binary crates as you like, but at most only one library crate.</li><li>Using External Packages<ol><li>the standard std library is also a crate that’s external to our package.we <em>don’t</em> need to change Cargo.toml to include std. But <em>we do need to refer to it</em> with use to bring items from there into our package’s scope</li></ol></li></ul><h3 id="Crates-A-tree-of-modules-that-produces-a-library-or-executable"><a href="#Crates-A-tree-of-modules-that-produces-a-library-or-executable" class="headerlink" title="Crates: A tree of modules that produces a library or executable"></a>Crates: A tree of modules that produces a library or executable</h3><ul><li>Binary create: must have a function called <code>main</code></li><li>Library crates : define functionality intended to be shared with multiple projects.<br>Rustaceans say “crate”, they mean library crate, and they use “crate” interchangeably with the general programming concept of a <em>“library”</em>.</li></ul><h3 id="Modules-and-use-Let-you-control-the-organization-scope-and-privacy-of-paths"><a href="#Modules-and-use-Let-you-control-the-organization-scope-and-privacy-of-paths" class="headerlink" title="Modules and use: Let you control the organization, scope, and privacy of paths"></a>Modules and use: Let you control the organization, scope, and privacy of paths</h3><ul><li>用处<ol><li>let us organize code within a crate for readability and easy reuse</li><li>allow us to control the privacy of items, because code within a module is private by default</li></ol></li><li>parent and child<ol><li>all items (functions, methods, structs, enums, modules, and constants) <em>are private to parent modules</em> by default. </li><li>Items in a parent module can’t use the private items inside child modules, but items in child modules can use the items in their ancestor modules.</li></ol></li></ul><h3 id="Paths-A-way-of-naming-an-item-such-as-a-struct-function-or-module"><a href="#Paths-A-way-of-naming-an-item-such-as-a-struct-function-or-module" class="headerlink" title="Paths: A way of naming an item, such as a struct, function, or module"></a>Paths: A way of naming an item, such as a struct, function, or module</h3><ul><li>the idiomatic way<ol><li>Bringing the function’s parent module into scope with use</li><li>when bringing in structs, enums, and other items with use, it’s idiomatic to specify the full path</li></ol></li><li><code>use std::io::Result as IoResult;</code></li><li>we can use nested paths to bring the same items into scope in one line.<code>use std::&#123;cmp::Ordering, io&#125;;</code>,<code>use std::io::&#123;self, Write&#125;;</code></li></ul><h2 id="Chapter8"><a href="#Chapter8" class="headerlink" title="Chapter8"></a>Chapter8</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><ul><li>Reason for a reference to the first element care about changes at the end of the vector <ol><li>adding a new element onto the end of the vector might require allocating new memory and copying the old elements <em>to the new space</em></li><li>the reference to the first element would be pointing to <em>deallocated memory</em></li></ol></li><li>Vec::push moves its argument, so s is not usable after calling v.push(s)</li><li>When the vector gets dropped, all of its contents are also dropped, meaning the integers it holds will be cleaned up.</li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul><li>the compiler can coerce the &amp;String argument into a &amp;str  </li><li>Rust strings don’t support indexing to <em>avoid returning an unexpected value and causing bugs that might not be discovered immediately</em></li><li>three relevant ways to look at strings from Rust’s perspective<ol><li>bytes</li><li>scalar values</li><li>grapheme clusters</li></ol></li><li>The best way to operate on pieces of strings is to <em>be explicit about whether you want</em> characters or bytes</li><li>&amp;str is a promise that the byte sequence it points to will always be valid UTF-8</li></ul><h3 id="hash-map"><a href="#hash-map" class="headerlink" title="hash map"></a>hash map</h3><ul><li>Hash maps are useful when you want to look up data not by using an index, as you can with vectors, but by using a key that can be of any type</li><li>For types that implement the Copy trait, like i32, the values are copied into the hash map. - For <em>owned values</em> like String, the values will be moved and the hash map will be <em>the owner of those values</em></li></ul><h2 id="chapter10"><a href="#chapter10" class="headerlink" title="chapter10"></a>chapter10</h2><h3 id="Generic-Data-Types"><a href="#Generic-Data-Types" class="headerlink" title="Generic Data Types"></a>Generic Data Types</h3><ul><li>Rust instead requires you to state the expected capabilities of generic types up front</li><li>Without restrictions, a generic type T has no capabilities: it cannot be printed, cloned, or mutated (although it can be dropped).</li><li>Rust does not have inheritance-like mechanisms for specializing methods as you might find in an object-oriented language,</li><li>Monomorphization is the process of turning generic code into specific code by filling in the concrete types that are used when compiled</li><li>const 泛型： <code>const N : usize</code></li></ul><h3 id="trait"><a href="#trait" class="headerlink" title="trait"></a>trait</h3><ul><li>A trait defines functionality a particular type has and can share with other types.</li><li>One restriction to note is that we can implement a trait on a type only if at least one of the trait or the type is local to our crate.</li><li>Default implementations can call other methods in the same trait, even if those other methods don’t have a default implementation</li><li>traits in parameter<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_function</span>&lt;T:Display + <span class="hljs-built_in">Clone</span> ,U: <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Debug</span>&gt;(t:&amp;T,u:&amp;U) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&#123;&#125;<br><span class="hljs-comment">// Clearer Trait Bounds with where Clauses</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_function</span>&lt;T,U&gt;()(t:&amp;T,u:&amp;U) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span><br><span class="hljs-keyword">where</span> <br>  T:Display + <span class="hljs-built_in">Clone</span> ,<br>  U: <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Debug</span><br>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li>can only use impl Trait if you’re returning a single type</li><li>Using Trait Bounds to Conditionally Implement Methods<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    x: T,<br>    y: T,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(x: T, y: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123; x, y &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T: Display + <span class="hljs-built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">cmp_display</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.x &gt;= <span class="hljs-keyword">self</span>.y &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The largest member is x = &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.x);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The largest member is y = &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.y);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>conditionally implement a trait for any type that implements another trait<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">impl</span>&lt;T: Display&gt; <span class="hljs-built_in">ToString</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">T</span> &#123;<br>  <span class="hljs-comment">// --snip--</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="lifetime"><a href="#lifetime" class="headerlink" title="lifetime"></a>lifetime</h3><ul><li>Lifetime annotations don’t change how long any of the references live. Rather, they describe the relationships of the lifetimes of multiple references to each other without affecting the lifetimes</li><li>the names of lifetime parameters must start with an apostrophe (‘) and are usually all lowercase and very short</li><li>when we specify the lifetime parameters in this function signature, we’re not changing the lifetimes of any values passed in or returned. Rather, we’re specifying that the borrow checker should reject any values that don’t adhere to these constraints.</li><li>in early versions (pre-1.0) of Rust,every reference needed an explicit lifetime</li><li>The compiler uses <em>three rules</em> to figure out the lifetimes of the references when there aren’t explicit annotations.<ol><li>the compiler assigns a different lifetime parameter to each lifetime in each input type.</li><li>if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters</li><li>if there are multiple input lifetime parameters, but one of them is <code>&amp;self</code> or <code>&amp;mut self</code> because this is a <em>method</em>, the lifetime of self is assigned to all output lifetime parameters.</li></ol></li><li>The Static Lifetime <code>&#39;static</code><ul><li>The string literals is <em>stored directly in the program’s binary</em>, which is always available. Therefore, <em>the lifetime of all string literals is <code>&#39;static</code>.</em></li><li>‘static means “live for the entire program”, and so data under a static reference must never be deallocated.</li></ul></li><li>生命周期标注并不会改变任何引用的实际作用域</li></ul><h2 id="chapter11"><a href="#chapter11" class="headerlink" title="chapter11"></a>chapter11</h2><h3 id="The-output-from-running-the-automatically-generated-test"><a href="#The-output-from-running-the-automatically-generated-test" class="headerlink" title="The output from running the automatically generated test"></a>The output from running the automatically generated test</h3><ul><li>The 0 measured statistic is for benchmark tests that measure performance.</li><li><code>Doc-tests</code>  is for the results of any documentation tests</li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-built_in">assert!</span>();<br><span class="hljs-built_in">assert_eq!</span>();<br><span class="hljs-built_in">assert_ne!</span> <span class="hljs-comment">//  will pass if the two values we give it are not equal and fail if they’re equal.</span><br></code></pre></td></tr></table></figure><h3 id="Running-Tests-in-Parallel-or-Consecutively"><a href="#Running-Tests-in-Parallel-or-Consecutively" class="headerlink" title="Running Tests in Parallel or Consecutively"></a>Running Tests in Parallel or Consecutively</h3><ul><li>When you run multiple tests, <em>by default</em> they run in parallel using threads</li><li><code>cargo test -- --test-threads=1</code></li><li><code>cargo test -- --show-output</code></li><li><code>cargo test --help</code></li><li><code>cargo test -- --help</code></li><li><pre><code class="Rust">#[test]#[ignore]cargo test -- --ignoredcargo test -- --include-ignored</code></pre></li><li>We can specify part of a test name, and <em>any test whose name matches that value</em> will be run.</li></ul><h3 id="test-organization"><a href="#test-organization" class="headerlink" title="test-organization"></a>test-organization</h3><ul><li>Unit tests exercise different parts of a library separately and can test private implementation details.</li><li>Unit tests exercise different parts of a library separately and can test private implementation details.</li></ul><h2 id="chapter12"><a href="#chapter12" class="headerlink" title="chapter12"></a>chapter12</h2><ul><li>in cases where the desired function is nested in more than one module, we’ve chosen to <em>bring the parent module into scope</em> rather than the function.</li><li>TDD(Test Driven Develop)</li><li>Write a test that fails and run it to make sure it fails for the reason you expect.</li><li>Write or modify just enough code to make the new test pass.</li><li>Refactor the code you just added or changed and make sure the tests continue to pass.</li><li>Repeat from step 1!</li></ul><h2 id="chapter13"><a href="#chapter13" class="headerlink" title="chapter13"></a>chapter13</h2><ul><li>Rust will infer the types of arguments&#x2F;returns for closures, but not top-level functions</li><li>Closures can capture values from their environment in three ways<ol><li>borrowing immutably</li><li>borrowing mutably</li><li>taking ownership.</li></ol></li><li>Fn traits<ol><li>FnOnce</li><li>FnMut</li><li>Fn</li></ol></li><li>iterator adaptors are lazy, and we need to consume the iterator here.</li></ul>]]></content>
    
    
    <summary type="html">no panic</summary>
    
    
    
    <category term="学习" scheme="http://euds63.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="记录" scheme="http://euds63.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="Rust" scheme="http://euds63.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>《操作系统：设计与实现》笔记</title>
    <link href="http://euds63.github.io/2023/learn-os-vias-jyy/"/>
    <id>http://euds63.github.io/2023/learn-os-vias-jyy/</id>
    <published>2023-06-27T10:37:47.000Z</published>
    <updated>2023-10-07T05:32:04.521Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://space.bilibili.com/202224425/channel/collectiondetail?sid=192498">操作系统：设计与实现 (2022 春季学期)</a>的学习笔记</strong></p><h3 id="p3-多处理器编程：从入门到放弃-线程库；现代处理器和宽松内存模型"><a href="#p3-多处理器编程：从入门到放弃-线程库；现代处理器和宽松内存模型" class="headerlink" title="p3 多处理器编程：从入门到放弃 (线程库；现代处理器和宽松内存模型)"></a>p3 多处理器编程：从入门到放弃 (线程库；现代处理器和宽松内存模型)</h3><ul><li><p>并发程序的三个麻烦</p><ul><li>原子性</li><li>顺序</li><li>可见性</li></ul></li><li><p>gcc 编译</p><ul><li>不优化,并查看汇编代码<br><code>gcc -c -O1 sum.c &amp;&amp; objdump -d sum.o</code></li><li><code>asm volatile(&quot;&quot; : : &quot;memory&quot;); // compiler barrier</code></li></ul></li><li><p>统计次数<br><code> ./a.out | head -n 1000 | sort | uniq -c</code></p></li><li><p>现代处理器</p><ul><li>也是动态编译器：汇编指令也是由多个uop所组成的。</li><li>维护一个uop的“池子” 指令的有向无环图</li><li>乱序执行，顺序提交</li></ul></li></ul><h3 id="p4-理解并发程序执行-Peterson算法、模型检验与软件自动化工具"><a href="#p4-理解并发程序执行-Peterson算法、模型检验与软件自动化工具" class="headerlink" title="p4 理解并发程序执行 (Peterson算法、模型检验与软件自动化工具)"></a>p4 理解并发程序执行 (Peterson算法、模型检验与软件自动化工具)</h3><ul><li>C语言的形式语义<ul><li>全局变量加多个栈帧；每个栈帧有其局部变量和pc</li></ul></li><li>Peterson算法<ul><li>看上去是谦让的，但其实是自私的</li><li>证明正确性：画出状态机<ul><li>困境：不敢不画，不敢乱画</li><li>解决： <a href="https://jyywiki.cn/pages/OS/2022/demos/model-checker.py">model-checker</a></li><li>把程序的问题变成图论的问题<ul><li>safety 红色状态不可达</li><li>liveness : 从任意状态出发，都能到达绿&#x2F;蓝色状态 强连通分量</li></ul></li></ul></li><li>许多重要的想法，凝练以后就是概念</li></ul></li><li>并发程序 &#x3D; 状态机</li><li>Python generator<ul><li>e.g.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">numbers</span>(<span class="hljs-params">init=<span class="hljs-number">0</span>,step=<span class="hljs-number">1</span></span>):<br>    n = init<br>    <span class="hljs-keyword">while</span> Trye:<br>    n += step<br>    <span class="hljs-keyword">yield</span> n<br>g = numbers()<br>g.__next__()<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="p5-并发控制：互斥-自旋锁、互斥锁和-futex"><a href="#p5-并发控制：互斥-自旋锁、互斥锁和-futex" class="headerlink" title="p5 并发控制：互斥 (自旋锁、互斥锁和 futex)"></a>p5 并发控制：互斥 (自旋锁、互斥锁和 futex)</h3><ul><li>不能解决问题的时候，可以找到所依赖的假设，并大胆地打破它</li><li>spin 线程直接共享 locked</li><li>mutex 通过系统调用访问 locked</li><li>futex(Fast Userspace muTexes)<ul><li>Fast path: 一条原子指令，上锁成功立即返回</li><li>Slow path: 上锁失败，执行系统调用睡眠</li></ul></li></ul><h2 id="p6-并发控制：同步-条件变量、信号量、生产者-消费者和哲♂学家吃饭问题"><a href="#p6-并发控制：同步-条件变量、信号量、生产者-消费者和哲♂学家吃饭问题" class="headerlink" title="p6 并发控制：同步 (条件变量、信号量、生产者-消费者和哲♂学家吃饭问题)"></a>p6 并发控制：同步 (条件变量、信号量、生产者-消费者和哲♂学家吃饭问题)</h2><ul><li>思考： 有一堆任务，平均切分成n堆。有x个线程负责完成该任务(x &lt; n) 一个线程一次只能完成一个任务，完成后会自动去做下一个任务。要怎么实现？</li><li>有万能的方法，就要用万能的方法。<ul><li>他是这样诠释的。当项目代码量不大（一千行以内），项目还是比较好维护的，这时候用写聪明的写法没问题。但当项目到了几万行甚至几百万行时，这时候就需要多个人来进行协作。而人和人之间最大的障碍就是无法完全沟通，理解对方的心意。</li><li>不要试图用聪明的办法解决并发问题</li><li>个人想法：第一次听这种说法，有一定道理。</li></ul></li><li><h2 id="万能同步方法-——-条件变量-Conditional-Variables-API-wait-cv-mutex-💤-调用时必须保证已经获得-mutex-释放-mutex、进入睡眠状态-signal-x2F-notify-cv-💬-私信：走起-如果有线程正在等待-cv，则唤醒其中一个线程-broadcast-x2F-notifyAll-cv-📣-所有人：走起-唤醒全部正在等待-cv-的线程"><a href="#万能同步方法-——-条件变量-Conditional-Variables-API-wait-cv-mutex-💤-调用时必须保证已经获得-mutex-释放-mutex、进入睡眠状态-signal-x2F-notify-cv-💬-私信：走起-如果有线程正在等待-cv，则唤醒其中一个线程-broadcast-x2F-notifyAll-cv-📣-所有人：走起-唤醒全部正在等待-cv-的线程" class="headerlink" title="万能同步方法 —— 条件变量(Conditional Variables )- API  - wait(cv, mutex) 💤    调用时必须保证已经获得 mutex    释放 mutex、进入睡眠状态  - signal&#x2F;notify(cv) 💬 私信：走起    如果有线程正在等待 cv，则唤醒其中一个线程  - broadcast&#x2F;notifyAll(cv) 📣 所有人：走起    唤醒全部正在等待 cv 的线程"></a>万能同步方法 —— 条件变量(Conditional Variables )<br>- API<br>  - wait(cv, mutex) 💤<br>    调用时必须保证已经获得 mutex<br>    释放 mutex、进入睡眠状态<br>  - signal&#x2F;notify(cv) 💬 私信：走起<br>    如果有线程正在等待 cv，则唤醒其中一个线程<br>  - broadcast&#x2F;notifyAll(cv) 📣 所有人：走起<br>    唤醒全部正在等待 cv 的线程</h2>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 需要等待条件满足时</span><br>mutex_lock(&amp;mutex);<br><span class="hljs-keyword">while</span> (!cond) &#123;<br>  wait(&amp;cv, &amp;mutex);<br>&#125;<br>assert(cond);<br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 互斥锁保证了在此期间条件 cond 总是成立</span><br><span class="hljs-comment">// ...</span><br>mutex_unlock(&amp;mutex);<br><br><span class="hljs-comment">// 其他线程条件可能被满足时</span><br>broadcast(&amp;cv);<br></code></pre></td></tr></table></figure><ul><li>debug -&gt; 隔离出bug触发的最小条件</li></ul></li></ul><h2 id="p7-真实世界的并发编程-高性能计算-x2F-数据中心-x2F-人机交互中的并发编程"><a href="#p7-真实世界的并发编程-高性能计算-x2F-数据中心-x2F-人机交互中的并发编程" class="headerlink" title="p7 真实世界的并发编程 (高性能计算&#x2F;数据中心&#x2F;人机交互中的并发编程)"></a>p7 真实世界的并发编程 (高性能计算&#x2F;数据中心&#x2F;人机交互中的并发编程)</h2><ul><li>谈block chain &gt; 是个很好的技术。但觉得不太对。因为造成了相当大的资源浪费。</li><li><a href="https://www.youtube.com/watch?v=FFftmWSzgmk&ab_channel=Numberphile">What’s so special about the Mandelbrot Set? - Numberphile</a></li><li><a href="https://github.com/atanunq/viu">atanunq&#x2F;viu</a></li><li>搜索降低了知识的获取成本，ChatGPT等再一次降低了成本。</li><li>go语言，编程友好、性能优化</li><li>博客是web2.0 的第一步</li><li>Ajax (Asynchronous JavaScript + XML)</li><li>这次课中讲了三种并发编程，根据不同的需要，实现并发的方式也不同。</li></ul><h2 id="p8-并发-bug-和应对-死锁-x2F-数据竞争-x2F-原子性违反；防御性编程和动态分析"><a href="#p8-并发-bug-和应对-死锁-x2F-数据竞争-x2F-原子性违反；防御性编程和动态分析" class="headerlink" title="p8 并发 bug 和应对 (死锁&#x2F;数据竞争&#x2F;原子性违反；防御性编程和动态分析)"></a>p8 并发 bug 和应对 (死锁&#x2F;数据竞争&#x2F;原子性违反；防御性编程和动态分析)</h2><ul><li>软件是需求在计算机数字世界的投影。</li><li>assert的使用</li><li>没有工具不做系统</li><li>premature optimization is root of all evil</li><li>编程语言的缺陷——对程序员的完全信任：因为计算资源的宝贵</li><li>动态分析工具 <code>-fsanitize</code></li><li>Canary msvc 中 debug mode 的canary  <code>(b&#39;\xcc&#39; * 80).decode(&#39;gb2312&#39;)</code></li></ul><h2 id="p9-操作系统的状态机模型-操作系统的加载-thread-os-代码讲解"><a href="#p9-操作系统的状态机模型-操作系统的加载-thread-os-代码讲解" class="headerlink" title="p9 操作系统的状态机模型 (操作系统的加载; thread-os 代码讲解)"></a>p9 操作系统的状态机模型 (操作系统的加载; thread-os 代码讲解)</h2><ul><li>大学的真正意义:f将已有的知识和方法重新消化，为大家建立好 “台阶”，在有限的时间里迅速赶上数十年来建立起的学科体系。</li></ul><h2 id="p10-状态机模型的应用-细胞自动机-gdb-x2F-rr-x2F-perf-代码验证工具"><a href="#p10-状态机模型的应用-细胞自动机-gdb-x2F-rr-x2F-perf-代码验证工具" class="headerlink" title="p10 状态机模型的应用 (细胞自动机; gdb&#x2F;rr&#x2F;perf; 代码验证工具)"></a>p10 状态机模型的应用 (细胞自动机; gdb&#x2F;rr&#x2F;perf; 代码验证工具)</h2><ul><li>分布式系统也是一种并发程序，但要更复杂。因为并发程序假设了每个thread都能正常运行，而分布式系统则要考虑节点丢失的情况。</li></ul><h2 id="p11-操作系统上的进程-最小-Linux-fork-execve-和-exit"><a href="#p11-操作系统上的进程-最小-Linux-fork-execve-和-exit" class="headerlink" title="p11 操作系统上的进程 (最小 Linux; fork, execve 和 exit)"></a>p11 操作系统上的进程 (最小 Linux; fork, execve 和 exit)</h2><ul><li>Linux 操作系统启动流程<br>CPU Reset → Firmware → Loader → Kernel _start() → 第一个程序 &#x2F;bin&#x2F;init → 程序 (状态机) 执行 + 系统调用</li><li>Fork Bomb:<br><code>:()&#123;:|:&amp;&#125;;:</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">  :() &#123;         <span class="hljs-comment"># 格式化一下</span><br>  : | : &amp;<br>  &#125;; :<br>- stdout:<br>  终端: line buffer<br>  pipe , file :full buffer (除非显示地调用fflush)<br></code></pre></td></tr></table></figure></li><li><strong>fork</strong><ul><li>程序就是状态机，正在执行的程序也是状态机，fork创建状态机的副本；</li><li>创建的进程返回+1，子进程返回为0 </li><li>把所有的寄存器和内存都复制</li></ul></li><li><strong>execve</strong><ul><li>将当前运行的状态机重置成成另一个程序的初始状态</li></ul></li><li><strong>_exit</strong></li></ul><h2 id="p12-进程的地址空间-pmap-vdso-mmap-游戏修改器-x2F-外挂"><a href="#p12-进程的地址空间-pmap-vdso-mmap-游戏修改器-x2F-外挂" class="headerlink" title="p12 进程的地址空间 (pmap; vdso; mmap; 游戏修改器&#x2F;外挂)"></a>p12 进程的地址空间 (pmap; vdso; mmap; 游戏修改器&#x2F;外挂)</h2><ul><li>端序<ul><li>大端 (big endian): 低地址存放<em>高</em>有效字节</li><li>小端 (little endian): 低字节存放<em>低</em>有效字节</li></ul></li><li>工具使用<ul><li>gdb</li><li>readelf</li><li>pmap</li></ul></li><li>计算机世界没有魔法。因为程序就是状态机。</li><li>vdso:不进入操作系统内核，实现系统调用</li><li>mmap：  </li><li>文件&#x3D;字节序列；内存&#x3D;字节序列； everything is a file</li></ul><h2 id="p13-系统调用和-Shell-freestanding-shell-终端和-job-control"><a href="#p13-系统调用和-Shell-freestanding-shell-终端和-job-control" class="headerlink" title="p13 系统调用和 Shell (freestanding shell, 终端和 job control)"></a>p13 系统调用和 Shell (freestanding shell, 终端和 job control)</h2><ul><li>cd是内部命令：改变当前目录是用系统调用实现的</li><li><code>strace -f gcc a.c 2&gt;&amp;1 | vim -</code> This will pipe both stdout and stderr to vim. The <code>-</code> argument tells vim to read from stdin.</li><li><code>strace pmap 152 |&amp; vim - </code><br> <code>|&amp;</code> : This is a shorthand for <code>2&gt;&amp;1 |</code> in bash and zsh. It passes both standard output and standard error of one command as input to another.</li><li>fish, zsh 和 bash 都是常用的命令行 shell; sh是比较原始的</li><li>clear 清屏</li><li><code>,./a.out &amp;</code>  后台执行.&#x2F;a.out</li></ul><h2 id="p14-C-标准库的实现-系统调用的封装；内存空间管理"><a href="#p14-C-标准库的实现-系统调用的封装；内存空间管理" class="headerlink" title="p14 C 标准库的实现 (系统调用的封装；内存空间管理)"></a>p14 C 标准库的实现 (系统调用的封装；内存空间管理)</h2><ul><li>文件描述符还是不理解。印象中这是第二次谈到了”everything is a file”<ul><li>os的对象和对象的访问</li></ul></li><li>gdn的使用<ul><li><code>No symbol table is loaded.  Use the &quot;file&quot; command</code>。可能是编译选项未包含debug信息,如gcc没有添加-g选项。</li></ul></li><li>premature optimization is the root of all evil.</li><li>脱离workload谈优化就是耍流氓</li><li>经典的设计：<ul><li>fast path</li><li>slow path</li></ul></li></ul><h2 id="p15-fork-的应用-文件描述符的复制；写时复制；创建平行宇宙的魔法"><a href="#p15-fork-的应用-文件描述符的复制；写时复制；创建平行宇宙的魔法" class="headerlink" title="p15 fork 的应用 (文件描述符的复制；写时复制；创建平行宇宙的魔法)"></a>p15 fork 的应用 (文件描述符的复制；写时复制；创建平行宇宙的魔法)</h2><ul><li>fork 状态机复制包括持有的所有操作系统对象</li><li>包括持有的所有操作系统对象</li><li>文件描述符（file discriptor）<ul><li>一个指向操作系统内对象的 “指针”</li><li>dup() 的两个文件描述符是共享 offset</li></ul></li><li>访问空指针也会造成缺页中断</li><li>“Copy-on-write” 只有被写入的页面才会复制一份<ul><li>被复制后，整个地址空间都被标记为 “只读”</li><li>操作系统捕获 Page Fault 后酌情复制页面</li><li>fork-execve 效率得到提升</li></ul></li><li>操作系统会维护每个页面的引用计数</li><li>定义进程所占用的内存</li><li>page是归os所有的，而非进程</li><li>使用fork来搜索并行化。</li></ul><h2 id="p16-什么是可执行文件-调试信息；Stack-Unwinding；静态链接中的重定位"><a href="#p16-什么是可执行文件-调试信息；Stack-Unwinding；静态链接中的重定位" class="headerlink" title="p16 什么是可执行文件 (调试信息；Stack Unwinding；静态链接中的重定位)"></a>p16 什么是可执行文件 (调试信息；Stack Unwinding；静态链接中的重定位)</h2><ul><li>可执行文件描述了状态机，是一个描述了状态机的初始状态 + 迁移的数据结构</li><li>os没有魔法，所有东西都有解释</li><li><code>She-bang</code> <code>#! interpreter [optional-arg]</code></li><li>GNU binutils<ul><li>生成可执行文件<ul><li>ld (linker), as (assembler)</li><li>ar, ranlib</li></ul></li><li>分析可执行文件<ul><li>objcopy&#x2F;objdump&#x2F;readelf</li><li>addr2line, size, nm</li></ul></li></ul></li><li><code>objdump -d a.out | less</code> disasm</li><li><code>addr2line 401122 a.out</code></li><li>elf: 小精灵；dwarf：矮人</li><li>将一个 assembly (机器) 状态映射到 “C 世界” 状态很难</li><li>gcc等仍存在着许多不完美</li><li>编译器，汇编器，链接器</li></ul><h2 id="p17-动态链接和加载-静态-ELF-加载器实现；调试-Linux-内核；动态链接和加载"><a href="#p17-动态链接和加载-静态-ELF-加载器实现；调试-Linux-内核；动态链接和加载" class="headerlink" title="p17 动态链接和加载 (静态 ELF 加载器实现；调试 Linux 内核；动态链接和加载)"></a>p17 动态链接和加载 (静态 ELF 加载器实现；调试 Linux 内核；动态链接和加载)</h2><ul><li>自定义了一个二进制格式文件</li><li>GOT ： global offset table</li><li>PLT : procedure linkage table</li></ul><h2 id="p23-1-Bit-数据的存储-延迟线-x2F-磁芯-x2F-DRAM-x2F-SRAM-x2F-磁带-x2F-磁盘-x2F-光盘-x2F-Flash-SSD"><a href="#p23-1-Bit-数据的存储-延迟线-x2F-磁芯-x2F-DRAM-x2F-SRAM-x2F-磁带-x2F-磁盘-x2F-光盘-x2F-Flash-SSD" class="headerlink" title="p23 1-Bit 数据的存储 (延迟线&#x2F;磁芯&#x2F;DRAM&#x2F;SRAM&#x2F;磁带&#x2F;磁盘&#x2F;光盘&#x2F;Flash SSD)"></a>p23 1-Bit 数据的存储 (延迟线&#x2F;磁芯&#x2F;DRAM&#x2F;SRAM&#x2F;磁带&#x2F;磁盘&#x2F;光盘&#x2F;Flash SSD)</h2><ul><li>volatile: 确保该变量的实际值与内存中的值一致,每次读取都是最新值,也禁止编译器对其进行优化。</li><li>core dumped 磁性内存年代开始的概念。</li><li>局部性原理 -&gt; 可以按照大块来读写</li></ul><h2 id="p24-输入输出设备模型-串口-x2F-键盘-x2F-磁盘-x2F-打印机-x2F-总线-x2F-中断控制器-x2F-DMA-和-GPU"><a href="#p24-输入输出设备模型-串口-x2F-键盘-x2F-磁盘-x2F-打印机-x2F-总线-x2F-中断控制器-x2F-DMA-和-GPU" class="headerlink" title="p24 输入输出设备模型 (串口&#x2F;键盘&#x2F;磁盘&#x2F;打印机&#x2F;总线&#x2F;中断控制器&#x2F;DMA 和 GPU"></a>p24 输入输出设备模型 (串口&#x2F;键盘&#x2F;磁盘&#x2F;打印机&#x2F;总线&#x2F;中断控制器&#x2F;DMA 和 GPU</h2><ul><li>DMA: direct memory access : 一个专门执行”memcpy”程序的cpu</li><li>IPC: Instruction per second</li><li>GPU: <ul><li>一个通用计算设备</li><li>大量并行相似的任务</li></ul></li><li>异构计算：都能做，但选那个最合适的。（jjy在22年说的现在已经能感觉到有相关的趋势了。不过倒不是里面举例的挖矿，而是llm模型）</li></ul><h2 id="p25-设备驱动程序-Linux-设备驱动-GPU-和-CUDA-存储设备抽象"><a href="#p25-设备驱动程序-Linux-设备驱动-GPU-和-CUDA-存储设备抽象" class="headerlink" title="p25 设备驱动程序 (Linux 设备驱动; GPU 和 CUDA; 存储设备抽象)"></a>p25 设备驱动程序 (Linux 设备驱动; GPU 和 CUDA; 存储设备抽象)</h2><ul><li>设备抽象成 支持各类操作的对象 (文件)<ul><li>read - 从设备某个指定的位置读出数据</li><li>write - 向设备某个指定位置写入数据</li><li>ioctl - 读取&#x2F;设置设备的状态</li></ul></li><li><code>stty -a</code></li><li>GPU<ul><li>Single Instruction, Multiple Thread</li></ul></li><li>读优先的正确性</li></ul><h2 id="p26-文件系统-API-设备在应用间的共享；目录和文件-API"><a href="#p26-文件系统-API-设备在应用间的共享；目录和文件-API" class="headerlink" title="p26 文件系统 API (设备在应用间的共享；目录和文件 API)"></a>p26 文件系统 API (设备在应用间的共享；目录和文件 API)</h2><ul><li>信息的局部性</li><li>Windows从c盘开始时是受其前身Dos系统的影响，那个有a、b</li><li><code>mount disk.img  /mnt</code></li><li><code>umount /mnt</code></li><li>硬（hard）链接 <ul><li><code>ln /usr/local/python3 python</code></li><li>目录中仅存储指向文件数据的指针</li><li>允许一个文件被多个目录引用.</li><li>无法用来链接目录，也不能跨文件系统</li><li>通过<code>ls -i</code>查看是否为硬链接</li></ul></li><li>软 (symbolic) 链接<ul><li>“快捷方式”</li><li><code> ln -s ../p24 p24</code> </li><li>目录从“树”变为了“图”，还是有环图</li></ul></li><li><code>cd</code>的特殊性<ul><li>每个进程都有一个对应的工作目录（pwd），而这个目录只有系统调用才能够修改</li></ul></li></ul><h2 id="p27-FAT-和-UNIX-文件系统-数据结构视角的文件系统-FAT-手册导读和目录树遍历"><a href="#p27-FAT-和-UNIX-文件系统-数据结构视角的文件系统-FAT-手册导读和目录树遍历" class="headerlink" title="p27 FAT 和 UNIX 文件系统 (数据结构视角的文件系统; FAT 手册导读和目录树遍历)"></a>p27 FAT 和 UNIX 文件系统 (数据结构视角的文件系统; FAT 手册导读和目录树遍历)</h2><ul><li>数据结构的假设：数据是以字节来存储的。</li><li>RAM 和 block的区别</li><li>FAT(File Allocation Table)<ul><li>将指针集中存放在文件系统的某个区域</li><li>适合小文件</li><li>会产生碎片（fragmentation）</li><li>基本假设<ul><li>链表无环且长度和文件大小一致</li><li>FREE的cluster不能有入边</li></ul></li></ul></li><li>cluster </li><li>sector</li><li>ext2<ul><li>大文件的随机读写性能提升明显 (O(1))</li><li>支持链接 (一定程度减少空间浪费)</li><li>inode 在磁盘上连续存储，便于缓存&#x2F;预取</li><li>碎片</li></ul></li></ul><h2 id="p28-持久数据的可靠性-RAID-崩溃一致性-FSCK-和日志"><a href="#p28-持久数据的可靠性-RAID-崩溃一致性-FSCK-和日志" class="headerlink" title="p28 持久数据的可靠性 (RAID; 崩溃一致性; FSCK 和日志)"></a>p28 持久数据的可靠性 (RAID; 崩溃一致性; FSCK 和日志)</h2><ul><li>虚拟化<ul><li>cpu的虚拟化：通过分时等技术让多个进程并行，相当于虚拟出了多个cpu</li><li>内存的虚拟化：一份内存通过mmu，虚拟成每个进程的地址空间</li><li>RAID：反向的虚拟化：多个磁盘虚拟化一个磁盘</li></ul></li><li>RAID<ul><li>RAID0 : 交错排列： 提升容量和带宽</li><li>RAID1 : 提升容错和读带宽</li><li>RAID4 : 额外的一块校验盘<ul><li>致命缺陷：随机写的性能只能有校验盘性能的一半</li></ul></li><li>RAID5 : Rotating Parity</li></ul></li><li>RAID带来的联想：<br>多个磁盘虚拟化为一个又大又快又可靠的磁盘，多台电脑虚拟化为一个又大又快又可靠的电脑<br>那能不能多个神经网络虚拟化为一个更好的神经网络</li><li>崩溃一致性  (Crash Consistency)<ul><li>场景：写入的时候突然断电了怎么办？</li><li>方法1：按照一定顺序来写，且 “all or nothing”<ul><li>困难：磁盘不提供多块读写 “all or nothing” 的支持，甚至为了性能，没有顺序保证。</li></ul></li><li>方法2： File System Checking (FSCK)<ul><li>根据磁盘上已有的信息，恢复出 “最可能” 的数据结构</li><li>困难：难；如果修复的时候再掉一次电？</li></ul></li><li>方法3： 日志</li><li>具体：<ul><li>数据结构操作发生时，用 (2) append-only 记录日志</li><li>日志落盘后，用 (1) 更新数据结构</li><li>崩溃后，重放日志并清除 (称为 redo log；相应也可以 undo log)</li></ul></li><li>优化: journaling (jdb2)</li></ul></li></ul><h2 id="p30-现代存储系统-关系数据库和分布式存储系统"><a href="#p30-现代存储系统-关系数据库和分布式存储系统" class="headerlink" title="p30 现代存储系统 (关系数据库和分布式存储系统)"></a>p30 现代存储系统 (关系数据库和分布式存储系统)</h2><ul><li>数据库<ul><li>关键<ul><li>索引</li><li>查询优化</li></ul></li><li>magic：你只管写sql语句，相应的搜索优化它来做</li><li>要求：acid<ul><li>Atoming</li><li>Consistency</li><li>Isolation</li><li>Durability</li></ul></li></ul></li><li>图灵奖<ul><li>这门课听下来，听到了好多知识点背后都是获得过图灵奖的研究，甚至开创了一整个产业。</li></ul></li><li>关系型数据库跟不上社交网络的需求</li><li>cap theorem<ul><li>Consistency</li><li>Availability</li><li>Partition Tolerance</li></ul></li><li>分布式存储系统</li></ul><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>蒋炎炎这门课还是别人推荐的。第一次看到还不以为意，但出现的次数多了就觉得有必要去看看。发现是一大惊喜。</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ol><li>原版书能看得下来了。大段的英文，之前看着有点怕，现在觉得也能看下来，并且速度还可以。</li></ol><h2 id="课外资料"><a href="#课外资料" class="headerlink" title="课外资料"></a>课外资料</h2><ul><li><a href="https://plantegg.github.io/2022/06/05/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E5%BC%80%E9%94%80/">上下文切换的代价</a></li><li><a href="https://plantegg.github.io/2021/06/01/CPU%E7%9A%84%E5%88%B6%E9%80%A0%E5%92%8C%E6%A6%82%E5%BF%B5/">CPU的制造和概念</a></li></ul>]]></content>
    
    
    <summary type="html">操作系统就是状态机</summary>
    
    
    
    <category term="学习" scheme="http://euds63.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="记录" scheme="http://euds63.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="笔记" scheme="http://euds63.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://euds63.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统复习笔记</title>
    <link href="http://euds63.github.io/2023/learn-os/"/>
    <id>http://euds63.github.io/2023/learn-os/</id>
    <published>2023-06-19T10:35:11.000Z</published>
    <updated>2023-10-07T05:32:04.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="期末复习"><a href="#期末复习" class="headerlink" title="期末复习"></a>期末复习</h1><h2 id="Chpter-3-Process"><a href="#Chpter-3-Process" class="headerlink" title="Chpter 3 Process"></a>Chpter 3 Process</h2><ul><li>操作系统进行任务调度和资源分配的基本单位</li><li>Process include:<ol><li>Program code</li></ol><ul><li>text section</li></ul><p><br>2. program counter and processors’ registers<br>3. Stack</p><ul><li>Function parameters</li><li>Return address</li><li>Local variables</li></ul><ol start="4"><li>data section</li></ol><ul><li>Global variables</li></ul><ol start="5"><li>Heap</li></ol><ul><li>Dynamically allocated memory</li></ul></li><li>Process State<ul><li>五态模型<ul><li>new</li><li>ready:waiting to be assigned to a processor</li><li>waiting: waiting for some event to occur</li><li>running</li><li>terminated</li></ul></li></ul></li><li>Process control block（PCB）<ul><li>包含信息有：<ul><li>Process number</li><li>Process state</li><li>Program counter<ul><li>下条指令的地址</li></ul></li><li>CPU registers</li><li>CPU scheduling information</li><li>Memory-management information</li><li>Accounting information</li><li>I&#x2F;O status information</li></ul></li></ul></li></ul><h3 id="Process-Scheduling"><a href="#Process-Scheduling" class="headerlink" title="Process Scheduling"></a>Process Scheduling</h3><ul><li><p>Scheduling queues</p><ol><li>Job queue</li></ol><ul><li>set of all processes in the system</li><li>As processes&#x2F;job enter the system，they are put into the job queue</li></ul><ol start="2"><li>Ready queue</li></ol><ul><li>set of all processes residing in “(main) memory”, ready and “waiting” to execute</li></ul><ol start="3"><li>Device queues</li></ol><ul><li>set of processes waiting for an I&#x2F;O device</li></ul></li><li><p>Scheduler(调度器)</p><ol><li>Long-term scheduler or job scheduler</li></ol><ul><li>job queue -&gt; ready queue</li><li>may  be absent on Time-sharing system such as UNIX  and Windows<ul><li>They put every new process in memory for the short-term scheduler</li></ul></li></ul><ol start="2"><li>Short-term scheduler Or CPU scheduler: 进程调度</li></ol><ul><li>selects which process should be executed next and allocates CPU</li><li>因为其执行十分频繁，所以每次选择不能耗时太长，否则就overhead</li></ul><ol start="3"><li>Medium-term scheduler Or swapping</li></ol><ul><li>swap out: removes processes from memory to disk and reduces the degree of multiprogramming</li><li>swap in: introduce process into memory</li></ul></li><li><p>Context Switch</p><ul><li>CPU switches to another process</li></ul></li></ul><h3 id="Operations-on-Processes"><a href="#Operations-on-Processes" class="headerlink" title="Operations on Processes"></a>Operations on Processes</h3><ol><li>fork()<ul><li>The new process consists of a copy of the address space of the original process</li><li>The return code for the fork() is zero for the child process</li><li>子进程会复制父进程的地址空间和资源，但并不会复制父进程的线程</li></ul></li></ol><h3 id="Interprocess-Communication"><a href="#Interprocess-Communication" class="headerlink" title="Interprocess Communication"></a>Interprocess Communication</h3><ul><li>Shared memory</li><li>Message passing</li></ul><h3 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h3><ul><li>multiprogramming： is to have some process running at all times, to maximize CPU utilization</li><li>time sharing ： is to switch the CPU among processes so frequently that users can interact with each process</li></ul><h2 id="Chapter-4-Thread"><a href="#Chapter-4-Thread" class="headerlink" title="Chapter 4 Thread"></a>Chapter 4 Thread</h2><ul><li>进程 vs 线程<ul><li>线程是CPU的分布单位</li><li>进程是资源的分布单位</li><li>线程是进程中的执行单元<ul><li>一个进程可以包含多个线程，它们共享相同的地址空间和系统资源，如open files, signals。</li><li>每个线程有自己的栈空间和执行上下文，但它们在同一个进程内共享代码段、数据段和堆等资源。</li></ul></li></ul></li><li>benefits of multithreaded programming <ol><li>Responsiveness</li><li>Resource sharing</li><li>Economy</li><li>utilization of multiprocessor architectures</li></ol></li></ul><h3 id="Multithreading-Models"><a href="#Multithreading-Models" class="headerlink" title="Multithreading Models"></a>Multithreading Models</h3><ul><li><p>两种线程</p><ul><li>User Threads<ul><li>Provided by a thread library at the user level</li></ul></li><li>Kernel Threads<ul><li>Provided and managed by the OS directly</li></ul></li></ul></li><li><p>Relationship between kernel threads and user threads</p><ol><li>Many-to-one model</li><li>One-to-one model- </li><li>Many-to-many model</li><li>Two-level Model<ul><li>主体是Many-to-many model</li><li>A user thread (important task) can be bound to a kernel thread</li></ul></li></ol></li><li><p>Two versions of fork() in UNIX systems</p><ol><li>To duplicate all the threads<ul><li>If exec() is not called after forking, then to duplicate all threads</li></ul></li><li>To only duplicate the thread that invoked the fork() system call<ul><li>If exec() is called immediately after forking, then only to duplicate the calling threads</li></ul></li></ol></li></ul><h2 id="Chapter-5-CPU-Scheduling"><a href="#Chapter-5-CPU-Scheduling" class="headerlink" title="Chapter 5 CPU Scheduling"></a>Chapter 5 CPU Scheduling</h2><h3 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><ul><li>CPU scheduling decisions may take place when a process:<ol><li>Switches from running to waiting state<ul><li>The result of  an I&#x2F;O request</li><li>An invocation of wait for the termination of one of the child processes （e.g. wait(NULL);）</li></ul></li><li>Switches from running to ready state<ul><li>When a interrupt occurs</li></ul></li><li>Switches from waiting to ready<ul><li>Completion of I&#x2F;O</li></ul></li><li>Terminates</li></ol></li><li>Non-preemptive (非剥夺)<ul><li>Once the CPU has been allocated to a process, the process keeps the CPU until it releases the CPU </li><li>调度只可能发生在情况 1. 和 4.</li><li>简单，硬件要求低</li></ul></li><li>Preemptive(剥夺)</li></ul><h3 id="Scheduling-Criteria"><a href="#Scheduling-Criteria" class="headerlink" title="Scheduling Criteria"></a>Scheduling Criteria</h3><ol><li>CPU utilization</li><li>CPU throughout<ul><li>number of processes that complete their execution per time unit.</li></ul></li><li>Process turnaround time <ul><li>From the time of submission of a process to the time of completion, include<ul><li>Waiting to get into memory</li><li>Waiting in the ready queue</li><li>Executing on the CPU</li><li>Doing I&#x2F;O</li></ul></li></ul></li><li>Process waiting time (等待时间)<ul><li>amount of time that a process spent waiting in the ready queue.</li></ul></li><li>Process response time (响应时间)<ul><li>amount of the time from the submission of a request until the first response&#x2F;result is produced</li></ul></li></ol><h3 id="Scheduling-Algorithms"><a href="#Scheduling-Algorithms" class="headerlink" title="Scheduling Algorithms"></a>Scheduling Algorithms</h3><ol><li>First come first served (FCFS) <ul><li>non-preemptive</li><li>Convoy effect (护航效应)</li></ul></li><li>Shortest job first (SJF) <ul><li>minimum average waiting time </li><li>种类<ol><li>Preemptive SJF allows to preempt the currently executing process</li><li>Non-preemptive</li></ol></li><li>比较适用于长程调度</li></ul></li><li>Priority scheduling <ul><li>问题：starvation</li><li>解决： Aging (时效) – as time progresses increase the priority of the process</li></ul></li><li>Round robin (RR) <ul><li>Is designed for especially for time-sharing systems</li><li>preemptive</li><li>time quantum<ul><li>需要保证 80%的cpu bursts &lt; the time quantum</li></ul></li><li>Response time &#x3D; 2*(n-1)*q</li></ul></li><li>Multilevel queue algorithm </li><li>Multilevel feedback queue algorithm <ul><li>the most general scheduling algorithm</li></ul></li></ol><h3 id="Multiple-Processor-Scheduling"><a href="#Multiple-Processor-Scheduling" class="headerlink" title="Multiple-Processor Scheduling"></a>Multiple-Processor Scheduling</h3><ul><li>homogeneous vs. heterogeneous CPUs<ul><li>homogeneous: 各处理器都一样</li></ul></li><li>Approaches to multiple-processor scheduling<ul><li>Asymmetric multiprocessing <ul><li>only one processor (the master server) has all scheduling decision, I&#x2F;O processing</li></ul></li><li>Symmetric multiprocessing<ul><li>each processor is self-scheduling</li></ul></li></ul></li></ul><h2 id="Chapter-6-Process-synchronization"><a href="#Chapter-6-Process-synchronization" class="headerlink" title="Chapter 6 Process synchronization"></a>Chapter 6 Process synchronization</h2><ul><li>Race condition <ul><li>The situation where several processes access and manipulate shared data concurrently. </li><li>The final value of the shared data depends upon which process finishes last.</li></ul></li></ul><h3 id="The-Critical-Section-Problem"><a href="#The-Critical-Section-Problem" class="headerlink" title="The Critical-Section Problem"></a>The Critical-Section Problem</h3><ul><li><p>critical section</p><ul><li>Each process has a code segment, called critical section, in which the shared data is accessed</li><li>有几个共享变量就有几个临界区</li></ul></li><li><p>Criteria for the critical section problem solution</p><ol><li>Mutual exclusion 互斥</li><li>progress 空闲让进</li><li>Bounded waiting 有限等待</li></ol></li><li><p>Peterson’s Solution</p><ul><li>举手+令牌</li></ul></li><li><p>hardware-based solution </p><ul><li>关中断<ul><li>多处理机不适合</li></ul></li><li>原子操作</li></ul></li></ul><h3 id="Semaphores"><a href="#Semaphores" class="headerlink" title="Semaphores"></a>Semaphores</h3><ul><li><p>A Semaphore S – integer variable</p><ul><li>may be initialized via a non-negative value</li><li>Can only be accessed via two indivisible (atomic) operations: P() and V()</li></ul></li><li><p>P(): the wait() operation</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">wait <span class="hljs-comment">(S)</span> &#123; <br>  <span class="hljs-keyword">while</span> <span class="hljs-comment">(S.value &lt;= 0)</span> ; <span class="hljs-comment">// no-op</span><br>    S.value--;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>V() The signal() operation</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-title function_">signal</span>(<span class="hljs-params">S</span>)&#123;<br>  <span class="hljs-variable">S</span>.<span class="hljs-property">value</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>main problem : busy waiting (spinlock)</p><ul><li>advantages<ol><li>No context switch is required when a process must wait on a lock</li><li>If locks are expected to be held for short times, the spinlocks are useful</li></ol></li><li>disadvantages<ol><li>wastes the CPU cycles that can be used by other processes productively</li></ol></li><li>解决：modify the definition of the wait() and signal() <strong>适用于 multiprocessor system</strong><ul><li>Wait(): the process can block() itself rather than engaging in busy waiting</li><li>Signal(): change the blocking process from the waiting state to the ready state</li></ul></li></ul></li><li><p>implementation</p><ol><li>In a single-processor environment</li></ol><ul><li>Disable interrupt</li></ul><ol start="2"><li>In a multi-processor environment</li></ol><ul><li>Critical section can be applied</li></ul></li></ul><h2 id="Chapter-7-Deadlocks"><a href="#Chapter-7-Deadlocks" class="headerlink" title="Chapter 7 Deadlocks"></a>Chapter 7 Deadlocks</h2><ul><li>Necessary conditions<ol><li>Mutual exclusion</li><li>Hold and wait </li><li>No preemption</li><li>Circular wait</li></ol></li></ul><h3 id="Methods-for-Handling-Deadlocks"><a href="#Methods-for-Handling-Deadlocks" class="headerlink" title="Methods for Handling Deadlocks"></a>Methods for Handling Deadlocks</h3><ol><li><p>Prevention</p><ul><li>Provides a set of methods for ensuring that at least one of necessary conditions cannot be held</li><li>针对条件2： all or nothing; 没有资源的时候才去申请</li><li>针对条件3： 谦让； 抢夺</li><li>针对条件4： 顺序执行</li><li>缺点： low device utilization and reduce system throughput.</li></ul></li><li><p>Avoidance </p><ul><li>using the addition information,decide whether the current request can be satisfied or must be delay</li><li>方法：<ol><li>Resource-allocation graph<ul><li>有环：处于unsafe state;可能处于死锁状态</li></ul></li><li>Banker’s algorithm</li></ol></li></ul></li><li><p>Detection and recovery</p><ul><li>方法:<ul><li>Wait-for graph <ul><li>not appilcable to a resource-allocation system with multiple instances of each resource type</li></ul></li><li>Banker’s Algorithm</li></ul></li><li>When, and how often, to invoke detection algorithm. it depends on:<ul><li>How often a deadlock is likely to occur?</li><li>How many processes will need to be rolled back?</li></ul></li></ul></li><li><p>Ignorance</p></li></ol><h2 id="Chapter-8"><a href="#Chapter-8" class="headerlink" title="Chapter 8"></a>Chapter 8</h2><ul><li><p>Address may be represented in </p><ol><li>symbolic address</li><li>re-locatable address</li><li>absolute address</li></ol></li><li><p>address binding </p><ul><li>转换：<ul><li>symbolic address -&gt; re-locatable address : compiler</li><li>re-locatable address -&gt; absolute address : linkage editor or loader</li></ul></li><li>发生的时期<ol><li>Compile time<ul><li>If memory location known at compile time, absolute code can be generated</li><li>If memory location is not known at compile time, Must generate re-locatable code</li></ul></li><li>Load time （+linkage time）<ul><li>if memory location is known at load time, absolute code can be generated at this time</li></ul></li><li>Execution time<ul><li>If memory location is not known at compile time and load time, Binding is delayed until run time</li><li>absolute code must be generated at run time</li></ul></li></ol></li></ul></li></ul><h3 id="Logical-vs-Physical-Address-Space"><a href="#Logical-vs-Physical-Address-Space" class="headerlink" title="Logical vs. Physical Address Space"></a>Logical vs. Physical Address Space</h3><ul><li><p>Logical address ：CPU</p><ul><li>also referred to as virtual address</li><li>重定位地址和逻辑地址没有直接关系</li></ul></li><li><p>Physical address ：memory unit </p></li><li><p>logical (virtual) and physical addresses differ in execution-time address-binding scheme</p><ul><li>re-locatable code are seen by CPU</li><li>absolute code are seen by the memory unit</li></ul></li><li><p>Memory-Management Unit (MMU)</p><ul><li>Hardware device that maps virtual address to physical address in the run-time</li></ul></li><li><p>Dynamic load</p><ul><li>not loaded the entire program and data of a process be in physical memory for the process to execute until it is called</li><li>好处： <ol><li>Better memory-space utilization</li><li>No special support is required from the operating system</li></ol></li></ul></li><li><p>Dynamic linking</p><ul><li>Linking is postponed until execution time</li><li>requires help from the OS</li></ul></li></ul><h3 id="Contiguous-Memory-Allocation"><a href="#Contiguous-Memory-Allocation" class="headerlink" title="Contiguous Memory Allocation"></a>Contiguous Memory Allocation</h3><ol><li>Fixed-Sized Contiguous Partition<ul><li>Strengths (advantages)<ul><li>Simple to implement</li><li>little overhead</li></ul></li><li>Weaknesses(drawbacks)<ul><li>internal fragmentation<ul><li>allocated memory may be larger than requested memory</li></ul></li><li>fixed number of processes</li></ul></li></ul></li><li>Dynamic Contiguous partition（可变分区）<ul><li>Hole – block of available memory</li><li>Allocation algorithms <ol><li>first fit:<ul><li>从头开始，或者是从当前位置开始</li></ul></li><li>best-fit <ul><li>Need to search all entire list, unless the list is ordered by size</li><li>produces the smallest leftover hole that may be wasted</li></ul></li><li>worst-fit<ul><li>Need to search all entire list, unless the list is ordered by size</li><li>小进程多的 效果好</li></ul></li></ol></li><li>问题：<ul><li>External Fragmentation</li></ul></li></ul></li></ol><ul><li><p>Solutions to fragmentation</p><ol><li>Compaction(紧凑)<ul><li>To reduce external fragmentation</li><li>Shuffle memory contents to place all free memory together in one large block</li><li>It is done at execution time， it’s possible only if relocation is dynamic</li><li>May be expensive in moving the processes and the holes</li></ul></li><li>paging</li><li>segmentation</li></ol></li><li><p>Disadvantage of Contiguous Memory Allocation</p><ul><li>Fragmentation in main memory</li><li>Compaction is impossible on the disk</li></ul></li></ul><h3 id="paging"><a href="#paging" class="headerlink" title="paging"></a>paging</h3><ul><li><p>frame: Divide physical memory into fixed-sized blocks </p></li><li><p>page : Divide logical memory into fixed-sized blocks </p><ul><li>page size is equal to frame size</li><li>Finding n free frames for loading a program of size n pages</li></ul></li><li><p>Translating logical address to physical address<br>If the address space is 2^m and the page size is 2^n</p><ul><li>Every logical address generated by CPU is divided into:<ol><li>Page number (p: 页号) <ul><li>used as an index into a page table</li><li>页表中包含每一页在physical memory 的 base address (f:块号)</li><li>p &#x3D;address&#x2F;2^n   is equal to m-n bit of the address</li></ul></li><li>Page offset (d: 偏移) <ul><li>combined with base address (f:块号) to define the physical memory address that is sent to the memory unit</li><li>d &#x3D;address%2n is equal to n bit of the address</li></ul></li></ol></li><li>Physical address <ol><li>frame number（f: 帧号、块号)</li><li>page offset      (d:页偏移、块偏移)</li></ol></li></ul></li><li><p>page size的选择</p><ul><li>越大： <ul><li>Disk I&#x2F;O is more efficient</li><li>page table size 越小</li></ul></li><li>越小：<ul><li>internal fragmentation 越小</li></ul></li></ul></li><li><p>Frame table (主存分块表)</p><ul><li>Has one entry for each physical page frame<br>Indicating <ul><li>whether the frame is free or it is allocated to which process</li></ul></li></ul><p></p></li><li><p>page table</p><ul><li>each process must maintain a copy of the page table </li><li>计算<ul><li>if page-table entry is 4 bytes long<ul><li>Can point to one of 2^32 physical page frames (1比特&#x3D;8字节)</li><li>If frame size(&#x3D; page size) is 4KB, the system can address 2^44 bytes(2^32×2^12&#x3D;16TB) of physical memory</li></ul></li><li>对于32位cpu<ul><li>page size: 4k (&#x3D;2^12)</li><li>Table size：2^32&#x2F;2^12&#x3D;1M </li><li>each entry’s size : 4 bytes</li><li>page table 的大小为： 4 MB</li></ul></li></ul></li><li>位置<ol><li>直接存放在寄存器中：<ul><li>Efficient and expensive</li><li>当page table is reasonable small 时可以</li></ul></li><li>存放在main memory ，然后用Page-table base register (PTBR：页表基址寄存器)存放其位置<ul><li>进程切换时，加载页表只需要改变PTBR</li><li>every data&#x2F;instruction access requires two memory accesses<ul><li>One for the page table</li><li>One for the data&#x2F;instruction</li></ul></li></ul></li><li>Translation Look-aside Buffer (TLB) also called Associate Memory(联想寄存器)<ul><li>并行查找</li><li>contains only a few of page-table entries</li></ul></li></ol></li></ul></li></ul><h3 id="Structure-of-the-Page-Table"><a href="#Structure-of-the-Page-Table" class="headerlink" title="Structure of the Page Table"></a>Structure of the Page Table</h3><ul><li>问题: The page table can be excessively large</li><li>Solution： Divide the page table into smaller pieces<ol><li>Hierarchical Paging （分层页表）</li><li>Hashed Page Tables（哈希页表）</li><li>Inverted Page Tables（反置页表）</li></ol></li></ul><ol><li>Hierarchical Paging （分层页表）<ul><li>缺陷：</li></ul><ol><li>需遍历，进程太多</li><li>可能有共享，而进程号只能填一个</li><li>不适用于64位</li></ol><ul><li>好：<ol><li>需要的空间小</li></ol></li></ul></li><li>Hashed Page Tables<ul><li>hash table -&gt; 在链表中遍历匹配</li></ul></li><li>Inverted Page Table(反置页表&#x2F;主存分块表)</li></ol><ul><li>Only a page table in the system</li><li>One entry for each real page (or physical frame) of memory</li><li>缺点：<ul><li>increases time needed to search the table when a page reference occurs</li><li>Lead to memory share difficulty</li></ul></li></ul><h3 id="segmentation"><a href="#segmentation" class="headerlink" title="segmentation"></a>segmentation</h3><ul><li>User’s View of a Program: A program is a collection of segments，a segment is a logical unit such as:<ul><li>main program<ul><li>procedure ，function，method，object</li><li>local variables, global   variables</li><li>common block</li><li>stack</li><li>symbol table</li><li>arrays</li></ul></li></ul></li></ul><h2 id="Chapter-9-Virtual-Memory"><a href="#Chapter-9-Virtual-Memory" class="headerlink" title="Chapter 9 Virtual Memory"></a>Chapter 9 Virtual Memory</h2><ul><li><p>the entire program is not needed to be in physical memory.这样的好处有：</p><ul><li>程序的大小不再受内存所限制</li><li>更多程序可以同时运行</li><li>Less I&#x2F;O would be needed to load or swap each user program into memory, so program would start to run faster</li></ul></li><li><p>Virtual memory management </p><ul><li>a term used to describe a technique whereby the computer appears to have much more memory than it actually does</li></ul></li><li><p>Virtual memory can be implemented via:</p><ul><li>Demand paging </li><li>Demand segmentation</li></ul></li></ul><h3 id="Demand-paging"><a href="#Demand-paging" class="headerlink" title="Demand paging"></a>Demand paging</h3><ul><li><p>思想： Bring a page into memory only when it is needed</p><ul><li>Be similar to a paging system with swapping</li></ul></li><li><p>Hardware</p><ul><li>Page table. 需要加一位valid–invalid bit <ul><li>v -》 The page is legal and in memory</li></ul></li><li>Secondary memory<ul><li>A high-speed disk, Swap space</li><li>Hold those page that are not present in memory</li></ul></li></ul></li><li><p>Page Fault</p><ul><li>Access to a page marked invalid causes a page-fault trap</li><li>handle<ol><li>Operating system looks at another table (PCB) to decide:<ul><li>Invalid reference -&gt; abort</li><li>Just not in memory（go on to 2））</li></ul></li><li>Get empty frame</li><li>Swap the desired page into the frame</li><li>modify the page table, Set validation bit &#x3D; v</li><li>Restart the instruction that caused the page fault</li></ol></li><li>特殊：<ol><li>一条指令可产生多个缺页中断</li><li>指令复执</li><li>在指令执行时中断。</li></ol></li><li>对比普通中断：<ul><li>一条指令在执行完后，检查是否有中断请求<ul><li>有：执行中断</li><li>无：执行下一条指令</li></ul></li></ul></li></ul></li></ul><h3 id="Page-Replacement"><a href="#Page-Replacement" class="headerlink" title="Page Replacement"></a>Page Replacement</h3><p><strong>替换算法</strong></p><ol><li><p>FIFO page Replacement</p><ul><li>Belady’s Anomaly : more frames -&gt; more page faults</li></ul></li><li><p>Optimal Page Replacement (OPT) </p><ul><li>替换最晚才用的页 或 后面最长时间用不到的页</li></ul></li><li><p>Least Recently Used (LRU) Algorithm</p><ul><li>思想： The recent past as an approximation of the near future</li><li>实现：</li><li>counters</li><li>stack</li></ul></li><li><p>LRU Approximation Algorithms</p><ol><li>Additional-reference-bits algorithm</li><li>Second chance (clock) </li><li>Enhanced second-chance algorithm</li></ol></li><li><p>Counting-Based Page Replacement </p><ul><li>Least Frequently used </li><li>Most Frequently used</li></ul></li><li><p>Page-Buffering Algorithm</p><ul><li>Assistant procedure to a page-replacement algorithm</li></ul></li></ol><h3 id="Allocation-of-Frames"><a href="#Allocation-of-Frames" class="headerlink" title="Allocation of Frames"></a>Allocation of Frames</h3><ul><li><p>Two major allocation schemes</p><ol><li>fixed allocation<ul><li>Equal allocation</li><li>Proportional allocation</li></ul></li><li>priority allocation<ul><li>Use a proportional allocation scheme using priorities rather than size</li></ul></li></ol></li><li><p>Global vs. Local Allocation</p><ol><li>Local replacement<ul><li>To allow a process to select from only its own set of allocated frames. </li><li>Cannot increase the number of frames allocated</li><li>Not affected by external circumstances</li></ul></li><li>Global replacement<ul><li>To allow a process to select a replacement frame from the set of all frames, even if that frame is currently allocated to some other process</li><li>Can increase the number of frames allocated</li><li>Cannot control its page-fault rate.</li></ul></li></ol><ul><li>In general, global replacement is better.</li></ul></li></ul><h3 id="Thrashing"><a href="#Thrashing" class="headerlink" title="Thrashing"></a>Thrashing</h3><ul><li>A process is thrashing （颠簸）if it is spending more time paging than executing</li><li>approach<ol><li>Using a local replacement algorithm</li><li>Working-set strategy <ul><li>To compute the working-set size for each process in the system</li></ul></li><li>Page-Fault Frequency (PFF) Scheme  (水多了加面，面多了加水)<ul><li>If actual rate too low, remove  a frame from the process</li><li>If actual rate too high, allocate another frame to the process</li><li>If no frames are free, suspend it</li></ul></li></ol></li></ul><h3 id="Other-Considerations"><a href="#Other-Considerations" class="headerlink" title="Other Considerations"></a>Other Considerations</h3><ul><li>page size 大小的选择要考虑到：<ol><li>内碎片</li><li>页表的大小</li><li>I&#x2F;O overhead (seek time, latency time, transfer time)</li><li>Locality</li><li>Page fault rate<ul><li>顺序访问： page size越大，则缺页中断率越小</li><li>随机访问： page size越大，则more paging action could ensue because fewer pages can be kept in memory and more data is transferred per page fault.</li></ul></li></ol></li><li>Install a faster hard disk, or multiple controllers with multiple hard disks<ul><li>for as the disk bottleneck is removed by faster response and more throughput to the disks, the CPU will get more data more quickly</li></ul></li></ul><h2 id="Chapter-10-File-System-Interface"><a href="#Chapter-10-File-System-Interface" class="headerlink" title="Chapter 10 File-System Interface"></a>Chapter 10 File-System Interface</h2><ul><li>File <ul><li>A file is named collection of related information that is recorded on secondary storage</li><li>Six basic operations<ol><li>create</li><li>read&#x2F;write&#x2F;seek</li><li>delete</li><li>truncate: to erase the contents of a file but keep its attributes except for it’s length</li></ol></li><li>Assistant operations<ul><li>open(F):<ol><li>search the directory structure on disk for entry F</li><li>copy the directory entry into the open-file table</li><li>allocate a file descriptor</li></ol></li><li>close(F):<ol><li>copy the directory entry in the open-file table to the directory structure on disk</li><li>free the file descriptor</li></ol></li></ul></li></ul></li></ul><h3 id="Access-Methods"><a href="#Access-Methods" class="headerlink" title="Access Methods"></a>Access Methods</h3><ul><li>The information in the file can be accessed in<ol><li>sequentical access</li><li>direct access</li><li>other access <ul><li>involve the construction of an index for the file</li></ul></li></ol></li></ul><h3 id="Directory-Structure"><a href="#Directory-Structure" class="headerlink" title="Directory Structure"></a>Directory Structure</h3><ul><li><p>symbol table </p><ul><li>The directory can be viewed as a symbol table that translates file names into their directory entries</li></ul></li><li><p>Criteria </p><ol><li>efficiency</li><li>naming</li><li>grouping</li></ol></li><li><p>shemes </p><ol><li>Single-Level Directory</li><li>Two-Level Directory<ul><li>Positive<ul><li>Efficient searching</li></ul></li><li>Negative<ul><li>No grouping capability</li><li>Difficult to share file among different users</li></ul></li></ul></li><li>Tree-Structured Directories<ul><li>Positive<ul><li>Efficient searching</li><li>Grouping Capability</li></ul></li><li>Negative<ul><li>Difficult to share file among different users</li></ul></li></ul></li><li>Acyclic-Graph Directories<ul><li>Tree-structured directory + shared subdirectories or files</li><li>Created a new directory entry  called a link to implement sharing</li><li>The difficulty is to avoid cycles as new links are added</li></ul></li><li>General Graph Directory<ul><li>Add the links to an existing tree-structure directory</li><li>Acyclic-Graph Directories更好</li></ul></li></ol></li><li><p>硬（hard）链接 </p><ul><li><code>ln /usr/local/python3 python</code></li><li>目录中仅存储指向文件数据的指针</li><li>允许一个文件被多个目录引用.</li><li>无法用来链接目录，也不能跨文件系统</li><li>通过<code>ls -i</code>查看是否为硬链接</li></ul></li><li><p>软 (symbolic) 链接</p><ul><li>“快捷方式”</li><li>软链接也是一个文件</li><li><code> ln -s ../p24 p24</code> </li><li>目录从“树”变为了“图”，还是有环图</li></ul></li><li><p>ACL: access-control list</p><ul><li>Each file or directory has an ACL</li></ul></li></ul><h2 id="File-System-Implementation"><a href="#File-System-Implementation" class="headerlink" title="File-System Implementation"></a>File-System Implementation</h2><ul><li>File system organized into layers<ol><li>application program</li><li>logical file system<ul><li>FCB: file control blocks</li></ul></li><li>file-organizational module</li><li>basic file system</li><li>I&#x2F;O control</li><li>devices</li></ol></li></ul><h3 id="Allocation-Methods"><a href="#Allocation-Methods" class="headerlink" title="Allocation Methods"></a>Allocation Methods</h3><ul><li><p>An allocation method refers to how disk blocks are allocated for files</p></li><li><p>Contiguous allocation</p><ul><li>Each file occupies a set of contiguous blocks on the disk</li><li>Supports both sequential access and direct access （Random access）</li><li>问题：<ol><li>External fragmentation </li><li>Files cannot grow</li></ol></li></ul></li><li><p>Linked allocation</p><ul><li>Each file is a linked list of disk blocks: blocks may be scattered anywhere on the disk</li><li>优点<ol><li>容易实现</li><li>无外碎片</li><li>文件增长方便</li></ol></li><li>缺点：<ol><li>No random access</li><li>Poor reliability</li><li>慢（链表是保存在磁盘上的，所以需要多次查询）</li></ol></li><li>改进： File-allocation table (FAT) <ul><li>把链表信息放到了一个单独的FAT表中，而不是各个数据块中，且进行备份</li></ul></li></ul></li><li><p>Indexed allocation</p><ul><li><p>Bringing all the pointers together into one location: index block </p></li><li><p>Solutions to large files</p><ol><li>Linked sheme<ul><li>Link blocks of index table</li></ul></li><li>Multilevel index</li><li>Combined scheme<ul><li>一部分是 direct pointers ，一部分是multi-indirect block</li></ul></li></ol></li><li><p>Criteria</p><ol><li>storage utilization efficiency</li><li>data block access time</li></ol><ul><li>Contiguous allocation: Good for known-size file</li><li>Linked allocation: Good for storage utilization </li><li>Indexed allocation: Access time depends on index structure, file size, block position</li></ul></li></ul></li></ul><h3 id="Free-Space-Management"><a href="#Free-Space-Management" class="headerlink" title="Free-Space Management"></a>Free-Space Management</h3><ul><li>The free-space list 的实现<ol><li>Bit vector<ul><li>优点<ul><li>Simple to implement </li><li>Efficient to find the first free block</li></ul></li><li>缺点<ul><li>Bit map requires extra space</li><li>Inefficient unless the entire vector is kept in main memory</li></ul></li></ul></li><li>Linked Lists (free list)<ul><li>优点<ul><li>No waste of space</li></ul></li><li>缺点<ul><li>Inefficient when traversing the list</li></ul></li></ul></li><li>Grouping</li></ol><ul><li>The first free block store the addresses of n free blocks</li><li>Easier to find a large number of free blocks</li></ul></li></ul><h2 id="Mass-Storage-Systems"><a href="#Mass-Storage-Systems" class="headerlink" title="Mass-Storage Systems"></a>Mass-Storage Systems</h2><ul><li><p>Magnetic disk’s structure</p><ul><li>Disk platter</li><li>track</li><li>sector<ul><li>each track is subdivided into several sectors</li></ul></li><li>cylinder<ul><li>is the set of tracks that are at one arm position</li></ul></li></ul></li><li><p>CLV vs. CAV</p><ol><li>ClV : constant linear velocity<ul><li>CD-ROM， DVD-ROM</li><li>Tracks in the outermost zone hold more sectors</li></ul></li><li>CAV : constant angular velocity<ul><li>Magnetic disk</li><li>The density of bits decreases from inner tracks to outer tracks to keep the data rate constant</li></ul></li></ol></li></ul><h3 id="Disk-Scheduling"><a href="#Disk-Scheduling" class="headerlink" title="Disk Scheduling"></a>Disk Scheduling</h3><ul><li>Access time <ol><li>Seek time is the time for the disk are to move the heads to the cylinder containing the desired sector<ul><li>Seek time  seek distance</li></ul></li><li>Rotational latency<ul><li>waiting for the disk to rotate the desired sector to the disk head</li></ul></li></ol></li><li>Disk bandwidth<ul><li>The total number of bytes transferred &#x2F; the total time  between the first request for service and the completion of the last transfer</li></ul></li></ul><ol><li>FCFS Scheduling</li><li>SSTF：Shortest-seek-time-first (SSTF)<ul><li>最短寻道时间优先</li><li>问题：<ul><li>往返跑—距离很短，但速度不一定很快</li><li>may cause starvation of some requests</li></ul></li></ul></li><li>SCAN</li></ol><ul><li>Sometimes called the elevator algorithm</li></ul><ol start="4"><li>C-SCAN (Circular SCAN)</li></ol><ul><li>The head moves from one end of the disk to the other, servicing requests as it goes</li><li>When it reaches the other end, however, it immediately returns to the beginning of the disk, without servicing any requests on the return trip</li><li>回途不载客</li></ul><ol start="5"><li>LOOK &#x2F; C-LOOK</li></ol><ul><li><p>Similar to SCAN&#x2F;C-SCAN  </p></li><li><p>Arm only goes as far as the last request in each direction, then reverses direction immediately, without first going all the way to the end of the disk.</p></li><li><p>选择<br><strong>Performance depends on the number and types of requests</strong></p><ul><li>SCAN and C-SCAN perform better for systems that place a heavy load on the disk</li><li>Either SSTF or LOOK is a reasonable choice for the default algorithm</li></ul></li></ul><h3 id="Disk-Management"><a href="#Disk-Management" class="headerlink" title="Disk Management"></a>Disk Management</h3><ul><li>Disk formatting<ul><li>Low-Level Formatting (physical formatting )<ul><li>Dividing a disk into sectors that the disk controller can read and write</li></ul></li><li>logical Formatting<ul><li>Creation of a file system</li><li>Build the metadata structures for a file system</li></ul></li></ul></li></ul><h3 id="RAID-Structure"><a href="#RAID-Structure" class="headerlink" title="RAID Structure"></a>RAID Structure</h3><ul><li><p>Redundant Array of Inexpensive Disks (past)</p></li><li><p>Redundant Array of Independent Disks (now)</p><ul><li>Used for their higher reliability and higher data-transfer rate(performance)</li></ul></li><li><p>levels</p><ol><li>RAID 0<ul><li>Disk arrays with data striping at the level of blocks but without any redundancy</li></ul></li><li>RAID 1<ul><li>Disk mirroring</li></ul></li><li>RAID 2<ul><li>Bit-level striping or Byte-level striping</li><li>Memory-style error-correcting-code (ECC)</li></ul></li><li>RAID 3<ul><li>Bit-interleaved parity</li></ul></li><li>RAID 4<ul><li>Block-interleaved parity organization</li></ul></li><li>RAID 5<ul><li>Block-interleaved distributed parity</li></ul></li></ol></li></ul><hr><h2 id="常用单词"><a href="#常用单词" class="headerlink" title="常用单词"></a>常用单词</h2><ul><li>simultaneously : 同时地</li><li>idle : 空闲，懒</li><li>reside : 位于，居住</li><li>uni-processor : 单处理器</li><li>interleave: 交织</li><li>allocation : 分配</li><li>dashed line ： 虚线</li><li>minuscule : 微小的</li><li>concrete : 具体的</li><li>mandatory: 强制的</li><li>mediate : 调解</li><li>strip : 脱掉；条</li></ul>]]></content>
    
    
    <summary type="html">操作系统复习笔记</summary>
    
    
    
    <category term="学习" scheme="http://euds63.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="笔记" scheme="http://euds63.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://euds63.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>软工导论复习笔记</title>
    <link href="http://euds63.github.io/2023/learn-introdue-to-se/"/>
    <id>http://euds63.github.io/2023/learn-introdue-to-se/</id>
    <published>2023-06-16T10:28:40.000Z</published>
    <updated>2023-10-07T05:32:04.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软工导论复习"><a href="#软工导论复习" class="headerlink" title="软工导论复习"></a>软工导论复习</h1><h2 id="Chapter-0"><a href="#Chapter-0" class="headerlink" title="Chapter 0"></a>Chapter 0</h2><ul><li><p>软件工程提出时间：1968年</p><p>  1968年北大西洋公约组织(NATO)的计<br>  算机科学家在联邦德国召开国际会议，<br>  讨论软件危机问题，正式提出了“软件<br>  工程”。</p></li></ul><h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><ul><li>The nature of software<br>Developed &#x2F; Deteriorates &#x2F; Custom built&#x2F; Complex</li></ul><h2 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h2><ul><li><p>软件工程定义</p><ol><li>The application of a systematic,<br>  disciplined, quantifiable approach to the<br>  development, operation, and maintenance<br>  of software; that is, the application of<br>  engineering to software.</li><li>The study of approaches as in (1).</li></ol></li><li><p>Software Process</p><ul><li>why: 需要及时的反馈</li><li>Process framework <ul><li>Framework activities<ul><li>Communication</li><li>Planning</li><li>Modeling<ol><li>需求分析</li><li>设计</li></ol></li><li>Construction<ol><li>代码</li><li>测试</li></ol></li><li>Deployment</li></ul></li><li>Umbrella Activities 庇护活动（普适性活动）<ul><li>Software project tracking and control</li><li>Risk management</li><li>Software quality assurance</li><li>Technical reviews</li><li>Measurement</li><li>Software configuration management</li><li>Reusability management</li><li>Work product preparation and production</li></ul></li></ul></li></ul></li><li><p>Software Lifecycle</p><ul><li>软件有一个孕育、诞生、成长、成熟、<br>衰亡的生存过程。这个过程即为计算机<br>软件的生命周期(生存周期)</li><li>why need<ul><li>从时间角度对软件开发和维护的复杂问题进行分解，把软件生存的漫长周期依次划分为若干个阶段，每个阶段有相对独立的任务，然后再逐步完成每个阶段的任务。</li><li>为软件人提供一个公共的框架，以便软件人的相互交流。</li></ul></li></ul></li></ul><h2 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h2><ul><li>Evolutionary Models<ul><li>prototype<ul><li>类型<ul><li>探索型(exploratory prototyping) 弄清需求</li><li>实验型(experimental prototyping)  验证方案</li><li>演化型(evolutionary prototyping)</li></ul></li><li>特征<ul><li>可实际运行</li><li>它没有固定的生存期。它可能被扔掉，或者作为最终产品的一部分。</li><li>可为不同目标作原型</li><li>快速、廉价</li><li>是迭代过程的集成部分，即每次经用户评价后修改、运行，不断重复双方认可。</li></ul></li></ul></li></ul></li></ul><h2 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a>Chapter 5</h2><ul><li>敏捷宣言<ul><li>个体和互动 高于 流程和工具</li><li>工作的软件 高于 详尽的文档</li><li>客户合作 高于 合同谈判</li><li>响应变化 高于 遵循计划</li></ul></li><li></li></ul><h2 id="Chapter-7"><a href="#Chapter-7" class="headerlink" title="Chapter 7"></a>Chapter 7</h2><h3 id="Requirements-Engineering"><a href="#Requirements-Engineering" class="headerlink" title="Requirements Engineering"></a>Requirements Engineering</h3><ul><li>Inception</li><li>Elicitation</li><li>Elaboration</li><li>Negotiation</li><li>Specification<ul><li>根据需求调查和需求分析的结果，进一步定义准确无误的产品需求，产生《产品需求规格说明书》</li></ul></li><li>Validation</li><li>Requirements management</li></ul><h3 id="Quality-Function-Deployment"><a href="#Quality-Function-Deployment" class="headerlink" title="Quality Function Deployment"></a>Quality Function Deployment</h3><ol><li>功能部署——确定系统功能的价值</li><li>信息部署——确定数据对象和事件</li><li>任务部署——确定系统的行为</li><li>价值分析——确定需求的优先级</li></ol><h3 id="Non-Functional-Requirements"><a href="#Non-Functional-Requirements" class="headerlink" title="Non-Functional Requirements"></a>Non-Functional Requirements</h3><ul><li>quality attribute</li><li>performance attribute</li><li>security attribute</li><li>general system constraint</li></ul><h3 id="diagrams"><a href="#diagrams" class="headerlink" title="diagrams"></a>diagrams</h3><p>Use-case &#x2F; Class &#x2F; State &#x2F; Activity</p><h2 id="Chapter-11"><a href="#Chapter-11" class="headerlink" title="Chapter 11"></a>Chapter 11</h2><ul><li>Analysis model<ul><li>focus on describing required data, function and behavior</li></ul></li></ul><h3 id="Design-model"><a href="#Design-model" class="headerlink" title="Design model"></a>Design model</h3><ul><li>provide detail about software data structure, architecture, interfaces and components</li><li>4 kinds<ul><li>Data&#x2F;Class design——将分析类转换为实现类和数据结构</li><li>Architectural design——定义主要软件结构元素之间的关系</li><li>Interface design——定义软件元素、硬件元素和最终用户如何通信</li><li>Component-level design——转换结构元素到软件组件的过程描述中</li></ul></li></ul><h3 id="concepts"><a href="#concepts" class="headerlink" title="concepts"></a>concepts</h3><ul><li>Architecture-软件的整体结构<ul><li>体现了系统的模块化,抽象和信息隐藏,接口设计</li><li>举例<ul><li>客户-服务器架构（Client-Server Architecture）</li><li>微服务架构（Microservices Architecture）</li><li>事件驱动架构（Event-Driven Architecture）</li><li>分层架构（Layered Architecture）</li></ul></li></ul></li><li>Pattern<ul><li>The goal of a pattern：easy to reuse.</li><li>types:<ul><li>Architecture Pattern<ul><li>B&#x2F;S, C&#x2F;S</li></ul></li><li>Design Pattern</li><li>Idiom<ul><li>a low-level pattern specific to a programming language</li></ul></li></ul></li></ul></li><li>Functional Independence<ul><li>Cohesion 内聚<ul><li>an indication of the relative functional strength of a module</li><li>功能内聚 分层内聚 通信内聚 顺序内聚 过程内聚 时间内聚 实用内聚（由高到低排列）</li></ul></li><li>Coupling 耦合<ul><li>an indication of the relative interdependence among modules</li><li>非直接耦合 数据耦合 标记耦合 控制耦合 外部耦合 共用耦合 内容耦合 （ 由低到高排列）</li></ul></li><li>goal: 高内聚，低耦合</li></ul></li></ul><h2 id="Chapter12-Behavioral-Modeling"><a href="#Chapter12-Behavioral-Modeling" class="headerlink" title="Chapter12 Behavioral Modeling"></a>Chapter12 Behavioral Modeling</h2><ul><li>what<br> the structure of the system, which comprise the software components, the externally visible properties of those components, and the relationships among them</li><li>The importance of architecture<ul><li>for communication between all parties (stakeholders)</li><li>highlights early design decisions</li><li>constitutes a relatively small, intellectually graspable mode</li></ul></li><li>架构有什么用<ul><li>分析设计在满足其规定要求方面的有效性</li><li>在进行设计更改仍然相对而言的阶段考虑架构替代方案容易</li><li>降低与软件构建相关的风险</li></ul></li></ul><h3 id="Architecture-Style"><a href="#Architecture-Style" class="headerlink" title="Architecture Style"></a>Architecture Style</h3><ul><li>定义内容<ul><li>一组执行系统所需功能的构件</li><li>一组连接器，可以实现“通信、协调和组件之间的合作”</li><li>定义组件如何集成以形成系统的约束</li><li>语义模型，使设计人员能够通过分析系统组成部分的已知特性来理解系统的整体属性</li></ul></li><li>种类<ul><li>数据流架构——批处理、管道和过滤器</li><li>调用和返回架构——主程序&#x2F;子程序、面向对象系统、分层系统</li><li>独立组件架构——事件系统、触发器、监视器</li><li>虚拟机架构——解释器，基于规则的系统</li><li>仓库架构——数据库系统，黑板系统等</li></ul></li></ul><h2 id="Chapter13-Component-Level-Design"><a href="#Chapter13-Component-Level-Design" class="headerlink" title="Chapter13 Component Level Design"></a>Chapter13 Component Level Design</h2><ul><li>一个模块化的、可部署的、可替换的系统部分，它封装了实现并公开了一组接口。</li></ul><h3 id="Basic-Design-Principles"><a href="#Basic-Design-Principles" class="headerlink" title="Basic Design Principles"></a>Basic Design Principles</h3><ol><li>开闭原则（OCP）——一个模块 [组件] 应该对扩展开放但对修改关闭</li><li>里氏替换原则（LSP）—— “子类应该可以替代它们的基类。</li><li>依赖倒置原则（DIP）——依赖于抽象。不要依赖实体<ul><li>高层模块应该依赖于抽象（接口或抽象类）</li><li>抽象不应该依赖于具体实现，具体实现应该依赖于抽象</li></ul></li><li>接口分离原则 (ISP)——许多专用的接口都比一个通用接口好</li><li>发布重用等效原则 (REP)——重用的粒度就是发布的粒度</li><li>共同闭合原则（CCP）——同时修改的类应该放在一起</li><li>共同重用原则（CRP）——不能同时复用的类不应该放在一起</li></ol><h2 id="Chapter14-User-Interface-Design"><a href="#Chapter14-User-Interface-Design" class="headerlink" title="Chapter14 User Interface Design"></a>Chapter14 User Interface Design</h2><ul><li>黄金规则<ul><li>用户控制操作</li><li>减少用户记忆负担</li><li>保持界面一致</li></ul></li></ul><h2 id="Chapter-15-16-Software-Quality"><a href="#Chapter-15-16-Software-Quality" class="headerlink" title="Chapter 15-16 Software Quality"></a>Chapter 15-16 Software Quality</h2><ul><li><p>什么是软件质量<br>一个有效的软件过程，其应用方式创造了一个有用的产品，为生产它的人和使用它的人提供可衡量的价值</p></li><li><p>McCall’s Triangle of Quality</p><ul><li>产品修改</li><li>产品转移</li><li>产品运行</li></ul></li><li><p>The Cost of Quality</p><ul><li>在测试和维护阶段改正错误和缺陷的成本急剧增高</li><li>种类：<ol><li>预防成本（COP）</li><li>评估成本（COA）</li><li>内部失败成本</li><li>外部失败成本</li></ol></li></ul></li></ul><h2 id="Chapter-17-19-Testing-Strategy-amp-Techniques"><a href="#Chapter-17-19-Testing-Strategy-amp-Techniques" class="headerlink" title="Chapter 17-19. Testing Strategy &amp; Techniques"></a>Chapter 17-19. Testing Strategy &amp; Techniques</h2><ul><li>Verification vs. Validation<ul><li>Verification: 确保软件能实现特定功能 building the product right</li><li>Validation: 确保软件可追溯到客户需求 building the right product</li></ul></li><li>测试策略——从小到大<ul><li>单元测试</li><li>集成测试</li><li>系统测试</li><li>验收测试<ul><li>α testing 由最终用户在开发人员站点进行</li><li>ß testing 在最终用户站点进行</li></ul></li></ul></li></ul><h3 id="测试策略之unit-testing"><a href="#测试策略之unit-testing" class="headerlink" title="测试策略之unit testing"></a>测试策略之unit testing</h3><ul><li>内容：<ul><li>接口</li><li>局部数据结构</li><li>边界条件</li><li>独立路径</li><li>错误处理路径</li></ul></li><li>stub——代替底层</li><li>driver——代替顶层<ul><li>提供了一个框架用于设置输入参数，环境 ，执行单元</li></ul></li></ul><h3 id="测试策略之integration-testing"><a href="#测试策略之integration-testing" class="headerlink" title="测试策略之integration testing"></a>测试策略之integration testing</h3><ul><li>Top Down Integration<ul><li>Advantage<ul><li>A skeletal version of the program can exist early and allows demonstrations</li><li>Design errors may be found sooner.</li><li>Reduces the need for test drivers</li><li>It tends to make fault location easier</li></ul></li><li>Disadvantage<ul><li>stubs could be expensive to build.</li></ul></li></ul></li><li>Bottom-Up Integration<ul><li>Advantage<ul><li>Particular useful for objects and reuse.</li><li>requiring no structural design information</li></ul></li><li>Disadvantage<ul><li>The program as a whole does not exist until the last module is added.</li><li>requires test drivers, not test stubs.</li></ul></li></ul></li></ul><h3 id="测试策略之system-testing——充分运用基于计算机的系统"><a href="#测试策略之system-testing——充分运用基于计算机的系统" class="headerlink" title="测试策略之system testing——充分运用基于计算机的系统"></a>测试策略之system testing——充分运用基于计算机的系统</h3><ul><li>目的：<ul><li>在将要运行的真实环境中测试整个系统</li><li>确保系统满足整体工作的要求</li><li>还要测试系统功能之外的方面</li><li>结果有时用于系统验收</li><li>验证软件用户手册</li><li>估计可靠性和可维护性</li></ul></li></ul><h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><ul><li>黑盒测试（功能）</li><li>白盒测试（结构）</li></ul><h2 id="Chapter-21-Software-configuration-management"><a href="#Chapter-21-Software-configuration-management" class="headerlink" title="Chapter 21 Software configuration management"></a>Chapter 21 Software configuration management</h2><h3 id="The-SCM-Process"><a href="#The-SCM-Process" class="headerlink" title="The SCM Process"></a>The SCM Process</h3><ol><li>identification</li><li>change control</li><li>version control</li><li>configuration auditing</li><li>reporting</li></ol><ul><li>Software configuration item</li></ul><h2 id="Chapter-22-Project-Management-Concept"><a href="#Chapter-22-Project-Management-Concept" class="headerlink" title="Chapter 22  Project Management Concept"></a>Chapter 22  Project Management Concept</h2><h3 id="4-p"><a href="#4-p" class="headerlink" title="4 p"></a>4 p</h3><ul><li>people</li><li>product<ul><li>scopes<ol><li>context</li><li>information objectives</li><li>function and performance</li></ol></li></ul></li><li>Process<ul><li>Consider project characteristics</li><li>Determine the degree of rigor required</li><li>Define a task set for each software engineering activity</li></ul></li><li>Project<ol><li>从正确的基础上开始工作——首先通过努力理解要解决的问题，然后设定现实的目标和期望来实现的</li><li>保持动力——项目经理必须提供激励措施，将人员流动率控制在最低限度，团队应在其执行的每项任务中强调质量，高级管理人员应尽一切可能远离团队</li><li>跟踪进度——作为质量保证活动的一部分，随着工作产品（例如模型、源代码、测试用例集）的生成和批准（使用正式的技术评审），进度会被跟踪。</li><li>做出明智的决定——项目经理和软件团队的决定应该是“保持简单”</li><li>进行事后分析——建立一个一致的机制来提取每个项目的经验教训</li></ol></li></ul><h3 id="W5HH"><a href="#W5HH" class="headerlink" title="W5HH"></a>W5HH</h3><ol><li>Why is the system being developed?——为什么</li><li>What will be done? ——做什么</li><li>When will it be accomplished?——什么时候做</li><li>Who is responsible?——谁负责</li><li>Where are they organizationally located?——其他人的组织机构位于何处</li><li>How will the job be done technically and managerially?——如何完成技术工作和管理工作</li><li>How much of each resource (e.g., people, software, tools, database) will be needed?——每种资源需要多少</li></ol><h3 id="Task-set-x3D"><a href="#Task-set-x3D" class="headerlink" title="Task set &#x3D;"></a>Task set &#x3D;</h3><ul><li>Software engineering tasks</li><li>Work products</li><li>Quality assurance points </li><li>Milestones</li></ul><h3 id="software-engineering-activity"><a href="#software-engineering-activity" class="headerlink" title="software engineering activity"></a>software engineering activity</h3><ul><li>需求分析</li><li>设计</li><li>软件开发</li><li>软件部署</li><li>软件维护</li><li>项目管理</li><li>质量保证</li><li>配置管理</li><li>文档编写</li></ul><h2 id="Chapter-23-Process-and-Project-Metrics"><a href="#Chapter-23-Process-and-Project-Metrics" class="headerlink" title="Chapter 23 Process and Project Metrics"></a>Chapter 23 Process and Project Metrics</h2><ul><li>意义<ol><li>评估正在进行的项目的状态</li><li>跟踪潜在风险</li><li>在问题造成不良影响前发现风险</li><li>调整工作流程或任务</li><li>评估项目团队控制软件工作产品质量的能力</li></ol></li></ul><h3 id="Process-Measurement"><a href="#Process-Measurement" class="headerlink" title="Process Measurement"></a>Process Measurement</h3><ul><li>根据过程中获得的一系列数据或软件工程任务的特性来进行测量。</li><li>Software Process Improvement (SPI)</li><li>5 Metrics<ul><li>Quality-related</li><li>Productivity-related</li><li>Statistical SQA data</li><li>Defecti removal effciency</li><li>Reuse data</li></ul></li></ul><h3 id="项目度量"><a href="#项目度量" class="headerlink" title="项目度量"></a>项目度量</h3><ul><li>三个方面<ul><li>如期</li><li>质量</li><li>成本</li></ul></li></ul><h3 id="Chapter-24-25-Project-Estimation-amp-Scheduling"><a href="#Chapter-24-25-Project-Estimation-amp-Scheduling" class="headerlink" title="Chapter 24-25 Project Estimation &amp; Scheduling"></a>Chapter 24-25 Project Estimation &amp; Scheduling</h3><h3 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h3><ul><li>Scope refers to all the work involved in creating the<br>products of the project and the processes used to<br>create them. It defines what is or is not to be done</li><li>项目范围的内容<ul><li>交付给最终用户的功能和特性</li><li>输入和输出的数据</li><li>由于使用软件而呈现给用户的“内容”</li><li>性能、约束、接口、和约束系统的可靠性</li></ul></li></ul><h3 id="Work-Breakdown-Structure-WBS"><a href="#Work-Breakdown-Structure-WBS" class="headerlink" title="Work Breakdown Structure (WBS)"></a>Work Breakdown Structure (WBS)</h3><ul><li>进行WBS的五种方法<ol><li>使用指南：一些组织提供的指南</li><li>类比方法：审查类似项目的 WBS，并根据我们的项目 进行定制。</li><li>自上而下的方法：从项目中最大的项目开始，并将它们分解</li><li>自下而上的方法：从详细的任务开始，并将它们汇总</li><li>思维导图方法：以非线性格式写下任务，然后创建 WBS 结构</li></ol></li></ul><h3 id="估计方法"><a href="#估计方法" class="headerlink" title="估计方法"></a>估计方法</h3><ul><li>基于代码行的估计<ul><li>优点：易于测量、容易自动化</li><li>缺点：仅限于代码不能用于设计、依赖于语言、没有考虑功能的复杂性、与设计的好坏挂钩</li></ul></li><li>基于功能点的估计<ul><li>优点：<ol><li>可用于最早的需求阶段</li><li>独立于编程语言、产品设计或开发风格 </li><li>用户视图，而不是实现视图 </li><li>可用于衡量非编码活动 </li><li>存在大量历史数据  </li><li>有据可查</li></ol></li><li>缺点：<ol><li>无法直接计算现有产品（源代码）的 FP 内容 </li><li>难以自动化 </li><li>FP 不反映语言、设计或风格差异 </li><li>FP 设计用于估计商业数据处理应用 </li><li>主观计数</li></ol></li></ul></li></ul><h3 id="项目调度"><a href="#项目调度" class="headerlink" title="项目调度"></a>项目调度</h3><ol><li>项目为什么会延期<br>  不切实际的截止日期<br>  需求的变化<br>  低估工作量<br>  不可预测的风险<br>  技术难题<br>  人为困难<br>  沟通不畅<br>  未能认识到项目落后于计划或缺乏纠正问题的行动</li><li>调度的原则<br> 划分——定义多个不同的任务<br> 相互依赖性——明确任务的相互关系<br> 工作量确认——确保人力资源可用<br> 确定责任——明确责任承担者<br> 明确输出结果——确定活动产生的结果<br> 确定里程碑——进行质量审查</li><li>调度的步骤<ol><li>定义任务集——WBS</li><li>安排活动</li><li>绘制项目网络图</li><li>关键路径分析</li><li>使用甘特图进行调度</li><li>进度跟踪</li></ol></li></ol><h2 id="Chapter-26-Risk-Management"><a href="#Chapter-26-Risk-Management" class="headerlink" title="Chapter 26 Risk Management"></a>Chapter 26 Risk Management</h2><ul><li><p>Reactive Risk Management</p></li><li><p>Proactive Risk Management</p><ul><li>formal risk analysis is performed</li><li>corrects the root causes of risk</li></ul></li><li><p>Risk Management Paradigm</p><ol><li>Risk identification</li><li>Risk analysis</li><li>Risk planning </li><li>Risk monitoring</li></ol></li><li><p>RMMM</p><ul><li>Mitigation</li><li>Monitoring </li><li>Management</li></ul></li></ul><h2 id="常用图"><a href="#常用图" class="headerlink" title="常用图"></a>常用图</h2><ul><li>用例图</li><li>类图</li><li>活动图<ul><li>变形：泳道图</li></ul></li><li>顺序图</li></ul>]]></content>
    
    
    <summary type="html">没有银弹</summary>
    
    
    
    <category term="学习" scheme="http://euds63.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="笔记" scheme="http://euds63.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="软件工程" scheme="http://euds63.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>诗词</title>
    <link href="http://euds63.github.io/2023/poem/"/>
    <id>http://euds63.github.io/2023/poem/</id>
    <published>2023-06-06T14:53:45.000Z</published>
    <updated>2023-10-07T05:32:04.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="诗词"><a href="#诗词" class="headerlink" title="诗词"></a>诗词</h1><p><strong>暂时定于用来记录些诗词</strong></p><h2 id="鹧鸪天（正月十一日观灯）-姜夔"><a href="#鹧鸪天（正月十一日观灯）-姜夔" class="headerlink" title="鹧鸪天（正月十一日观灯）     姜夔"></a>鹧鸪天（正月十一日观灯）     姜夔</h2><p>巷陌风光纵赏时。笼纱未出马先嘶。白头居士无呵殿，只有乘肩小女随。</p><p>花满市，月侵衣。少年情事老来悲。沙河塘上春寒浅，看了游人缓缓归。</p><p><strong>看过一篇点评。说这阙词可能是唯一一阙描写了女儿坐在爸爸肩头的。那篇文章中还写，说姜夔半生潦倒，不知他的小女命运几何。我感觉不管以后如何，当坐在爸爸肩头赏灯的时候肯定是很幸福的。</strong></p><hr><h2 id="咏史-李梦唐"><a href="#咏史-李梦唐" class="headerlink" title="咏史 李梦唐"></a>咏史 李梦唐</h2><p>高阁垂裳调鼎时，可怜天下有微词。<br>覆舟水是苍生泪，不到横流君不知。</p><hr><h2 id="拟行路难-其四-鲍照"><a href="#拟行路难-其四-鲍照" class="headerlink" title="拟行路难-其四 鲍照"></a>拟行路难-其四 鲍照</h2><p>泻水置平地，各自东西南北流。<br>人生亦有命，安能兴叹复坐愁！<br>酌酒以自宽，举杯断绝歌路难。<br>心非木石岂无感，吞声踯躅不敢言。</p><p><strong>很喜欢最后这一句。今天（2023年6月6日）才知道鲍照久居建康，也就是南京，然后才发信现江苏和山东竟然是邻居。</strong></p><hr><h2 id="塞下曲-其二-王昌龄"><a href="#塞下曲-其二-王昌龄" class="headerlink" title="塞下曲-其二 王昌龄"></a>塞下曲-其二 王昌龄</h2><p>饮马渡秋水，水寒风似刀。<br>平沙日未没，黯黯见临洮。<br>昔日长城战，咸言意气高。<br>黄尘足今古，白骨乱蓬蒿。</p><p><strong>四月份记的一首诗，已经忘了为什么记了。</strong></p><hr><h2 id="拟挽歌辞-陶渊明"><a href="#拟挽歌辞-陶渊明" class="headerlink" title="拟挽歌辞 陶渊明"></a>拟挽歌辞 陶渊明</h2><p>有生必有死，早终非命促。<br>昨暮同为人，今旦在鬼录。<br>魂气散何之，枯形寄古木。<br>娇儿索父啼，良友抚我哭，<br>得失不复知，是非安能觉！<br>千秋万岁后，谁知荣与辱？<br>但恨在世时，饮酒不得足。</p><p>在昔无酒饮，今但湛空觞。<br>春醪生浮蚁，何时更能尝！<br>肴案盈我前，亲旧哭我旁。<br>欲语口无音，欲视眼无光。<br>昔在高唐寝，今宿荒草乡；<br>一朝出门去，归来夜未央。</p><p>荒草何茫茫，白杨亦萧萧。<br>严霜九月中，送我出远郊。<br>四面无人居，高坟自嶣峣。<br>马为仰天鸣，风为自萧条。<br>幽室一已闭，千年不复朝。<br>千年不复朝，贤达无奈何。<br>向来相送人，各自还其家。<br>亲戚或余悲，他人亦已歌。<br>死去何所道，托体同山阿。</p><p><strong>之前读不懂，今年读懂了。</strong></p><p><strong>“得失不复知，是非安能觉”这句，让我想到“死去元知万事空”。他们都不信什么在天之灵，都认为死了就是死了。我也认同这种想法，但更希望能有在天之灵。</strong></p><p><strong>“春醪生浮蚁，何时更能尝”这句看了注释才知道自己完全读反了。说的是祭酒的时候，我理解为生的时候。</strong></p><p><strong>“亲戚或余悲，他人亦已歌”。听着很残酷，但我现在觉得：死后能让他人偶尔想起，已经是很了不起的事了</strong></p><hr><h2 id="定风波-南海归赠王定国侍人寓娘-苏轼"><a href="#定风波-南海归赠王定国侍人寓娘-苏轼" class="headerlink" title="定风波-南海归赠王定国侍人寓娘 苏轼"></a>定风波-南海归赠王定国侍人寓娘 苏轼</h2><p>王定国哥儿曰柔奴，姓宇文氏，眉目娟丽，善应对，家世住京师。定国南迁归，余问柔：“广南应是不好？”柔对曰：“此心安处，便是吾乡。”因为缀词云。</p><p>常羡人间琢玉郎，天教分付酥娘。尽道清歌传皓齿，风起，雪飞炎海变清凉。<br>万里归来颜愈少。微笑，笑时犹带岭梅香。试问岭南应不好，却道：此心安处是吾乡。</p><p><strong>苏轼的两阙定风波我都很喜欢。</strong></p><h2 id="定风波-苏轼"><a href="#定风波-苏轼" class="headerlink" title="定风波 苏轼"></a>定风波 苏轼</h2><p>三月七日，沙湖道中遇雨，雨具先去，同行皆狼狈，余独不觉。已而放晴，故作此。</p><p>莫听穿林打叶声，何妨吟啸且徐行。竹杖芒鞋轻胜马，谁怕，一蓑烟雨任平生。<br>料峭春风吹酒醒，微冷，山头斜照却相迎。回首向来萧瑟处，归去，也无风雨也无晴。</p><p><strong>蓑这个意像是诗词里的常客了。</strong></p><p><strong>对这阙词一直有个印象，就是苏轼淋雨生病了，去看病又写了阙《游沙湖》。但是查了下才发现自己的记忆是错的。苏轼去看的是手肿，明显不是因为淋雨</strong></p><hr><h2 id="朝中措·送刘仲原甫出守维扬-欧阳修"><a href="#朝中措·送刘仲原甫出守维扬-欧阳修" class="headerlink" title="朝中措·送刘仲原甫出守维扬 欧阳修"></a>朝中措·送刘仲原甫出守维扬 欧阳修</h2><p>平山栏槛倚晴空。山色有无中。手种堂前垂柳，别来几度春风。<br>文章太守，挥毫万字，一饮千钟。行乐直须年少，尊前看取衰翁。</p><p><strong>之前去扬州找攻略的时候翻到的。</strong></p><hr><h2 id="汴河怀古-皮日休"><a href="#汴河怀古-皮日休" class="headerlink" title="汴河怀古 皮日休"></a>汴河怀古 皮日休</h2><p>尽道隋亡为此河，至今千里赖通波。<br>若无水殿龙舟事，共禹论功不较多。</p><p><strong>在大运河博物馆看到的。现在想到皮日休在开元寺待过一段时间。影壁上好像还有他的名。</strong></p><hr><h2 id="题龙阳县青草湖-唐珙"><a href="#题龙阳县青草湖-唐珙" class="headerlink" title="题龙阳县青草湖 唐珙"></a>题龙阳县青草湖 唐珙</h2><p>西风吹老洞庭波，一夜湘君白发多，<br>醉后不知天在水，满船清梦压星河。</p><p><strong>老字用得很妙，之前没悟出来</strong></p><hr><h2 id="答武陵太守-王昌龄"><a href="#答武陵太守-王昌龄" class="headerlink" title="答武陵太守 王昌龄"></a>答武陵太守 王昌龄</h2><p>仗剑行千里，微躯感一言。<br>曾为大梁客，不负信陵恩。</p><p><strong>我比较喜欢前面两句，但却不太能做得到，反而是“微躯不敢言”。</strong></p>]]></content>
    
    
    <summary type="html">暂时定于用来记录些诗词</summary>
    
    
    
    <category term="想法" scheme="http://euds63.github.io/categories/%E6%83%B3%E6%B3%95/"/>
    
    
    <category term="记录" scheme="http://euds63.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="感想" scheme="http://euds63.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Tears of the Kingdom</title>
    <link href="http://euds63.github.io/2023/Tears-of-the-Kingdom/"/>
    <id>http://euds63.github.io/2023/Tears-of-the-Kingdom/</id>
    <published>2023-06-05T13:30:39.000Z</published>
    <updated>2023-10-07T05:32:04.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="王国之泪"><a href="#王国之泪" class="headerlink" title="王国之泪"></a>王国之泪</h1><p><em>第一个让我想写点什么，并且真的写了点什么的游戏</em></p><h2 id="游戏历程"><a href="#游戏历程" class="headerlink" title="游戏历程"></a>游戏历程</h2><p>5月3日开始玩偷跑的模拟器版本。（这里先自我检讨，不仅是玩的盗版，而且还是偷跑版本。以后经济独立后尽量补票。）中间间断了几天，昨天打完加侬多夫，算是通关了。打完蛮惆怅的，各种看视频网站、刷贴吧想看看别人的感受，没找着。洗澡的时候有些想法，就想着自己写一写。</p><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>23年过年前我下了一堆游戏，但过完年到了二月份就开始对游戏提不起兴趣，一直到5月初接触了《王国之泪》才一发不可收拾，玩游戏玩得熬了好几次夜。</p><p>这游戏为什么有那么大的魔力。我想了几点：</p><ul><li><p>剧情。说实话剧情在我玩不到5天的时候就大概能知道是个什么样的剧情了。但还是觉得是恶搞不错的剧情。很喜欢这作里林克和塞尔达的关系。塞尔达对林克的这种信任，跨越时间、牺牲自己的信任，我着实有被感动到。</p></li><li><p>人物。</p><ul><li>塞尔达。这作的塞尔达真的很美。她在哈特诺学校里当了一段时间的老师，家里还挂着学生给她画的画。她周游海拉鲁大陆，各地的人民那都能听到他的评价。</li><li>加侬多夫。没啥感觉，甚至有点想笑。最终的boss战难度即使手残如我也能一把过，但一万年前却那样的所向披靡。加上boss的一些宣言逼格也感觉不高。不过倒不影响就是了。打完后才知道中途要是死了就得冲怪物大军那边开始，想想就感到庆幸。</li><li>卡卡利特村的村民。最恶心的一个村子。说实话，我玩这作的时候带着“我前几年拯救了世界，你们不要说要怎么崇拜我，至少得尊重我吧”的想法。但在这个村子却觉得地位比普通村民还低。一个村民直接躺石板上睡觉不让我直接叫醒，还得我去找生命松露来；而我只是要去摸一下石板都会被喝止。更不用说有一个地点我尝试了多种方式也不让进。虽然后面才知道这是剧情的要求，但还是觉得很不爽。</li><li>沃特里村的村民。这反倒和卡卡利特村形成了鲜明了对比，在这里感受到了尊重。任务做起来也有意思。</li></ul></li><li><p>和前作的关系：<br>这作的时间线应该是在旷野之息之后的几年。可以说是续作。但前作的希卡科技几乎消失殆尽。这点也被许多老玩家所吐槽。我虽然也有玩过旷野之息，但只通了风、水两个神殿，加上玩的时候过度使用金手指，导致游戏体验并不好。所以对前作没什么感情。因此反倒是影响不大。</p><p>另外，这作还成功勾起了我对塞尔达传说全作的兴趣。在了解了一些相关信息后（云了几个视频），现在更能感受到本作里埋的一些彩蛋。羡慕那些早早入坑的玩家，他们得有多幸福啊。</p></li><li><p>配乐。印象最深的风神殿那段，太棒了。虽然进神殿前的跳跳乐我跳了快一个下午，但这并不影响其给我带来的震撼。</p></li></ul><p>上面说了这么多，还没有说到点子上。我觉得最吸引我的是这几点：</p><ul><li>开发人员的周到：玩的时候能感受到开发人员是真的有很细致地玩过，这点做起来似乎也不难：趁手的工具，丰富的文本，能让我有一种感觉：开发人员把我能想到的都想到了。但实际上我玩过的游戏中，似乎只有赛尔达传说真正做到了这点。</li><li>合乎直觉。这点似乎和上一点是相同的。但我还是把它单独列出来了。因为这点太棒了。我一直觉得一个好的设计的最高标准就是合乎直觉，你拿到一个产品，你不需要看说明书，不需要问别人，你拿到手就能用，我觉得这就是一个很棒的体验。而要做得合乎直觉，特别是游戏这种，就需要开发人员想得够多。</li><li>探索欲。看过一篇讲旷野之息的文章，说任天堂通过塔、神庙、宝箱等将一个大的地图切分成了一个个的三角。我觉得说得很在理。而王国之泪更是加强了这一点，因为有了鸟望塔的存在。射向高空后，看到特殊的地形、神庙、龙之泪，就有忍不住想一一探索的冲动。这也是导致一玩就难以停止，永远想着这个结束就暂停，永远都会冒出来新的可探索点。</li><li>能力。这作的能力十分出彩。通天术增强了机动性。余料建造对武器系统的丰富。究极手更是被玩出花来。我玩游戏一向很菜，不仅手残而且创意也一般，但看网上各种脑洞大开的拼法也是我这一个月以来的一大乐趣。</li><li>手残友好。难度设计不高，且有较合适的引导，而且不乏逃课手段，这让我能更好地去体验游戏的乐趣。</li><li>技术。我一直记得自己在知道超级玛丽的程序员为了去适配游戏机的性能所做的各种奇淫巧技时的震撼，太magic了。而王国之泪的技术力也很强，16g左右的大小在今天已经不能算大，但这作的丰富程度却是很多其他游戏所不能比拟的。而且bug也不多，除了一些复制bug，我好像没有看到有说什么影响游戏体验的恶性bug。</li></ul><p>再说下模拟器。模拟器从偷跑刚出时候的明显卡顿、不断闪退、贴图错误，到现在的流畅体验，离不开模拟器开发和维护者的不断努力。而刚出的那几天，相关社区里的氛围也十分好。很多都是分享自己增强游戏体验的设置。说句可能不是很恰当的话，我在这点上感受到了互联网精神 —— 互帮互助、不求回报、持续钻研。我是这样理解的。这也可以说是王国之泪吸引我的一点。</p><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>今天看到一句话“突然明白了什么才是好游戏，就连看它的玩家们怎么玩都是一件很有趣的事”。说得真好。</p>]]></content>
    
    
    <summary type="html">第一个让我想写点什么，并且真的写了点什么的游戏</summary>
    
    
    
    <category term="想法" scheme="http://euds63.github.io/categories/%E6%83%B3%E6%B3%95/"/>
    
    
    <category term="游戏" scheme="http://euds63.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="感受" scheme="http://euds63.github.io/tags/%E6%84%9F%E5%8F%97/"/>
    
  </entry>
  
  <entry>
    <title>为什么要写博客</title>
    <link href="http://euds63.github.io/2023/reasons-for-build-a-blog/"/>
    <id>http://euds63.github.io/2023/reasons-for-build-a-blog/</id>
    <published>2023-05-19T16:38:56.000Z</published>
    <updated>2023-10-07T05:32:04.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要写博客"><a href="#为什么要写博客" class="headerlink" title="为什么要写博客"></a>为什么要写博客</h1><p>这个问题已经被很多人回答过了。但我还是愿意给出些自己的回答（或者认同的回答）。</p><ul><li><a href="https://plantegg.github.io/2117/06/07/%E5%85%B3%E4%BA%8E%E6%9C%AC%E5%8D%9A/">关于本博</a>里的答案是这样的。<br>为了解决一看就懂，一问就打鼓，一用就糊涂。所以需要记录、总结，再联系案例。把零散知识记录下来（看到过），慢慢地相关知识积累更多，直到碰到实践案例或是有点领悟到于是发现这块知识可以整理成一篇系统些的文章。</li></ul><h2 id="2023年5月5日"><a href="#2023年5月5日" class="headerlink" title="2023年5月5日"></a>2023年5月5日</h2><p>我享受逛博客的过程。不管是博客的页面设计还是文章的内容，基本上都是作者的一番心血。巨大的互联网使用人数和几十年的时间，诞生了许多很有意思的博客，可谓浩如烟海。而我想在这这烟海中有一颗属于自己的星。</p><h2 id="2023年5月19日"><a href="#2023年5月19日" class="headerlink" title="2023年5月19日"></a>2023年5月19日</h2><p>今天一天都跟博客有关。</p><p>白天是拼了几篇博客来做作业。</p><p>晚上的时候看<a href="https://soulogic.com/item/3294">我的郑老三死了</a>。我记忆中自己没养过动物，但前不久才经历过亲人的突然离去，所以这篇让我很有些想法。</p><p>更晚些的时候看<a href="https://rehoni.github.io/cn/">罗皓的个人博客</a>，是一个学长的。从大学一直记录到工作。看着那些熟悉的地名和事情很有感觉。</p><p>现在突然冒出来了个想法。博客的意义可能在于存在。它不需要马上就能让某个人有想法。它只需要存在，存在着能访问就好。</p>]]></content>
    
    
    <summary type="html">这个问题已经被很多人回答过了。但我还是愿意给出些自己的回答（或者认同的回答）。</summary>
    
    
    
    <category term="想法" scheme="http://euds63.github.io/categories/%E6%83%B3%E6%B3%95/"/>
    
    
    <category term="博客" scheme="http://euds63.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="感想" scheme="http://euds63.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
    <category term="折腾" scheme="http://euds63.github.io/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>死亡</title>
    <link href="http://euds63.github.io/2023/death/"/>
    <id>http://euds63.github.io/2023/death/</id>
    <published>2023-05-19T16:35:36.000Z</published>
    <updated>2023-10-07T05:32:04.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="隋炀帝墓"><a href="#隋炀帝墓" class="headerlink" title="隋炀帝墓"></a>隋炀帝墓</h2><p>查扬州旅游景点时看到有隋炀帝墓考古遗址公园。词条中有句话。</p><blockquote><p>后来的考证，1980年代进，当地居民在隋炀帝墓附近建房，曾在主墓室中心上方挖过一个粪坑，底部距离墓室仅半米。<br>堂堂帝王，千年后安眠之地却差点要成了粪坑。令人唏嘘。</p></blockquote><h2 id="寻梦环游记"><a href="#寻梦环游记" class="headerlink" title="寻梦环游记"></a>寻梦环游记</h2><p>这部电影无论是中文名还是英文名都觉得取得一般。中文太烂大街了，英文不知道的还以为是讲奶茶的。</p><p>但无法掩盖这不部电影绝对是部好电影。关于死亡的电影我觉得目前没有比它更好的。</p><p>我喜欢电影中墨西哥人的亡灵节。喜欢这种理念——一个人真正的死是世界上再也没有人记得他。</p><h2 id="2023年5月19日"><a href="#2023年5月19日" class="headerlink" title="2023年5月19日"></a>2023年5月19日</h2><p>今天看<a href="https://soulogic.com/item/3294">我的郑老三死了</a>，很有感触。</p><p>摘抄几段文字</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">之后的这两天里，我每天要嘱咐自己不下二十次，郑老三已经永远的消失了，没有任何挽救的方法。不要去幻想还有另一个世界存在，因为天堂是不自洽的。接受这个事实，有出生就有死亡。我们都会死，郑老三会死，我和我老婆将来要有一个人去承受对方先死的痛苦，将来我们的孩子也会死。在这之前我以为自己已经反复思考过终有一死，没有例外，反复读过《耶鲁大学公开课：死亡》，可真碰到的时候才发现自己就像读过如何游泳的书一样。<br><span class="hljs-meta prompt_">...</span><br>这时候我才明白“文化”的意义，我之前一直有类似“工业党”的心态，觉得逻辑思维才代表着人类的进步（网站名 Soulogic 表明了这种倾向），但其实人类大部分时间都在面对着无力改变的事情，需要有人从事艺术创作来抒发喜怒哀乐。理科是改良，文科是本。或者放大到极端来说，如果将来的人类（或者取代了人类的 AI）征服了整个宇宙，却已经没人会吟唱一首深情地求爱或者悼念逝者的歌曲，那这个物种不值得存在，只是些分布广泛、化学性质活泼的泡沫而已。<br><br>同时曲解死亡的定义、相信灵魂不灭是一个非常大的诱惑，我必须费很大的力气去克制。很明显不能要求所有人都能正确地理解死亡，就像不能要求所有人中考物理满分一样，那太刻薄了。其实“正确”一词出现在上句话里本身就充满了傲慢。<br><br>我也因此明白宗教存在的意义，可以抛弃一些细枝末节，诸如没必要相信天使、对圣餐的解释，但是，所有人在任何时候都是坚定的无神论者，这感觉并不妙。别误会，我没有屈服，但是相比世间所有的心理打击，我碰到的这次简直什么都不算。所以完全摈弃宗教是不可思议的。<br></code></pre></td></tr></table></figure><p>今天看贴吧的时候还看到这个。</p><p>楼中楼中有人说“我叔检查出晚期，要放弃了，但是堂弟的老婆有了身孕，叔想看孙子，靠着止痛药硬抗。最后堂弟竭尽全力花费这么多年的积蓄吊着他一口气，坚持了六个月。医生说一般人能坚持一个月就到头了，我叔坚持六个月真是奇迹。”</p><p>路人a回“孙子出生了，家里钱全花光了，说不定还欠点，孩子怎么养？现在小孩开销大的离谱”</p><p>路人b怼他“那换是你你愿意让你爹带着遗憾走，然后自己愧疚一辈子？”</p><p>路人a回路人b“他不想死我就尽力治，不过如果是我老了我不会让我儿子治我”</p><p>层主回复：差了两个月。本来发现的时候已经放弃了，我堂弟的工资尚可，家里有点地种果的，年收入20这样。叔叔想给儿子孙子留点，但是堂弟觉得钱还能再赚，可是人没了就是遗憾了，所以竭尽全力想让他看一眼孙子。上面的人大概都是孤儿吧，不懂什么叫孝心。</p><p>（差了两个月这五个字我越看越难受，甚至有点泪。太残酷了，太残酷了）</p><p>看了很难受，我发现很多人其实都是类似的想法：老了得了绝症就不治了，钱先不说，主要治不好，治疗过程大多又很痛苦，不如趁最后的时间想干啥干啥，潇洒潇洒。</p><p>但很可能也只是说得容易，真到了那时候有很东西阻挡着，让你身不由己。</p><h2 id="2023年6月6日"><a href="#2023年6月6日" class="headerlink" title="2023年6月6日"></a>2023年6月6日</h2><p>今天细度了陶渊明的拟挽歌辞</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs">有生必有死，早终非命促。<br>昨暮同为人，今旦在鬼录。<br>魂气散何之，枯形寄古木。<br>娇儿索父啼，良友抚我哭，<br>得失不复知，是非安能觉！<br>千秋万岁后，谁知荣与辱？<br>但恨在世时，饮酒不得足。<br><br>在昔无酒饮，今但湛空觞。<br>春醪生浮蚁，何时更能尝！<br>肴案盈我前，亲旧哭我旁。<br>欲语口无音，欲视眼无光。<br>昔在高唐寝，今宿荒草乡；<br>一朝出门去，归来夜未央。<br><br>荒草何茫茫，白杨亦萧萧。<br>严霜九月中，送我出远郊。<br>四面无人居，高坟自嶣峣。<br>马为仰天鸣，风为自萧条。<br>幽室一已闭，千年不复朝。<br>千年不复朝，贤达无奈何。<br>向来相送人，各自还其家。<br>亲戚或余悲，他人亦已歌。<br>死去何所道，托体同山阿。<br></code></pre></td></tr></table></figure><p>之前读不懂，今年读懂了。</p><p>“得失不复知，是非安能觉”这句，让我想到“死去元知万事空”。他们都不信什么在天之灵，都认为死了就是死了。我也认同这种想法，但更希望能有在天之灵。</p><p>“亲戚或余悲，他人亦已歌”。听着很残酷，但我现在觉得：死后能让他人偶尔想起，已经是很了不起的事了。</p>]]></content>
    
    
    <summary type="html">死去何所道，托体同山阿。</summary>
    
    
    
    <category term="想法" scheme="http://euds63.github.io/categories/%E6%83%B3%E6%B3%95/"/>
    
    
    <category term="博客" scheme="http://euds63.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="感想" scheme="http://euds63.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
    <category term="死亡" scheme="http://euds63.github.io/tags/%E6%AD%BB%E4%BA%A1/"/>
    
  </entry>
  
  <entry>
    <title>《悉达多》摘录</title>
    <link href="http://euds63.github.io/2023/excerpt-of-Siddhartha/"/>
    <id>http://euds63.github.io/2023/excerpt-of-Siddhartha/</id>
    <published>2023-05-15T16:43:47.000Z</published>
    <updated>2023-10-07T05:32:04.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《悉达多》摘录"><a href="#《悉达多》摘录" class="headerlink" title="《悉达多》摘录"></a>《悉达多》摘录</h1><ul><li>您在第 13 页（位置 #186-188）的标注 | 添加于 2023年3月17日星期五 上午5:55:20</li></ul><h1 id="他已经学会如何默念“唵-”——这真言之本：吸气时内心默念，呼气时则集聚全部的精神，每当此刻，他的前额仿佛放射出纯净的心灵之光。他已学会如何在自我存在的深层体认阿特曼——永恒不坏，与宇宙合一。"><a href="#他已经学会如何默念“唵-”——这真言之本：吸气时内心默念，呼气时则集聚全部的精神，每当此刻，他的前额仿佛放射出纯净的心灵之光。他已学会如何在自我存在的深层体认阿特曼——永恒不坏，与宇宙合一。" class="headerlink" title="他已经学会如何默念“唵 ”——这真言之本：吸气时内心默念，呼气时则集聚全部的精神，每当此刻，他的前额仿佛放射出纯净的心灵之光。他已学会如何在自我存在的深层体认阿特曼——永恒不坏，与宇宙合一。"></a>他已经学会如何默念“唵 ”——这真言之本：吸气时内心默念，呼气时则集聚全部的精神，每当此刻，他的前额仿佛放射出纯净的心灵之光。他已学会如何在自我存在的深层体认阿特曼——永恒不坏，与宇宙合一。</h1><ul><li>您在第 15 页（位置 #216-217）的标注 | 添加于 2023年3月17日星期五 上午5:59:35</li></ul><h1 id="他们的确极为渊博，但假如他们不了解那件重要的事，那唯一重要之事，那么是否还值得了解上述的一切"><a href="#他们的确极为渊博，但假如他们不了解那件重要的事，那唯一重要之事，那么是否还值得了解上述的一切" class="headerlink" title="他们的确极为渊博，但假如他们不了解那件重要的事，那唯一重要之事，那么是否还值得了解上述的一切?"></a>他们的确极为渊博，但假如他们不了解那件重要的事，那唯一重要之事，那么是否还值得了解上述的一切?</h1><ul><li>您在第 15 页（位置 #225-226）的标注 | 添加于 2023年3月17日星期五 上午6:00:57</li></ul><h1 id="为什么毫无过错的他要每天沐浴一新，并试图洗清自己的罪孽呢"><a href="#为什么毫无过错的他要每天沐浴一新，并试图洗清自己的罪孽呢" class="headerlink" title="为什么毫无过错的他要每天沐浴一新，并试图洗清自己的罪孽呢?"></a>为什么毫无过错的他要每天沐浴一新，并试图洗清自己的罪孽呢?</h1><ul><li>您在第 20 页（位置 #294-295）的标注 | 添加于 2023年3月17日星期五 上午8:05:55</li></ul><h1 id="所有这一切都不值一顾，一切都是欺骗，一切都散发着谎言的恶臭；无论快乐或是美丽都只是感官造成的幻象，一切注定要腐朽。世界充满苦痛，生命即苦。"><a href="#所有这一切都不值一顾，一切都是欺骗，一切都散发着谎言的恶臭；无论快乐或是美丽都只是感官造成的幻象，一切注定要腐朽。世界充满苦痛，生命即苦。" class="headerlink" title="所有这一切都不值一顾，一切都是欺骗，一切都散发着谎言的恶臭；无论快乐或是美丽都只是感官造成的幻象，一切注定要腐朽。世界充满苦痛，生命即苦。"></a>所有这一切都不值一顾，一切都是欺骗，一切都散发着谎言的恶臭；无论快乐或是美丽都只是感官造成的幻象，一切注定要腐朽。世界充满苦痛，生命即苦。</h1><ul><li>您在第 21 页（位置 #312-312）的标注 | 添加于 2023年3月17日星期五 上午8:08:31</li></ul><h1 id="征服了旧的渴望。又会感到新的渴望。"><a href="#征服了旧的渴望。又会感到新的渴望。" class="headerlink" title="征服了旧的渴望。又会感到新的渴望。"></a>征服了旧的渴望。又会感到新的渴望。</h1><ul><li>您在第 27 页（位置 #409-412）的标注 | 添加于 2023年3月17日星期五 上午8:20:07</li></ul><h1 id="他平和的表情既非欢喜，亦非忧伤。-他仿佛从内心发出温和的微笑。-他静静地，安详地走着，-带着一种神秘的微笑，-这微笑与一个健康婴孩的笑并无不同。"><a href="#他平和的表情既非欢喜，亦非忧伤。-他仿佛从内心发出温和的微笑。-他静静地，安详地走着，-带着一种神秘的微笑，-这微笑与一个健康婴孩的笑并无不同。" class="headerlink" title="他平和的表情既非欢喜，亦非忧伤。 他仿佛从内心发出温和的微笑。 他静静地，安详地走着， 带着一种神秘的微笑， 这微笑与一个健康婴孩的笑并无不同。"></a>他平和的表情既非欢喜，亦非忧伤。 他仿佛从内心发出温和的微笑。 他静静地，安详地走着， 带着一种神秘的微笑， 这微笑与一个健康婴孩的笑并无不同。</h1><ul><li>您在第 33 页（位置 #493-496）的标注 | 添加于 2023年3月18日星期六 下午4:08:55</li></ul><h1 id="让我来告诉你们这些渴求知识的人，不要陷入论辩的渊薮和言辞的冲突。辩言毫无意义，它们或优美或丑陋，或聪明或愚蠢，任何人都可以接受或拒绝。然而你已听过的教义却并非我的辩言，它的目标也并非向那些追求知识的人们解释这个世界。它的目标与众不同：这就是超拔苦难而得救，乔答摩所宣讲的仅此而已"><a href="#让我来告诉你们这些渴求知识的人，不要陷入论辩的渊薮和言辞的冲突。辩言毫无意义，它们或优美或丑陋，或聪明或愚蠢，任何人都可以接受或拒绝。然而你已听过的教义却并非我的辩言，它的目标也并非向那些追求知识的人们解释这个世界。它的目标与众不同：这就是超拔苦难而得救，乔答摩所宣讲的仅此而已" class="headerlink" title="让我来告诉你们这些渴求知识的人，不要陷入论辩的渊薮和言辞的冲突。辩言毫无意义，它们或优美或丑陋，或聪明或愚蠢，任何人都可以接受或拒绝。然而你已听过的教义却并非我的辩言，它的目标也并非向那些追求知识的人们解释这个世界。它的目标与众不同：这就是超拔苦难而得救，乔答摩所宣讲的仅此而已"></a>让我来告诉你们这些渴求知识的人，不要陷入论辩的渊薮和言辞的冲突。辩言毫无意义，它们或优美或丑陋，或聪明或愚蠢，任何人都可以接受或拒绝。然而你已听过的教义却并非我的辩言，它的目标也并非向那些追求知识的人们解释这个世界。它的目标与众不同：这就是超拔苦难而得救，乔答摩所宣讲的仅此而已</h1><ul><li>您在第 34 页（位置 #510-511）的标注 | 添加于 2023年3月20日星期一 下午4:07:56</li></ul><h1 id="我无权去评判他人的生活，我必须为自己做出判断。我必须选择或抛弃。"><a href="#我无权去评判他人的生活，我必须为自己做出判断。我必须选择或抛弃。" class="headerlink" title="我无权去评判他人的生活，我必须为自己做出判断。我必须选择或抛弃。"></a>我无权去评判他人的生活，我必须为自己做出判断。我必须选择或抛弃。</h1><ul><li>您在第 37 页（位置 #556-556）的标注 | 添加于 2023年4月4日星期二 上午1:27:41</li></ul><h1 id="意义与实在并非隐藏于事物的背后，而是寓于事物自身，寓于事物的一切现象。"><a href="#意义与实在并非隐藏于事物的背后，而是寓于事物自身，寓于事物的一切现象。" class="headerlink" title="意义与实在并非隐藏于事物的背后，而是寓于事物自身，寓于事物的一切现象。"></a>意义与实在并非隐藏于事物的背后，而是寓于事物自身，寓于事物的一切现象。</h1><ul><li>您在第 37 页（位置 #557-558）的标注 | 添加于 2023年4月4日星期二 上午1:28:22</li></ul><h1 id="一个人阅读一本所要研究的书，他不会去鄙弃书的字母和句点并把它们斥为幻象，斥为偶然的无意义的躯壳，"><a href="#一个人阅读一本所要研究的书，他不会去鄙弃书的字母和句点并把它们斥为幻象，斥为偶然的无意义的躯壳，" class="headerlink" title="一个人阅读一本所要研究的书，他不会去鄙弃书的字母和句点并把它们斥为幻象，斥为偶然的无意义的躯壳，"></a>一个人阅读一本所要研究的书，他不会去鄙弃书的字母和句点并把它们斥为幻象，斥为偶然的无意义的躯壳，</h1><ul><li>您在第 48 页（位置 #731-733）的标注 | 添加于 2023年4月15日星期六 下午4:33:45</li></ul><h1 id="悉达多想，这种生活没有任何难题。当我还是沙门的时候，一切都是艰难和烦恼，最终是绝望。而现在一切都非常容易，容易得就像伽摩拉的亲吻指令。我需要衣服与金钱，仅此而已。这都是不会搅乱一个人睡眠的简单目标。"><a href="#悉达多想，这种生活没有任何难题。当我还是沙门的时候，一切都是艰难和烦恼，最终是绝望。而现在一切都非常容易，容易得就像伽摩拉的亲吻指令。我需要衣服与金钱，仅此而已。这都是不会搅乱一个人睡眠的简单目标。" class="headerlink" title="悉达多想，这种生活没有任何难题。当我还是沙门的时候，一切都是艰难和烦恼，最终是绝望。而现在一切都非常容易，容易得就像伽摩拉的亲吻指令。我需要衣服与金钱，仅此而已。这都是不会搅乱一个人睡眠的简单目标。"></a>悉达多想，这种生活没有任何难题。当我还是沙门的时候，一切都是艰难和烦恼，最终是绝望。而现在一切都非常容易，容易得就像伽摩拉的亲吻指令。我需要衣服与金钱，仅此而已。这都是不会搅乱一个人睡眠的简单目标。</h1><ul><li>您在第 49 页（位置 #750-751）的标注 | 添加于 2023年4月15日星期六 下午4:36:00</li></ul><h1 id="他也无需激动，他只是被牵引并且任凭自己的沉落。他只为自己的目标所牵引，他不允许任何扰乱自己目标的东西进入他的心境"><a href="#他也无需激动，他只是被牵引并且任凭自己的沉落。他只为自己的目标所牵引，他不允许任何扰乱自己目标的东西进入他的心境" class="headerlink" title="他也无需激动，他只是被牵引并且任凭自己的沉落。他只为自己的目标所牵引，他不允许任何扰乱自己目标的东西进入他的心境"></a>他也无需激动，他只是被牵引并且任凭自己的沉落。他只为自己的目标所牵引，他不允许任何扰乱自己目标的东西进入他的心境</h1><ul><li>您在第 50 页（位置 #752-754）的标注 | 添加于 2023年4月15日星期六 下午4:36:10</li></ul><h1 id="。没有任何事物是由神灵的驱使，世上并不存在神灵。只要能够思考、等待和斋戒。任何人都可以施魔法，任何人都可以达到自己的目标。”-伽摩拉静静地听着，她喜爱"><a href="#。没有任何事物是由神灵的驱使，世上并不存在神灵。只要能够思考、等待和斋戒。任何人都可以施魔法，任何人都可以达到自己的目标。”-伽摩拉静静地听着，她喜爱" class="headerlink" title="。没有任何事物是由神灵的驱使，世上并不存在神灵。只要能够思考、等待和斋戒。任何人都可以施魔法，任何人都可以达到自己的目标。” 伽摩拉静静地听着，她喜爱"></a>。没有任何事物是由神灵的驱使，世上并不存在神灵。只要能够思考、等待和斋戒。任何人都可以施魔法，任何人都可以达到自己的目标。” 伽摩拉静静地听着，她喜爱</h1><ul><li>您在第 50 页（位置 #752-753）的标注 | 添加于 2023年4月15日星期六 下午4:36:15</li></ul><h1 id="。没有任何事物是由神灵的驱使，世上并不存在神灵。只要能够思考、等待和斋戒。任何人都可以施魔法，任何人都可以达到自己的目标。”"><a href="#。没有任何事物是由神灵的驱使，世上并不存在神灵。只要能够思考、等待和斋戒。任何人都可以施魔法，任何人都可以达到自己的目标。”" class="headerlink" title="。没有任何事物是由神灵的驱使，世上并不存在神灵。只要能够思考、等待和斋戒。任何人都可以施魔法，任何人都可以达到自己的目标。”"></a>。没有任何事物是由神灵的驱使，世上并不存在神灵。只要能够思考、等待和斋戒。任何人都可以施魔法，任何人都可以达到自己的目标。”</h1><ul><li>您在第 50 页（位置 #752-753）的标注 | 添加于 2023年4月15日星期六 下午4:36:23</li></ul><h1 id="没有任何事物是由神灵的驱使，世上并不存在神灵。只要能够思考、等待和斋戒。任何人都可以施魔法，任何人都可以达到自己的目标。”"><a href="#没有任何事物是由神灵的驱使，世上并不存在神灵。只要能够思考、等待和斋戒。任何人都可以施魔法，任何人都可以达到自己的目标。”" class="headerlink" title="没有任何事物是由神灵的驱使，世上并不存在神灵。只要能够思考、等待和斋戒。任何人都可以施魔法，任何人都可以达到自己的目标。”"></a>没有任何事物是由神灵的驱使，世上并不存在神灵。只要能够思考、等待和斋戒。任何人都可以施魔法，任何人都可以达到自己的目标。”</h1><ul><li>您在第 54 页（位置 #821-822）的标注 | 添加于 2023年5月3日星期三 下午3:31:11</li></ul><h1 id="。我也没有以懊恼和急躁的情绪来伤害自己或是伤害他人。如果我有机会再去那里，或许还是去收购稻米，或许为了其他事情，那么那里的朋友们一定会欢迎我"><a href="#。我也没有以懊恼和急躁的情绪来伤害自己或是伤害他人。如果我有机会再去那里，或许还是去收购稻米，或许为了其他事情，那么那里的朋友们一定会欢迎我" class="headerlink" title="。我也没有以懊恼和急躁的情绪来伤害自己或是伤害他人。如果我有机会再去那里，或许还是去收购稻米，或许为了其他事情，那么那里的朋友们一定会欢迎我"></a>。我也没有以懊恼和急躁的情绪来伤害自己或是伤害他人。如果我有机会再去那里，或许还是去收购稻米，或许为了其他事情，那么那里的朋友们一定会欢迎我</h1><ul><li>您在第 59 页（位置 #897-899）的标注 | 添加于 2023年5月5日星期五 下午6:01:50</li></ul><h1 id="。然而，他一直觉得自己与众不同并带着一种优越感。他总是带着一点轻蔑来看待世人，带着那么一种嘲讽般的不屑，正如一个沙门总是对尘俗的人们感到那种不屑"><a href="#。然而，他一直觉得自己与众不同并带着一种优越感。他总是带着一点轻蔑来看待世人，带着那么一种嘲讽般的不屑，正如一个沙门总是对尘俗的人们感到那种不屑" class="headerlink" title="。然而，他一直觉得自己与众不同并带着一种优越感。他总是带着一点轻蔑来看待世人，带着那么一种嘲讽般的不屑，正如一个沙门总是对尘俗的人们感到那种不屑"></a>。然而，他一直觉得自己与众不同并带着一种优越感。他总是带着一点轻蔑来看待世人，带着那么一种嘲讽般的不屑，正如一个沙门总是对尘俗的人们感到那种不屑</h1><ul><li>您在第 59 页（位置 #902-904）的标注 | 添加于 2023年5月5日星期五 下午6:02:48</li></ul><h1 id="世人对自己的生活所持的那种重大感，他们深刻的欢乐与忧伤，以及那种无休止地推动他们去爱的力量所带给他们的焦虑而甜美的幸福。这些人永远爱着他们自己，爱着他们的孩子，爱着荣誉和利益，爱着对未来的筹划和企盼"><a href="#世人对自己的生活所持的那种重大感，他们深刻的欢乐与忧伤，以及那种无休止地推动他们去爱的力量所带给他们的焦虑而甜美的幸福。这些人永远爱着他们自己，爱着他们的孩子，爱着荣誉和利益，爱着对未来的筹划和企盼" class="headerlink" title="世人对自己的生活所持的那种重大感，他们深刻的欢乐与忧伤，以及那种无休止地推动他们去爱的力量所带给他们的焦虑而甜美的幸福。这些人永远爱着他们自己，爱着他们的孩子，爱着荣誉和利益，爱着对未来的筹划和企盼"></a>世人对自己的生活所持的那种重大感，他们深刻的欢乐与忧伤，以及那种无休止地推动他们去爱的力量所带给他们的焦虑而甜美的幸福。这些人永远爱着他们自己，爱着他们的孩子，爱着荣誉和利益，爱着对未来的筹划和企盼</h1><ul><li>您在第 61 页（位置 #930-931）的标注 | 添加于 2023年5月5日星期五 下午6:04:40</li></ul><h1 id="后又回到那种追求和积聚财富的冲动。在这毫无意义的循环之中，他把自"><a href="#后又回到那种追求和积聚财富的冲动。在这毫无意义的循环之中，他把自" class="headerlink" title="后又回到那种追求和积聚财富的冲动。在这毫无意义的循环之中，他把自"></a>后又回到那种追求和积聚财富的冲动。在这毫无意义的循环之中，他把自</h1><ul><li>您在第 61 页（位置 #931-931）的标注 | 添加于 2023年5月5日星期五 下午6:04:46</li></ul><h1 id="在这毫无意义的循环之中，他把自己拖得筋疲力尽，变得衰老而病态。"><a href="#在这毫无意义的循环之中，他把自己拖得筋疲力尽，变得衰老而病态。" class="headerlink" title="在这毫无意义的循环之中，他把自己拖得筋疲力尽，变得衰老而病态。"></a>在这毫无意义的循环之中，他把自己拖得筋疲力尽，变得衰老而病态。</h1><ul><li>您在第 65 页（位置 #997-999）的标注 | 添加于 2023年5月5日星期五 下午6:10:07</li></ul><h1 id="他热切地希求空寂，希求安宁，希求死亡。就让一道雷电来将他击毁-就让一条猛虎来将他吞噬！要是有某种烈酒、某种毒药能够给予他虚无，让他忘却，让他长眠不醒，那该有多好"><a href="#他热切地希求空寂，希求安宁，希求死亡。就让一道雷电来将他击毁-就让一条猛虎来将他吞噬！要是有某种烈酒、某种毒药能够给予他虚无，让他忘却，让他长眠不醒，那该有多好" class="headerlink" title="他热切地希求空寂，希求安宁，希求死亡。就让一道雷电来将他击毁!就让一条猛虎来将他吞噬！要是有某种烈酒、某种毒药能够给予他虚无，让他忘却，让他长眠不醒，那该有多好"></a>他热切地希求空寂，希求安宁，希求死亡。就让一道雷电来将他击毁!就让一条猛虎来将他吞噬！要是有某种烈酒、某种毒药能够给予他虚无，让他忘却，让他长眠不醒，那该有多好</h1><ul><li>您在第 67 页（位置 #1016-1017）的标注 | 添加于 2023年5月5日星期五 下午6:12:28</li></ul><h1 id="他已经在寻求死亡。通过毁灭肉体以获得安宁的天真愿望在他的内心竟已如此强烈。"><a href="#他已经在寻求死亡。通过毁灭肉体以获得安宁的天真愿望在他的内心竟已如此强烈。" class="headerlink" title="他已经在寻求死亡。通过毁灭肉体以获得安宁的天真愿望在他的内心竟已如此强烈。"></a>他已经在寻求死亡。通过毁灭肉体以获得安宁的天真愿望在他的内心竟已如此强烈。</h1><ul><li>您在第 75 页（位置 #1149-1149）的标注 | 添加于 2023年5月5日星期五 下午6:23:34</li></ul><h1 id="他看到河水无间断地流转不居，而同时却又恒常不变地存在着；河水永无迁变却又刻刻常新。"><a href="#他看到河水无间断地流转不居，而同时却又恒常不变地存在着；河水永无迁变却又刻刻常新。" class="headerlink" title="他看到河水无间断地流转不居，而同时却又恒常不变地存在着；河水永无迁变却又刻刻常新。"></a>他看到河水无间断地流转不居，而同时却又恒常不变地存在着；河水永无迁变却又刻刻常新。</h1><ul><li>您在第 79 页（位置 #1207-1209）的标注 | 添加于 2023年5月5日星期五 下午6:27:28</li></ul><h1 id="河水在同一时刻无处不在，遍及源头，河口、瀑布、渡口、水流、海洋以及山脉之间；从另一方面来说，现在只为其自身而存在，并非过去或未来的影子。”"><a href="#河水在同一时刻无处不在，遍及源头，河口、瀑布、渡口、水流、海洋以及山脉之间；从另一方面来说，现在只为其自身而存在，并非过去或未来的影子。”" class="headerlink" title="河水在同一时刻无处不在，遍及源头，河口、瀑布、渡口、水流、海洋以及山脉之间；从另一方面来说，现在只为其自身而存在，并非过去或未来的影子。”"></a>河水在同一时刻无处不在，遍及源头，河口、瀑布、渡口、水流、海洋以及山脉之间；从另一方面来说，现在只为其自身而存在，并非过去或未来的影子。”</h1><ul><li>您在第 79 页（位置 #1212-1212）的标注 | 添加于 2023年5月5日星期五 下午6:27:55</li></ul><h1 id="不可得，未来之心不可得，万法皆如，俱入目前。"><a href="#不可得，未来之心不可得，万法皆如，俱入目前。" class="headerlink" title="不可得，未来之心不可得，万法皆如，俱入目前。"></a>不可得，未来之心不可得，万法皆如，俱入目前。</h1><ul><li>您在第 79 页（位置 #1212-1212）的标注 | 添加于 2023年5月5日星期五 下午6:28:01</li></ul><h1 id="万法皆如，俱入目前。"><a href="#万法皆如，俱入目前。" class="headerlink" title="万法皆如，俱入目前。"></a>万法皆如，俱入目前。</h1><ul><li>您在第 82 页（位置 #1249-1249）的标注 | 添加于 2023年5月5日星期五 下午6:30:32</li></ul><h1 id="让他死好了，这和我们孩子有什么关系呢"><a href="#让他死好了，这和我们孩子有什么关系呢" class="headerlink" title="让他死好了，这和我们孩子有什么关系呢?"></a>让他死好了，这和我们孩子有什么关系呢?</h1><ul><li>您在第 93 页（位置 #1422-1423）的标注 | 添加于 2023年5月5日星期五 下午6:41:38</li></ul><h1 id="悉达多此时的思维竟如此幼稚，如此缺乏逻辑，他与凡俗的人们竟变得如此相像"><a href="#悉达多此时的思维竟如此幼稚，如此缺乏逻辑，他与凡俗的人们竟变得如此相像" class="headerlink" title="悉达多此时的思维竟如此幼稚，如此缺乏逻辑，他与凡俗的人们竟变得如此相像"></a>悉达多此时的思维竟如此幼稚，如此缺乏逻辑，他与凡俗的人们竟变得如此相像</h1><ul><li>您在第 98 页（位置 #1491-1492）的标注 | 添加于 2023年5月5日星期五 下午6:46:58</li></ul><h1 id="而所有的音声，所有的目标，所有的渴望，所有的善与恶，悲伤与欢乐，所有这一切共同构成了统一的世界，"><a href="#而所有的音声，所有的目标，所有的渴望，所有的善与恶，悲伤与欢乐，所有这一切共同构成了统一的世界，" class="headerlink" title="而所有的音声，所有的目标，所有的渴望，所有的善与恶，悲伤与欢乐，所有这一切共同构成了统一的世界，"></a>而所有的音声，所有的目标，所有的渴望，所有的善与恶，悲伤与欢乐，所有这一切共同构成了统一的世界，</h1><ul><li>您在第 100 页（位置 #1523-1524）的标注 | 添加于 2023年5月5日星期五 下午6:49:17</li></ul><h1 id="当一个人有所追寻，”悉达多道，“他只会看到他所追寻之物。他之所以无所发现，无所获得是因为他只专注于他所追寻之物，因为他执迷于自己的目标。"><a href="#当一个人有所追寻，”悉达多道，“他只会看到他所追寻之物。他之所以无所发现，无所获得是因为他只专注于他所追寻之物，因为他执迷于自己的目标。" class="headerlink" title="当一个人有所追寻，”悉达多道，“他只会看到他所追寻之物。他之所以无所发现，无所获得是因为他只专注于他所追寻之物，因为他执迷于自己的目标。"></a>当一个人有所追寻，”悉达多道，“他只会看到他所追寻之物。他之所以无所发现，无所获得是因为他只专注于他所追寻之物，因为他执迷于自己的目标。</h1><ul><li>您在第 102 页（位置 #1564-1566）的标注 | 添加于 2023年5月5日星期五 下午6:53:20</li></ul><h1 id="。因此，我认为一切的存在皆为至善——无论是死与生，无论罪孽与虔诚，无论智慧或是蠢行，一切皆是必然，一切只须我的欣然赞同，一切只需我的理解与爱心"><a href="#。因此，我认为一切的存在皆为至善——无论是死与生，无论罪孽与虔诚，无论智慧或是蠢行，一切皆是必然，一切只须我的欣然赞同，一切只需我的理解与爱心" class="headerlink" title="。因此，我认为一切的存在皆为至善——无论是死与生，无论罪孽与虔诚，无论智慧或是蠢行，一切皆是必然，一切只须我的欣然赞同，一切只需我的理解与爱心"></a>。因此，我认为一切的存在皆为至善——无论是死与生，无论罪孽与虔诚，无论智慧或是蠢行，一切皆是必然，一切只须我的欣然赞同，一切只需我的理解与爱心</h1><ul><li>您在第 103 页（位置 #1579-1580）的标注 | 添加于 2023年5月5日星期五 下午6:54:38</li></ul><h1 id="而值得礼敬之处。可我不想再谈下去，言词不能很好地表达思想。思想一旦形诸言词即刻就会有所改变，有所歪曲，有点愚蠢。"><a href="#而值得礼敬之处。可我不想再谈下去，言词不能很好地表达思想。思想一旦形诸言词即刻就会有所改变，有所歪曲，有点愚蠢。" class="headerlink" title="而值得礼敬之处。可我不想再谈下去，言词不能很好地表达思想。思想一旦形诸言词即刻就会有所改变，有所歪曲，有点愚蠢。"></a>而值得礼敬之处。可我不想再谈下去，言词不能很好地表达思想。思想一旦形诸言词即刻就会有所改变，有所歪曲，有点愚蠢。</h1><ul><li>您在第 105 页（位置 #1604-1605）的标注 | 添加于 2023年5月5日星期五 下午6:56:46</li></ul><p>这就是我之所以如此怀疑言词的原因。我知道这种言词的冲突是一种幻象，</p>]]></content>
    
    
    <summary type="html">万法皆如，俱入目前。</summary>
    
    
    
    <category term="什锦" scheme="http://euds63.github.io/categories/%E4%BB%80%E9%94%A6/"/>
    
    
    <category term="感想" scheme="http://euds63.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
    <category term="书评" scheme="http://euds63.github.io/tags/%E4%B9%A6%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>Internet</title>
    <link href="http://euds63.github.io/2023/Internet/"/>
    <id>http://euds63.github.io/2023/Internet/</id>
    <published>2023-05-05T14:51:21.000Z</published>
    <updated>2023-10-07T05:32:04.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h1><p><strong>暂时用这个标题，还没想好</strong></p><p><strong>打算用来记录互联网带给我激动的事情。可以是网站，或者是事件</strong></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>我蛮喜欢做这样一件事情，点击一个网站中感兴趣的链接，跳转到另一个网站。如此重复多次，再回头去看时，我常常记不得自己是从哪跳转到这个网站。但往往打开的网站都能让我有所收获，至少觉得有趣。</p><p>很多博客也会设置友链接力。还有个蛮有意境的名字叫“开往”。</p><p>互联网将人与人之间的距离大大减小，却还是形成了大大小小的孤岛。而这一个个链接就像连接这一座座孤岛的桥。</p><p>六度分隔理论最早提出的时候是1967年，那时候还没有互联网。而几十年后的今天，在互联网的帮助下，只需要好的链接，中间人甚至可以不再需要6个，就可以将世界上任何本来互不相识的两人建立起联系。</p><p>我觉得这就是互联网于我的魅力。</p><h2 id="2023年4月25日"><a href="#2023年4月25日" class="headerlink" title="2023年4月25日"></a>2023年4月25日</h2><p>今天想到要看下比特币诞生的那篇论文<a href="https://bitcoin.org/bitcoin.pdf">Bitcoin: A Peer-to-Peer Electronic Cash System</a>。论文中参考文献中有个链接，我抱着试试看的心态点了进去。<a href="http://www.weidai.com/bmoney.txt">网站</a>加载得很快。没有太多的修饰，它就只是文字。那时候就有种被触动的感觉。1998年的互联网，我就这样无意中窥探到了。</p><p>更让我惊讶的是，这个网站最近修改的时间是1&#x2F;10&#x2F;2021。我很难用恰当的言语去描述我现在的感觉。但就是感觉很惊喜。</p><p>然后我去搜了下作者，戴伟，华裔。他当时写这篇文章的时候大概是22岁左右。！！！</p><h2 id="2023年5月2日"><a href="#2023年5月2日" class="headerlink" title="2023年5月2日"></a>2023年5月2日</h2><p>发现了这个网站<a href="https://playgameoflife.com/">Game of Life</a>。我一直有自己实现一个生命游戏的想法，但始终没有动手。这个网站做得很好，可以用来参考。</p><h2 id="2023年5月5日"><a href="#2023年5月5日" class="headerlink" title="2023年5月5日"></a>2023年5月5日</h2><p>今天经历了一个很有意思的事情。</p><ol><li>最开始时看到timeline上有人star了<a href="https://github.com/SuikaXhq/seu-bachelor-thesis-2022">SuikaXhq&#x2F;seu-bachelor-thesis-2022</a>。</li><li>发现项目的作者star的项目中有一个<a href="https://github.com/seuite/awesome-seu">seuite&#x2F;awesome-seu</a>。</li><li>接着就发现了一个学校里曾存在并活跃着的协会——东南大学网络技术和开源技术协会。虽然很可惜的是：这个协会已经不再传承，而且它的官方网站也已经挂掉了。但从它在Github上仍存在的项目和博客上仍能看到这是一个很有趣的协会。</li><li>这个协会的会长也有写博客，虽然已经无法访问，但项目中有一句话让我觉得很有感触。<blockquote><p>一个对计算机充满好奇的小男孩现在长大成为一个对计算机更加好奇的大男孩了。我始终还是觉得自己没有摸到计算机的门槛，觉得这个巨大的世界我仅仅只探索了极其微小的一角。过去的天才们，工程师们，平凡人们探索过的世界已经不小，可是抬头看看，那浩瀚的，未知的，多么美丽而又神秘的新世界，还等待着我，我的朋友们，老师们，以及所有的人们继续去学习，去探索它。我相信计算机带给人类的绝不仅仅只有现在这么一点点成就，还有更多，更远，更辽阔的内容等着我们一代人，一代人地走下去，寻找下去，喜欢下去。</p></blockquote> 我喜欢这个观点。</li><li>今天还发现了好几位很优秀的学长。从他们的博客中看到他们当年的一些想法和经历的事情。特别是他们上学时的笔记。这种感觉就很奇妙。</li></ol><h2 id="2023年9月13日"><a href="#2023年9月13日" class="headerlink" title="2023年9月13日"></a>2023年9月13日</h2><p><a href="https://spacewar.oversigma.com/">Spacewar!</a>.</p><p>刚开始还不得其法，玩了几分钟后才明白。挺有趣的一个小游戏。更吸引我的是它是1962年的游戏。厚重的历史感，好游戏那种穿越时间的魅力。太美妙了。</p><p>然后又突然想到Steam上那款测试游戏，也是叫Spacewar，致敬?巧合?有一种奇妙感。</p><h2 id="2023年10月6日"><a href="#2023年10月6日" class="headerlink" title="2023年10月6日"></a>2023年10月6日</h2><p><a href="https://softwareengineering.stackexchange.com/questions/108124/why-it-is-called-hash-table-or-hash-function-hash-doesnt-make-any-sense-t">naming - Why it is called “hash table”, or “hash function”? </a></p><p>可能是我理解有问题，看完后还是不太理解为什么要叫hash。底下的回答似乎都是在说hash是用来做什么的。</p>]]></content>
    
    
    <summary type="html">打算用来记录互联网带给我激动的事情。可以是网站，或者是事件</summary>
    
    
    
    <category term="什锦" scheme="http://euds63.github.io/categories/%E4%BB%80%E9%94%A6/"/>
    
    
    <category term="博客" scheme="http://euds63.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="感想" scheme="http://euds63.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>诗词里的地名</title>
    <link href="http://euds63.github.io/2023/place-names-in-poetry/"/>
    <id>http://euds63.github.io/2023/place-names-in-poetry/</id>
    <published>2023-04-30T16:32:17.000Z</published>
    <updated>2023-10-07T05:32:04.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="诗词里的地名"><a href="#诗词里的地名" class="headerlink" title="诗词里的地名"></a>诗词里的地名</h1><p><strong>出去旅游，有件事我一直很热衷，就是去那些在诗词中出现过的地方中走走。这往往能给我一种感觉，用张若虚的话来说就是“人生代代无穷已，江月年年望相似”。让我如此热衷的还有另一个原因：古人在某个地点因事因景所凝聚的个人感受，能让现在的我读到。而当年他们所在的地方或者地名，又能流传至今。这两点每一点都是很难得的，而两点同时发生，更是凤毛麟角。</strong></p><h2 id="南京"><a href="#南京" class="headerlink" title="南京"></a>南京</h2><h3 id="金陵"><a href="#金陵" class="headerlink" title="金陵"></a>金陵</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">桂枝香·金陵怀古 王安石<br><br>登临送目，正故国晚秋，天气初肃。千里澄江似练，翠峰如簇。归帆去棹残阳里，背西风，酒旗斜矗。彩舟云淡，星河鹭起，画图难足。<br><br>念往昔，繁华竞逐，叹门外楼头，悲恨相续。千古凭高对此，谩嗟荣辱。六朝旧事随流水，但寒烟衰草凝绿。至今商女，时时犹唱，后庭遗曲。<span class="hljs-comment">(衰草 一作：芳草)</span><br></code></pre></td></tr></table></figure><h2 id="扬州"><a href="#扬州" class="headerlink" title="扬州"></a>扬州</h2><h3 id="扬州-1"><a href="#扬州-1" class="headerlink" title="扬州"></a>扬州</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">江城子 苏轼<br>墨云拖雨过西楼。水东流，晚烟收。柳外残阳，回照动帘钩。今夜巫山真个好，花未落，酒新篘。<br><br>美人微笑转星眸。月华羞，捧金瓯。歌扇萦风，吹散一春愁。试问江南诸伴侣，谁似我，醉扬州。<br></code></pre></td></tr></table></figure><p>喜欢“墨云拖雨”中这个“拖”字。这几天雨下得很大，雨云我也常常看，但想不到用“拖”去形容。</p><h3 id="维扬"><a href="#维扬" class="headerlink" title="维扬"></a>维扬</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">扬州慢 姜夔<br><br>淳熙丙申至日，予过维扬。夜雪初霁，荠麦弥望。入其城则四顾萧条，寒水自碧，暮色渐起，戍角悲吟。予怀怆然，感慨今昔，因自度此曲。千岩老人以为有《黍离》之悲也。<br><br>淮左名都，竹西佳处，解鞍少驻初程。过春风十里，尽荠麦青青。自胡马窥江去后，废池乔木，犹厌言兵。渐黄昏，清角吹寒，都在空城。<br><br>杜郎俊赏，算而今，重到须惊。纵豆蔻词工，青楼梦好，难赋深情。二十四桥仍在，波心荡，冷月无声。念桥边红药，年年知为谁生？<br></code></pre></td></tr></table></figure><p>扬州城历史上很坎坷，几经战乱。姜夔当时写下这首词时，杨州正是战乱结束。但他描绘的还是很有意境的。我觉得单是这词牌名就很美。很简单的一个“慢”字，就写出了一种令人向往的生活节奏。</p><h3 id="瓜州"><a href="#瓜州" class="headerlink" title="瓜州"></a>瓜州</h3><ul><li><p><em>楼船夜雪瓜洲渡，铁马秋风大散关。</em></p></li><li><p><em>京口瓜州一水间</em></p></li></ul><p>瓜州渡现在是一个公园。我经过，但还没有进去过。</p><p>可以坐镇扬汽渡来体验“一水间”。体验感很不错：大货车，小车，人共乘一艘船。江面宽阔，江风蛮大的，甚至有些冷。</p><h3 id="二十四桥"><a href="#二十四桥" class="headerlink" title="二十四桥"></a>二十四桥</h3><ul><li><em>二十四桥明月夜，玉人何处教吹箫。</em></li><li><em>二十四桥仍在，波心荡，冷月无声。</em></li></ul><p>我之前读到“二十四桥明月夜”的时候，下意识地想象成是月光照耀下的二十四座桥。但现在二十四桥是瘦西湖景区内的一座景点，只有一座桥。</p><p>但据黄永玉老先生的经历，他年轻时也去找过，但“狠狠地走了一趟”后，“连二十四桥桥基都捉摸不到”。如果那桥就在瘦西湖景区内，我想他并不需要费这么大一番功夫。所以我仍愿意保留自己之前的想象。</p><h3 id="春江"><a href="#春江" class="headerlink" title="春江"></a>春江</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs">春江花月夜 张若虚<br>春江潮水连海平，海上明月共潮生。<br><br>滟滟随波千万里，何处春江无月明！<br><br>江流宛转绕芳甸，月照花林皆似霰。<br><br>空里流霜不觉飞，汀上白沙看不见。<br><br>江天一色无纤尘，皎皎空中孤月轮。<br><br>江畔何人初见月？江月何年初照人？<br><br>人生代代无穷已，江月年年望相似。<br><br>不知江月待何人，但见长江送流水。<br><br>白云一片去悠悠，青枫浦上不胜愁。<br><br>谁家今夜扁舟子？何处相思明月楼？<br><br>可怜楼上月徘徊，应照离人妆镜台。<br><br>玉户帘中卷不去，捣衣砧上拂还来。<br><br>此时相望不相闻，愿逐月华流照君。<br><br>鸿雁长飞光不度，鱼龙潜跃水成文。<br><br>昨夜闲潭梦落花，可怜春半不还家。<br><br>江水流春去欲尽，江潭落月复西斜。<br><br>斜月沉沉藏海雾，碣石潇湘无限路。<br><br>不知乘月几人归，落月摇情满江树。<br></code></pre></td></tr></table></figure><p>此首诗中的春江说法众多，主流的有三种说法，但都是指向扬州<br>（我中学的时候，慕着其“孤篇压倒全唐”之名背过，但到如今还是不能完全欣赏。背的也是七零八落，惭愧）</p>]]></content>
    
    
    <summary type="html">人生代代无穷已，江月年年望相似</summary>
    
    
    
    <category term="想法" scheme="http://euds63.github.io/categories/%E6%83%B3%E6%B3%95/"/>
    
    
    <category term="记录" scheme="http://euds63.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="感想" scheme="http://euds63.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
    <category term="出游" scheme="http://euds63.github.io/tags/%E5%87%BA%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>博客与文章</title>
    <link href="http://euds63.github.io/2023/Blog-and-Articles/"/>
    <id>http://euds63.github.io/2023/Blog-and-Articles/</id>
    <published>2023-04-30T08:06:34.000Z</published>
    <updated>2023-10-07T05:32:04.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博客与文章"><a href="#博客与文章" class="headerlink" title="博客与文章"></a>博客与文章</h1><p><em>打算记录些我看过的觉得有意思的博客和文章</em><br><em>博客会简单写下推荐的理由，其实也说不上推荐，因为我觉得这些博主都可以称得上是我需要向之学习的大佬</em><br><em>文章会简单记录下自己读的感受，但会避免变成是对文章的梗概</em></p><p><del><strong>感觉这个题目不能很好地概括我这篇的内容，但现在又没想好</strong></del></p><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><ul><li><a href="https://plantegg.github.io/">plantegg</a> 计算机网络相关的，干货很多</li><li><a href="https://plumz.me/">Plum’s Blog</a> 作者很有趣，涉猎也很广泛。博客持续更新了十几年了。</li><li><a href="https://freemind.pluskid.org/">Free Mind</a> 有思考，有科普，内容足。</li><li><a href="https://blog.jm233333.com/">JM233333’s Blog</a> 作者是南大在读博士生，也是jyy操作系统课的助教</li><li><a href="https://seuite.github.io/">SEUITE</a> 偶然间发现的学校曾存在过的一个协会。从仅存的内容中可以看出是一个很有意思的社团，很可惜它没有传承下来。</li><li><a href="https://soulogic.com/about">灵魂逻辑</a> 先关注的Twitter才发现的博客。作者的经历蛮羡慕的。</li><li><a href="https://rehoni.github.io/cn/">罗皓的个人博客</a> 一个学长&#x2F;学姐的blog。从17年还在大学，到最后一篇博文是痛风的注意事项，能看出ta经历了很多。很吸引我的是ta对每个月支出的总结，虽然可能没太多参考夹着，但还是能让我对以后可能的生活一窥一二。</li></ul><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><ul><li><p><a href="https://plumz.me/archives/12906/">你所热爱的，就是你的生活</a><br>我还蛮喜欢看别人写的年度总结的。像是开了一扇窗去了解一个陌生人一年来的生活。但自己却没啥勇气去写年度总结，并将之放之网上。再说回来这篇文章，我很认同这段话。</p><blockquote><p>有时候我想想，互联网给我带来的是更多时光的消磨，有的时候，我是不是应该返璞归真，多多做一些“远离网络”的事情。比如翻出自己曾经买过的那些书，拿出自己还没有拆封的音乐 CD，找到自己当年吃灰的 3DS，享受那些我们还没有被浮躁的互联网绑架时候的珍贵东西，或许这样对我来说是更好的选择，自己也会得到更多的提高。</p></blockquote><p>我有好多时间是用来刷Twitter，贴吧，尽管这些碎片化的东西常常就是刷过去就忘了。我觉得我的这些时间值得更好的去处。</p></li><li><p><a href="https://www.jasonwei.net/blog/practicing-ai-research">Practicing AI research</a></p><ul><li>这句让我印象很深。有被激励到。<blockquote><p>doing research is a skill that can be learned through practice, much like sports or music.</p></blockquote></li><li>作者谈到沉没成本时，是这样说的”it’s important to identify sunk cost fallacies”。我的理解是当断则断，不要过多地去考虑沉没成本。</li></ul></li><li><p><a href="https://luolei.org/gfw/">GFW之父方滨兴讲座后杂想</a></p><ul><li>看到这篇的时候觉得很巧。因为我之前就follow了作者的Twitter。现在无意间看到了他十年前还在上大学时听讲座的想法。这种感觉很棒。</li><li>另一个感触是尽管十年过去，这篇文章依旧没有过时。甚至墙更高了些。作者文中的畅想”不知20年后，如果我们走进了一个开放、自由的公民社会，那堵墙不再，方校长还在的话，他会怎么回味自己的所作所为。”距离当时的二十年后，还有十年。</li><li>但最近有一个现象我看着很欣喜。我看到周围好多同学都在用着ChatGPT。而用它是需要用代理的。</li></ul></li><li><p><a href="https://freemind.pluskid.org/misc/elden-ring-pvp-and-theory-of-mind/">Elden Ring PvP and Theory of Mind</a></p><ul><li>很有趣，作者从pvp讲到ToM。并科普了ToM的概念。我觉得作者科普的很好。既讲明白了概念，还让读者——至少是我，对此有了进一步了解的兴趣。</li><li>文中谈到 AI 语言模型。让我想到之前看过的LLM继续发展下去，可能会有类似读心术的效果，能预测你下一步要做什么，甚至是在想什么。我觉得这在一定程度是可行的。因为现代所谓的一些读心术，很多都是基于微表情的观察和分析其过去的行为模式和经历上。</li></ul></li><li><p><a href="https://freemind.pluskid.org/electronics/5x12-keyboard-debugging2/">记一次有意义的熬夜</a></p><ul><li>作者客制化键盘的经历。</li><li>我自己算是半个机械键盘爱好者，也接触了些客制化键盘，但一直只停留在很初级的阶段。所以看得很起劲。</li></ul></li><li><p><a href="https://soulogic.com/item/3294">我的郑老三死了</a> </p><ul><li>作者纪念自己的猫</li><li>很有感觉</li></ul></li><li><p><a href="https://www.skywind.me/blog/archives/2719">互联网技术比游戏后端技术领先十年吗？</a></p><ul><li>现在已经习以为然的互联网体验，其背后的技术令人咋舌。</li></ul></li><li><p><a href="https://www.kivinsae.com/2023/05/17/2023-05-17-no_sophism/">关于 初码先生 某推中典型诡辩论部分的拆解</a></p><ul><li>有趣</li></ul></li><li><h2 id="Fire-And-Motion-作者在文中有个观点：大公司不断地技术迭代，有一部分原因是为了让竞争对手疲于奔命，“has-no-choice-but-to-spend-all-their-time-porting-and-keeping-up-time-that-they-can’t-spend-writing-new-features-”"><a href="#Fire-And-Motion-作者在文中有个观点：大公司不断地技术迭代，有一部分原因是为了让竞争对手疲于奔命，“has-no-choice-but-to-spend-all-their-time-porting-and-keeping-up-time-that-they-can’t-spend-writing-new-features-”" class="headerlink" title="Fire And Motion- 作者在文中有个观点：大公司不断地技术迭代，有一部分原因是为了让竞争对手疲于奔命，“has no choice but to spend all their time porting and keeping up, time that they can’t spend writing new features.”"></a><a href="https://web.archive.org/web/20060207013551/http://www.joelonsoftware.com/articles/fog0000000339.html">Fire And Motion</a><br>- 作者在文中有个观点：大公司不断地技术迭代，有一部分原因是为了让竞争对手疲于奔命，“has no choice but to spend all their time porting and keeping up, time that they can’t spend writing new features.”</h2><blockquote><p>Maybe as a software developer I really can’t control when I’m productive, and I just have to take the slow times with the fast times and hope that they average out to enough lines of code to make me employable”</p></blockquote></li><li><p><a href="https://sive.rs/pnt">The past is not true</a></p><ul><li>文章还没看，先被这个网站所震撼到。好短，好漂亮。</li><li>读完后让我十分怀念，让我想到以前做的英文阅读题。 差不多相同的结构：故事、作者的感悟。</li><li>里面一句话我觉得值得记录：<blockquote><p>We think of the past like it’s a physical fact - like it’s real. But the past is what we call our memory and stories about it. Imperfect memories, and stories built on one interpretation of incomplete information. That’s “the past”.</p></blockquote></li></ul></li><li><p>[读博第一年总结]</p><ul><li>读博对我来说太遥远，但最后一段我觉得值得记录：<blockquote><p>当然，对于我个人而言最重要的是，相信一切都是能结束的。 之前碰到同学的室友，隔壁专业的，聊如果挂科了，找不到工作，不得不回到国内，被卷进新文革，该怎么办。我说，大不了我还能跳楼，他说，大不了我就趴在泥里，吃草吃土地活下去。屋子内外充满了快活的空气。</p></blockquote><blockquote><p>我想，在现在这样的时代，确实需要一些这样的觉悟，才能活得更轻松一些。</p></blockquote></li><li>我最近偶尔会觉得焦虑，不过找到了一个自己觉得还算不错的排解方法。就是假设最坏的结果发生，然后我就会想，就算是那样我也是不能活，一旦接受了这个可能的最坏结果，我一般就没那么焦虑了。所以看到这段后，我会心一笑。</li></ul></li><li><p><a href="https://vadim.oversigma.com/MAS862/Project.html">Information Processing in Human Body</a><br>人体真奇妙</p></li><li><p><a href="https://writings.sh/post/naming">浅谈编程中的命名（短文） | 春水煎茶 - 王超的个人博客</a></p><ul><li>基本上都认可。第二点我之前有注意到，但一直没有去落实。</li><li>我最近命名的时候喜欢用全称，因为觉得缩写时间久了很容易忘。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">博客和文章的推荐</summary>
    
    
    
    <category term="什锦" scheme="http://euds63.github.io/categories/%E4%BB%80%E9%94%A6/"/>
    
    
    <category term="博客" scheme="http://euds63.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="记录" scheme="http://euds63.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>TinyTinyRSS-OPML-to-MD-Table</title>
    <link href="http://euds63.github.io/2023/TinyTinyRSS-OPML-to-MD-Table/"/>
    <id>http://euds63.github.io/2023/TinyTinyRSS-OPML-to-MD-Table/</id>
    <published>2023-04-28T16:59:40.000Z</published>
    <updated>2023-10-07T05:32:04.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TinyTinyRSS-OPML-to-MD-Table"><a href="#TinyTinyRSS-OPML-to-MD-Table" class="headerlink" title="TinyTinyRSS-OPML-to-MD-Table"></a>TinyTinyRSS-OPML-to-MD-Table</h1><h2 id="需求由来："><a href="#需求由来：" class="headerlink" title="需求由来："></a>需求由来：</h2><p>我很喜欢读博客。但发现总有些很有趣的博客等着发现。所以我关注了些推荐博客的频道。同时，我也想分享些自己喜欢的博客，但每次去手动复制又显得太麻烦了。所以就想着做一个自动化的方式，顺带着也可以学习下Github Action.</p><h2 id="历程"><a href="#历程" class="headerlink" title="历程"></a>历程</h2><ol><li>大部分时间是花在了如何获取opml文件上。Tiny Tiny RSS所给的文档较为精简，而网上相关的资料大都仅局限于如何部署。所以这一段只能是自己摸索。<ul><li>TinyTinyRSS的网页版有给一个按钮能导出OPML，而这个按钮所指向的网址是<code>http://example.com/tt-rss/backend.php?op=opml&amp;method=export&#39;</code>。但它是有个鉴权操作的。需要登录。</li><li>它的示例中有提供了一个登录的api调用，所以我开始的想法也是顺着这个来。想着直接添加data参数。但尝试了多种添加方式无果。</li><li>后来注意到登录成功是会返回session值的，于是先用curl试验了下。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 登录并获取Session ID</span><br>SESSION=$(curl -s -d <span class="hljs-string">&#x27;&#123;&quot;op&quot;:&quot;login&quot;,&quot;user&quot;:&quot;user&quot;,&quot;password&quot;:&quot;password&quot;&#125;&#x27;</span> http://example.com/tt-rss/api/ | python -c <span class="hljs-string">&quot;import sys, json; print(json.load(sys.stdin)[&#x27;content&#x27;][&#x27;session_id&#x27;])&quot;</span>)<br><br><span class="hljs-comment">#获得opml文件</span><br>curl -o my_tiny_tiny_rss.opml <span class="hljs-string">&#x27;http://example.com/tt-rss/backend.php?op=opml&amp;method=export&#x27;</span> --cookie <span class="hljs-string">&quot;ttrss_sid=<span class="hljs-variable">$&#123;SESSION&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure></li><li>转写成python是用的request。其实现在回头想想，这应该是蛮基础的操作，而且session之前也有接触过。如果早点想起来的话是可以少花些时间的。</li></ul></li><li>opml的解析有现成的库，用就是了。</li><li>然后就是把一些个人信息抽出来写在配置文件中。这里踩了一个坑。<code>data = &#123;&#39;op&#39;: &#39;login&#39;, &#39;user&#39;: user, &#39;password&#39;: password&#125;</code>,我开始的时候是这样写的<code>data = f&quot;&#123;&#123;'op': 'login', 'user': &#123;user&#125;, 'password': &#123;password&#125;&#125;&#125;&quot;</code>。后者虽然在形式上看着一样，但前者是json对象，后者是字符串。这里也给我提了个醒：Python虽然有动态类型这个特性，但还是要注意类型错误。</li><li>最后是使用Github Action。之前也有使用过，但是是直接用的别人写好的workflow。所以也花了些时间学习了下。遇到的几个问题是<ul><li>Yml文件的格式问题。这个可以用<a href="https://codebeautify.org/yaml-validator">YAML Validator</a>来检查。Vscode应该也有相应的插件吧。</li><li>运行时需要用到的变量，是用的secret。我之前以为secret的value只能是字符串。但<a href="https://nekokiku.cn/2020/12/22/2020-12-22-Github-Action%E4%B8%ADpython%E8%8E%B7%E5%8F%96%E4%BB%93%E5%BA%93%E7%9A%84secrets/">Github Action中python获取仓库的secrets</a>中提到，可以把一整个yml文件放在value里面。所以我就想那json文件应该也可以。试了下确实能行。这样我的代码需要修改的地方就很少了。</li><li>workflow的触发方式,要添加手动触发，需加上<code>workflow_dispatch:</code></li></ul></li></ol><h2 id="学到的知识"><a href="#学到的知识" class="headerlink" title="学到的知识"></a>学到的知识</h2><ul><li>pipe和python的结合。下面这段是ChatGPT写的，太妙了。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">SESSION=$(curl -s -d <span class="hljs-string">&#x27;&#123;&quot;op&quot;:&quot;login&quot;,&quot;user&quot;:&quot;user&quot;,&quot;password&quot;:&quot;password&quot;&#125;&#x27;</span> http://example.com/tt-rss/api/ | python -c <span class="hljs-string">&quot;import sys, json; print(json.load(sys.stdin)[&#x27;content&#x27;][&#x27;session_id&#x27;])&quot;</span>)<br></code></pre></td></tr></table></figure></li><li>Github Action的使用</li><li>python request</li></ul><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>这个项目算是个很小的项目，但我还是花了半天的时间，而且是在ChatGPT的帮助下。之前看到这样一种说法，搜索引擎大幅降低了普通人获取知识的难度，而ChatGPT在此基础上更是降低了十分客观的一个量。结合自己这次的经历，我十分认同这个观点。通过我对背景的补充和提问，ChatGPT让我省去了花费在各种教程和不完善的文档上所要消费的时间。这比搜索引擎所做到的交互要更自然。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://tt-rss.org/wiki/ApiReference">API Reference</a></li><li><a href="https://www.cnblogs.com/jiangleads/p/10636696.html">curl命令实现上网认证登录</a></li><li><a href="https://nekokiku.cn/2020/12/22/2020-12-22-Github-Action%E4%B8%ADpython%E8%8E%B7%E5%8F%96%E4%BB%93%E5%BA%93%E7%9A%84secrets/">Github Action中python获取仓库的secrets</a></li><li><a href="https://codebeautify.org/yaml-validator">YAML Validator</a></li></ul>]]></content>
    
    
    <summary type="html">记录[EuDs63/TinyTinyRSS-OPML-to-MD-Table](https://github.com/EuDs63/TinyTinyRSS-OPML-to-MD-Table) 的过程</summary>
    
    
    
    <category term="学习" scheme="http://euds63.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="博客" scheme="http://euds63.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="记录" scheme="http://euds63.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="折腾" scheme="http://euds63.github.io/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>扬州慢</title>
    <link href="http://euds63.github.io/2023/Yangzhou-slow/"/>
    <id>http://euds63.github.io/2023/Yangzhou-slow/</id>
    <published>2023-04-26T10:34:32.000Z</published>
    <updated>2023-10-07T05:32:04.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="扬州慢"><a href="#扬州慢" class="headerlink" title="扬州慢"></a>扬州慢</h1><p><strong>黄永玉先生为“入木——黄永玉百岁版画艺术展”所创作的画作。我看了觉得很是喜欢。摘录原文如下</strong></p><p>扬州慢。</p><p>淮左名都，竹西佳处，解鞍少驻初程。过春风十里，尽荠麦青青。自胡马窥江去后，废池乔木，犹厌言兵。渐黄昏，清角吹寒，都在空城。</p><p>杜郎俊赏，算而今，重到须惊。纵豆蔻词工，青楼梦好，难赋深情。二十四桥仍在，波心荡，冷月无声。念桥边红药，年年知为谁生？</p><p>钤印  认识的人越多，我就越喜欢狗（白文方印）</p><p>姜夔先生这阕词，不单评论了杜牧大师，并且还教育了我们一代代后人，也看透了社会的真情，所以我有时用不同的心情来画过它。多少年过去了，我居然也会老到快一百岁，好像还有好多事情还准备做。你看就那么兰约的完蛋，似乎连自己也对不起，好像也没有偷生的办法，好像写一点姜夔式的变文也办不到。（这难道很易？）写这劳骚，也只还不过多写几个字，讨主人的开心。我去过扬州，那是几十又几十年的事，在某个庙门口地摊上买到一部残之又残的傅青主的妇科刻本，回北京老书游子告诉我，傅山这刻本满地都是，不足取，等元宵节，我带你上厂甸要多少有多少。这事跟傅山无关，跟扬州无关，我只是交待一次我去过一回扬州。</p><p>钤印  黄（朱文圆印）</p><p>我还真附庸风雅去找过二十四桥，照姜先生口气，应该不是扬州所有桥的排列顺序，说“仍在”，起码应从杜先生那时候算起。“波心荡，冷月无声”，是姜先生感觉的回应，那桥在哪里呢？有人说在此，有人说在彼，我真跟着他和她们狠狠走了一趟临河的一条小街，几位街坊妇女在做针线，别说二十四桥，北京普通话也听不懂，大家沿河兜头一看，连二十四桥桥基都捉摸不到。唉！世界愚如我的真是不少，对着苍茫，着了多少笔墨，真是不计其数。夔先生自己也着了不少道，他是公认的曲牌的创作名家，好不容易一辈子混了个“乐正”似的官，上午上任，要摆点威武，命令濏官“奏”来听听，出口就错，原来瑟官动手叫“鼓”不叫“奏”，一汇报，马上下台。我仿佛记得以前有段笑话，把立体派、印象派和现代派混在一起演讲，有如把黄人、白人和“人类”混为一起，讲的当时没人敢站出来揭错的，谁都清楚，这是学术“问题”，谁也都清楚，这不是学术“后果”。时间过去近百年，写出来给大家看看，或许当时某位先生还未出世，不相信这事真有其事，说我把谎话当真话讲的，莫怪莫怪！</p><p>钤印  椿子（朱文扁方印）</p><p>大运河博物馆惠存。二〇二三年三月二十七日，黄永玉九十九岁于北京。</p><p>钤印  黄永玉（白文方印）、九五火眼金睛（朱文椭圆印）</p><h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p>提到扬州，我第一印象当属姜夔这阕《扬州慢》。来的路上，我也默诵这阙词。</p><p>荷花，我中学的美术课画过。我画得不好，所以知道不容易画。但百岁高龄，能画出这荷花，写这么多字。我觉得更是不易。</p><p>关于画上的字，我觉得也不错。尤其是内容。我觉得颇有种“从心所欲不逾矩”的感觉。记录几点：</p><ul><li>“不单评论了杜牧大师，并且还教育了我们一代代后人，也看透了社会的真情”。这里我读不出来。应该是阅历未到。</li><li>“我只是交待一次我去过一回扬州。”。很有趣。</li><li>“我还真附庸风雅去找过二十四桥”。本来觉得附庸风雅不是什么好词，但黄先生用来就显得风趣。我也喜欢干类似的事，特意去一些曾在诗中读过的地名走走，哪怕物是人非。</li><li>“唉！世界愚如我的真是不少”。 谦虚</li></ul>]]></content>
    
    
    <summary type="html">黄永玉先生为“入木——黄永玉百岁版画艺术展”所创作的画作。我看了觉得很是喜欢。摘录原文如下，及自己的一些感想。</summary>
    
    
    
    <category term="什锦" scheme="http://euds63.github.io/categories/%E4%BB%80%E9%94%A6/"/>
    
    
    <category term="感想" scheme="http://euds63.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
    <category term="诗词" scheme="http://euds63.github.io/tags/%E8%AF%97%E8%AF%8D/"/>
    
    <category term="出游" scheme="http://euds63.github.io/tags/%E5%87%BA%E6%B8%B8/"/>
    
  </entry>
  
</feed>
