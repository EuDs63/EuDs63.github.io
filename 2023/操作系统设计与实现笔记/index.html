<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>《操作系统：设计与实现》笔记 | EuDs's Blog</title><meta name=keywords content="操作系统,笔记,记录"><meta name=description content="操作系统就是状态机"><meta name=author content="euds63"><link rel=canonical href=https://euds63.github.io/2023/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.min.be037ed91db9b40ac53dc29e76d73dfc6f41c682c03e19f95a9472905dc1395c.css integrity="sha256-vgN+2R25tArFPcKedtc9/G9BxoLAPhn5WpRykF3BOVw=" rel="preload stylesheet" as=style><link rel=icon href=https://euds63.github.io/favicon.ico><link rel=apple-touch-icon href=https://euds63.github.io/apple-touch-icon.png><meta name=twitter:card content="summary"><meta name=twitter:title content="《操作系统：设计与实现》笔记 | EuDs's Blog"><meta name=twitter:description content="操作系统就是状态机"><meta property="og:title" content="《操作系统：设计与实现》笔记 | EuDs's Blog"><meta property="og:description" content="操作系统就是状态机"><meta property="og:type" content="article"><meta property="og:url" content="https://euds63.github.io/2023/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/"><meta property="og:image" content="https://euds63.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-27T18:37:47+08:00"><meta property="article:modified_time" content="2023-06-27T18:37:47+08:00"><meta property="og:site_name" content="EuDs's Blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://euds63.github.io/posts/"},{"@type":"ListItem","position":2,"name":"《操作系统：设计与实现》笔记","item":"https://euds63.github.io/2023/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"《操作系统：设计与实现》笔记 | EuDs's Blog","name":"《操作系统：设计与实现》笔记","description":"操作系统就是状态机","keywords":["操作系统","笔记","记录"],"wordCount":"749","inLanguage":"en","datePublished":"2023-06-27T18:37:47+08:00","dateModified":"2023-06-27T18:37:47+08:00","author":{"@type":"Person","name":"euds63"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://euds63.github.io/2023/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"EuDs's Blog","logo":{"@type":"ImageObject","url":"https://euds63.github.io/favicon.ico"}}}</script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://euds63.github.io/ accesskey=h title="EuDs's Blog (Alt + H)">EuDs's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://euds63.github.io/discover/ title="Discover (Alt + /)" data-no-instant accesskey=/>Discover</a></li><li><a href=https://euds63.github.io/about/ title=about>about</a></li><li><a href=https://euds63.github.io/archives/ title=archives>archives</a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><h1 class=post-title>《操作系统：设计与实现》笔记</h1><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>June 27, 2023</span></span><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://euds63.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a><a href=https://euds63.github.io/tags/%E7%AC%94%E8%AE%B0/>笔记</a><a href=https://euds63.github.io/tags/%E8%AE%B0%E5%BD%95/>记录</a></span></span></div></header><div class="toc side right"><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><ul><li><a href=#p3-%e5%a4%9a%e5%a4%84%e7%90%86%e5%99%a8%e7%bc%96%e7%a8%8b%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e6%94%be%e5%bc%83-%e7%ba%bf%e7%a8%8b%e5%ba%93%e7%8e%b0%e4%bb%a3%e5%a4%84%e7%90%86%e5%99%a8%e5%92%8c%e5%ae%bd%e6%9d%be%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b aria-label="p3 多处理器编程：从入门到放弃 (线程库；现代处理器和宽松内存模型)">p3 多处理器编程：从入门到放弃 (线程库；现代处理器和宽松内存模型)</a></li><li><a href=#p4-%e7%90%86%e8%a7%a3%e5%b9%b6%e5%8f%91%e7%a8%8b%e5%ba%8f%e6%89%a7%e8%a1%8c-peterson%e7%ae%97%e6%b3%95%e6%a8%a1%e5%9e%8b%e6%a3%80%e9%aa%8c%e4%b8%8e%e8%bd%af%e4%bb%b6%e8%87%aa%e5%8a%a8%e5%8c%96%e5%b7%a5%e5%85%b7 aria-label="p4 理解并发程序执行 (Peterson算法、模型检验与软件自动化工具)">p4 理解并发程序执行 (Peterson算法、模型检验与软件自动化工具)</a></li><li><a href=#p5-%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6%e4%ba%92%e6%96%a5-%e8%87%aa%e6%97%8b%e9%94%81%e4%ba%92%e6%96%a5%e9%94%81%e5%92%8c-futex aria-label="p5 并发控制：互斥 (自旋锁、互斥锁和 futex)">p5 并发控制：互斥 (自旋锁、互斥锁和 futex)</a></li></ul><li><a href=#p6-%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6%e5%90%8c%e6%ad%a5-%e6%9d%a1%e4%bb%b6%e5%8f%98%e9%87%8f%e4%bf%a1%e5%8f%b7%e9%87%8f%e7%94%9f%e4%ba%a7%e8%80%85-%e6%b6%88%e8%b4%b9%e8%80%85%e5%92%8c%e5%93%b2%e5%ad%a6%e5%ae%b6%e5%90%83%e9%a5%ad%e9%97%ae%e9%a2%98 aria-label="p6 并发控制：同步 (条件变量、信号量、生产者-消费者和哲♂学家吃饭问题)">p6 并发控制：同步 (条件变量、信号量、生产者-消费者和哲♂学家吃饭问题)</a></li><li><a href=#p7-%e7%9c%9f%e5%ae%9e%e4%b8%96%e7%95%8c%e7%9a%84%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b-%e9%ab%98%e6%80%a7%e8%83%bd%e8%ae%a1%e7%ae%97%e6%95%b0%e6%8d%ae%e4%b8%ad%e5%bf%83%e4%ba%ba%e6%9c%ba%e4%ba%a4%e4%ba%92%e4%b8%ad%e7%9a%84%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b aria-label="p7 真实世界的并发编程 (高性能计算/数据中心/人机交互中的并发编程)">p7 真实世界的并发编程 (高性能计算/数据中心/人机交互中的并发编程)</a></li><li><a href=#p8-%e5%b9%b6%e5%8f%91-bug-%e5%92%8c%e5%ba%94%e5%af%b9-%e6%ad%bb%e9%94%81%e6%95%b0%e6%8d%ae%e7%ab%9e%e4%ba%89%e5%8e%9f%e5%ad%90%e6%80%a7%e8%bf%9d%e5%8f%8d%e9%98%b2%e5%be%a1%e6%80%a7%e7%bc%96%e7%a8%8b%e5%92%8c%e5%8a%a8%e6%80%81%e5%88%86%e6%9e%90 aria-label="p8 并发 bug 和应对 (死锁/数据竞争/原子性违反；防御性编程和动态分析)">p8 并发 bug 和应对 (死锁/数据竞争/原子性违反；防御性编程和动态分析)</a></li><li><a href=#p9-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9a%84%e7%8a%b6%e6%80%81%e6%9c%ba%e6%a8%a1%e5%9e%8b-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%8a%a0%e8%bd%bd-thread-os-%e4%bb%a3%e7%a0%81%e8%ae%b2%e8%a7%a3 aria-label="p9 操作系统的状态机模型 (操作系统的加载; thread-os 代码讲解)">p9 操作系统的状态机模型 (操作系统的加载; thread-os 代码讲解)</a></li><li><a href=#p10-%e7%8a%b6%e6%80%81%e6%9c%ba%e6%a8%a1%e5%9e%8b%e7%9a%84%e5%ba%94%e7%94%a8-%e7%bb%86%e8%83%9e%e8%87%aa%e5%8a%a8%e6%9c%ba-gdbrrperf-%e4%bb%a3%e7%a0%81%e9%aa%8c%e8%af%81%e5%b7%a5%e5%85%b7 aria-label="p10 状态机模型的应用 (细胞自动机; gdb/rr/perf; 代码验证工具)">p10 状态机模型的应用 (细胞自动机; gdb/rr/perf; 代码验证工具)</a></li><li><a href=#p11-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e4%b8%8a%e7%9a%84%e8%bf%9b%e7%a8%8b-%e6%9c%80%e5%b0%8f-linux-fork-execve-%e5%92%8c-exit aria-label="p11 操作系统上的进程 (最小 Linux; fork, execve 和 exit)">p11 操作系统上的进程 (最小 Linux; fork, execve 和 exit)</a></li><li><a href=#p12-%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4-pmap-vdso-mmap-%e6%b8%b8%e6%88%8f%e4%bf%ae%e6%94%b9%e5%99%a8%e5%a4%96%e6%8c%82 aria-label="p12 进程的地址空间 (pmap; vdso; mmap; 游戏修改器/外挂)">p12 进程的地址空间 (pmap; vdso; mmap; 游戏修改器/外挂)</a></li><li><a href=#p13-%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e5%92%8c-shell-freestanding-shell-%e7%bb%88%e7%ab%af%e5%92%8c-job-control aria-label="p13 系统调用和 Shell (freestanding shell, 终端和 job control)">p13 系统调用和 Shell (freestanding shell, 终端和 job control)</a></li><li><a href=#p14-c-%e6%a0%87%e5%87%86%e5%ba%93%e7%9a%84%e5%ae%9e%e7%8e%b0-%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e7%9a%84%e5%b0%81%e8%a3%85%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%e7%ae%a1%e7%90%86 aria-label="p14 C 标准库的实现 (系统调用的封装；内存空间管理)">p14 C 标准库的实现 (系统调用的封装；内存空间管理)</a></li><li><a href=#p15-fork-%e7%9a%84%e5%ba%94%e7%94%a8-%e6%96%87%e4%bb%b6%e6%8f%8f%e8%bf%b0%e7%ac%a6%e7%9a%84%e5%a4%8d%e5%88%b6%e5%86%99%e6%97%b6%e5%a4%8d%e5%88%b6%e5%88%9b%e5%bb%ba%e5%b9%b3%e8%a1%8c%e5%ae%87%e5%ae%99%e7%9a%84%e9%ad%94%e6%b3%95 aria-label="p15 fork 的应用 (文件描述符的复制；写时复制；创建平行宇宙的魔法)">p15 fork 的应用 (文件描述符的复制；写时复制；创建平行宇宙的魔法)</a></li><li><a href=#p16-%e4%bb%80%e4%b9%88%e6%98%af%e5%8f%af%e6%89%a7%e8%a1%8c%e6%96%87%e4%bb%b6-%e8%b0%83%e8%af%95%e4%bf%a1%e6%81%afstack-unwinding%e9%9d%99%e6%80%81%e9%93%be%e6%8e%a5%e4%b8%ad%e7%9a%84%e9%87%8d%e5%ae%9a%e4%bd%8d aria-label="p16 什么是可执行文件 (调试信息；Stack Unwinding；静态链接中的重定位)">p16 什么是可执行文件 (调试信息；Stack Unwinding；静态链接中的重定位)</a></li><li><a href=#p17-%e5%8a%a8%e6%80%81%e9%93%be%e6%8e%a5%e5%92%8c%e5%8a%a0%e8%bd%bd-%e9%9d%99%e6%80%81-elf-%e5%8a%a0%e8%bd%bd%e5%99%a8%e5%ae%9e%e7%8e%b0%e8%b0%83%e8%af%95-linux-%e5%86%85%e6%a0%b8%e5%8a%a8%e6%80%81%e9%93%be%e6%8e%a5%e5%92%8c%e5%8a%a0%e8%bd%bd aria-label="p17 动态链接和加载 (静态 ELF 加载器实现；调试 Linux 内核；动态链接和加载)">p17 动态链接和加载 (静态 ELF 加载器实现；调试 Linux 内核；动态链接和加载)</a></li><li><a href=#p23-1-bit-%e6%95%b0%e6%8d%ae%e7%9a%84%e5%ad%98%e5%82%a8-%e5%bb%b6%e8%bf%9f%e7%ba%bf%e7%a3%81%e8%8a%afdramsram%e7%a3%81%e5%b8%a6%e7%a3%81%e7%9b%98%e5%85%89%e7%9b%98flash-ssd aria-label="p23 1-Bit 数据的存储 (延迟线/磁芯/DRAM/SRAM/磁带/磁盘/光盘/Flash SSD)">p23 1-Bit 数据的存储 (延迟线/磁芯/DRAM/SRAM/磁带/磁盘/光盘/Flash SSD)</a></li><li><a href=#p24-%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba%e8%ae%be%e5%a4%87%e6%a8%a1%e5%9e%8b-%e4%b8%b2%e5%8f%a3%e9%94%ae%e7%9b%98%e7%a3%81%e7%9b%98%e6%89%93%e5%8d%b0%e6%9c%ba%e6%80%bb%e7%ba%bf%e4%b8%ad%e6%96%ad%e6%8e%a7%e5%88%b6%e5%99%a8dma-%e5%92%8c-gpu aria-label="p24 输入输出设备模型 (串口/键盘/磁盘/打印机/总线/中断控制器/DMA 和 GPU">p24 输入输出设备模型 (串口/键盘/磁盘/打印机/总线/中断控制器/DMA 和 GPU</a></li><li><a href=#p25-%e8%ae%be%e5%a4%87%e9%a9%b1%e5%8a%a8%e7%a8%8b%e5%ba%8f-linux-%e8%ae%be%e5%a4%87%e9%a9%b1%e5%8a%a8-gpu-%e5%92%8c-cuda-%e5%ad%98%e5%82%a8%e8%ae%be%e5%a4%87%e6%8a%bd%e8%b1%a1 aria-label="p25 设备驱动程序 (Linux 设备驱动; GPU 和 CUDA; 存储设备抽象)">p25 设备驱动程序 (Linux 设备驱动; GPU 和 CUDA; 存储设备抽象)</a></li><li><a href=#p26-%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f-api-%e8%ae%be%e5%a4%87%e5%9c%a8%e5%ba%94%e7%94%a8%e9%97%b4%e7%9a%84%e5%85%b1%e4%ba%ab%e7%9b%ae%e5%bd%95%e5%92%8c%e6%96%87%e4%bb%b6-api aria-label="p26 文件系统 API (设备在应用间的共享；目录和文件 API)">p26 文件系统 API (设备在应用间的共享；目录和文件 API)</a></li><li><a href=#p27-fat-%e5%92%8c-unix-%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e8%a7%86%e8%a7%92%e7%9a%84%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f-fat-%e6%89%8b%e5%86%8c%e5%af%bc%e8%af%bb%e5%92%8c%e7%9b%ae%e5%bd%95%e6%a0%91%e9%81%8d%e5%8e%86 aria-label="p27 FAT 和 UNIX 文件系统 (数据结构视角的文件系统; FAT 手册导读和目录树遍历)">p27 FAT 和 UNIX 文件系统 (数据结构视角的文件系统; FAT 手册导读和目录树遍历)</a></li><li><a href=#p28-%e6%8c%81%e4%b9%85%e6%95%b0%e6%8d%ae%e7%9a%84%e5%8f%af%e9%9d%a0%e6%80%a7-raid-%e5%b4%a9%e6%ba%83%e4%b8%80%e8%87%b4%e6%80%a7-fsck-%e5%92%8c%e6%97%a5%e5%bf%97 aria-label="p28 持久数据的可靠性 (RAID; 崩溃一致性; FSCK 和日志)">p28 持久数据的可靠性 (RAID; 崩溃一致性; FSCK 和日志)</a></li><li><a href=#p30-%e7%8e%b0%e4%bb%a3%e5%ad%98%e5%82%a8%e7%b3%bb%e7%bb%9f-%e5%85%b3%e7%b3%bb%e6%95%b0%e6%8d%ae%e5%ba%93%e5%92%8c%e5%88%86%e5%b8%83%e5%bc%8f%e5%ad%98%e5%82%a8%e7%b3%bb%e7%bb%9f aria-label="p30 现代存储系统 (关系数据库和分布式存储系统)">p30 现代存储系统 (关系数据库和分布式存储系统)</a></li><li><a href=#%e6%84%9f%e6%83%b3 aria-label=感想>感想</a></li><li><a href=#%e6%94%b6%e8%8e%b7 aria-label=收获>收获</a></li><li><a href=#%e8%af%be%e5%a4%96%e8%b5%84%e6%96%99 aria-label=课外资料>课外资料</a></li></ul></div></details></div><div class=post-content><p><strong><a href="https://space.bilibili.com/202224425/channel/collectiondetail?sid=192498" target=_blank rel=noopener>操作系统：设计与实现 (2022 春季学期)</a>的学习笔记</strong></p><h3 id=p3-多处理器编程从入门到放弃-线程库现代处理器和宽松内存模型>p3 多处理器编程：从入门到放弃 (线程库；现代处理器和宽松内存模型)<a hidden class=anchor aria-hidden=true href=#p3-多处理器编程从入门到放弃-线程库现代处理器和宽松内存模型>¶</a></h3><ul><li><p>并发程序的三个麻烦</p><ul><li>原子性</li><li>顺序</li><li>可见性</li></ul></li><li><p>gcc 编译</p><ul><li>不优化,并查看汇编代码
<code>gcc -c -O1 sum.c && objdump -d sum.o</code></li><li><code>asm volatile("" : : "memory"); // compiler barrier</code></li></ul></li><li><p>统计次数
<code>./a.out | head -n 1000 | sort | uniq -c</code></p></li><li><p>现代处理器</p><ul><li>也是动态编译器：汇编指令也是由多个uop所组成的。</li><li>维护一个uop的“池子” 指令的有向无环图</li><li>乱序执行，顺序提交</li></ul></li></ul><h3 id=p4-理解并发程序执行-peterson算法模型检验与软件自动化工具>p4 理解并发程序执行 (Peterson算法、模型检验与软件自动化工具)<a hidden class=anchor aria-hidden=true href=#p4-理解并发程序执行-peterson算法模型检验与软件自动化工具>¶</a></h3><ul><li>C语言的形式语义<ul><li>全局变量加多个栈帧；每个栈帧有其局部变量和pc</li></ul></li><li>Peterson算法<ul><li>看上去是谦让的，但其实是自私的</li><li>证明正确性：画出状态机<ul><li>困境：不敢不画，不敢乱画</li><li>解决： <a href=https://jyywiki.cn/pages/OS/2022/demos/model-checker.py target=_blank rel=noopener>model-checker</a></li><li>把程序的问题变成图论的问题<ul><li>safety 红色状态不可达</li><li>liveness : 从任意状态出发，都能到达绿/蓝色状态 强连通分量</li></ul></li></ul></li><li>许多重要的想法，凝练以后就是概念</li></ul></li><li>并发程序 = 状态机</li><li>Python generator<ul><li>e.g.<div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>numbers</span><span class=p>(</span><span class=n>init</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span><span class=n>step</span><span class=o>=</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=n>init</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>Trye</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>+=</span> <span class=n>step</span>
</span></span><span class=line><span class=cl>    <span class=k>yield</span> <span class=n>n</span>
</span></span><span class=line><span class=cl><span class=n>g</span> <span class=o>=</span> <span class=n>numbers</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>g</span><span class=o>.</span><span class=fm>__next__</span><span class=p>()</span>
</span></span></code></pre></div></li></ul></li></ul><h3 id=p5-并发控制互斥-自旋锁互斥锁和-futex>p5 并发控制：互斥 (自旋锁、互斥锁和 futex)<a hidden class=anchor aria-hidden=true href=#p5-并发控制互斥-自旋锁互斥锁和-futex>¶</a></h3><ul><li>不能解决问题的时候，可以找到所依赖的假设，并大胆地打破它</li><li>spin 线程直接共享 locked</li><li>mutex 通过系统调用访问 locked</li><li>futex(Fast Userspace muTexes)<ul><li>Fast path: 一条原子指令，上锁成功立即返回</li><li>Slow path: 上锁失败，执行系统调用睡眠</li></ul></li></ul><h2 id=p6-并发控制同步-条件变量信号量生产者-消费者和哲学家吃饭问题>p6 并发控制：同步 (条件变量、信号量、生产者-消费者和哲♂学家吃饭问题)<a hidden class=anchor aria-hidden=true href=#p6-并发控制同步-条件变量信号量生产者-消费者和哲学家吃饭问题>¶</a></h2><ul><li>思考： 有一堆任务，平均切分成n堆。有x个线程负责完成该任务(x &lt; n) 一个线程一次只能完成一个任务，完成后会自动去做下一个任务。要怎么实现？</li><li>有万能的方法，就要用万能的方法。<ul><li>他是这样诠释的。当项目代码量不大（一千行以内），项目还是比较好维护的，这时候用写聪明的写法没问题。但当项目到了几万行甚至几百万行时，这时候就需要多个人来进行协作。而人和人之间最大的障碍就是无法完全沟通，理解对方的心意。</li><li>不要试图用聪明的办法解决并发问题</li><li>个人想法：第一次听这种说法，有一定道理。</li></ul></li><li>万能同步方法 —— 条件变量(Conditional Variables )<ul><li>API<ul><li>wait(cv, mutex) 💤
调用时必须保证已经获得 mutex
释放 mutex、进入睡眠状态</li><li>signal/notify(cv) 💬 私信：走起
如果有线程正在等待 cv，则唤醒其中一个线程</li><li>broadcast/notifyAll(cv) 📣 所有人：走起
唤醒全部正在等待 cv 的线程</li></ul></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 需要等待条件满足时
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>cond</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cv</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nf>assert</span><span class=p>(</span><span class=n>cond</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1>// 互斥锁保证了在此期间条件 cond 总是成立
</span></span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 其他线程条件可能被满足时
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>broadcast</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cv</span><span class=p>);</span>
</span></span></code></pre></div></li><li>debug -> 隔离出bug触发的最小条件</li></ul></li></ul><h2 id=p7-真实世界的并发编程-高性能计算数据中心人机交互中的并发编程>p7 真实世界的并发编程 (高性能计算/数据中心/人机交互中的并发编程)<a hidden class=anchor aria-hidden=true href=#p7-真实世界的并发编程-高性能计算数据中心人机交互中的并发编程>¶</a></h2><ul><li>谈block chain > 是个很好的技术。但觉得不太对。因为造成了相当大的资源浪费。</li><li><a href="https://www.youtube.com/watch?v=FFftmWSzgmk&amp;ab_channel=Numberphile" target=_blank rel=noopener>What&rsquo;s so special about the Mandelbrot Set? - Numberphile</a></li><li><a href=https://github.com/atanunq/viu target=_blank rel=noopener>atanunq/viu</a></li><li>搜索降低了知识的获取成本，ChatGPT等再一次降低了成本。</li><li>go语言，编程友好、性能优化</li><li>博客是web2.0 的第一步</li><li>Ajax (Asynchronous JavaScript + XML)</li><li>这次课中讲了三种并发编程，根据不同的需要，实现并发的方式也不同。</li></ul><h2 id=p8-并发-bug-和应对-死锁数据竞争原子性违反防御性编程和动态分析>p8 并发 bug 和应对 (死锁/数据竞争/原子性违反；防御性编程和动态分析)<a hidden class=anchor aria-hidden=true href=#p8-并发-bug-和应对-死锁数据竞争原子性违反防御性编程和动态分析>¶</a></h2><ul><li>软件是需求在计算机数字世界的投影。</li><li>assert的使用</li><li>没有工具不做系统</li><li>premature optimization is root of all evil</li><li>编程语言的缺陷——对程序员的完全信任：因为计算资源的宝贵</li><li>动态分析工具 <code>-fsanitize</code></li><li>Canary msvc 中 debug mode 的canary <code>(b'\xcc' * 80).decode('gb2312')</code></li></ul><h2 id=p9-操作系统的状态机模型-操作系统的加载-thread-os-代码讲解>p9 操作系统的状态机模型 (操作系统的加载; thread-os 代码讲解)<a hidden class=anchor aria-hidden=true href=#p9-操作系统的状态机模型-操作系统的加载-thread-os-代码讲解>¶</a></h2><ul><li>大学的真正意义:f将已有的知识和方法重新消化，为大家建立好 “台阶”，在有限的时间里迅速赶上数十年来建立起的学科体系。</li></ul><h2 id=p10-状态机模型的应用-细胞自动机-gdbrrperf-代码验证工具>p10 状态机模型的应用 (细胞自动机; gdb/rr/perf; 代码验证工具)<a hidden class=anchor aria-hidden=true href=#p10-状态机模型的应用-细胞自动机-gdbrrperf-代码验证工具>¶</a></h2><ul><li>分布式系统也是一种并发程序，但要更复杂。因为并发程序假设了每个thread都能正常运行，而分布式系统则要考虑节点丢失的情况。</li></ul><h2 id=p11-操作系统上的进程-最小-linux-fork-execve-和-exit>p11 操作系统上的进程 (最小 Linux; fork, execve 和 exit)<a hidden class=anchor aria-hidden=true href=#p11-操作系统上的进程-最小-linux-fork-execve-和-exit>¶</a></h2><ul><li>Linux 操作系统启动流程
CPU Reset → Firmware → Loader → Kernel _start() → 第一个程序 /bin/init → 程序 (状态机) 执行 + 系统调用</li><li>Fork Bomb:
<code>:(){:|:&};:</code><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>:<span class=o>()</span> <span class=o>{</span>         <span class=c1># 格式化一下</span>
</span></span><span class=line><span class=cl>: <span class=p>|</span> : <span class=p>&amp;</span>
</span></span><span class=line><span class=cl><span class=o>}</span><span class=p>;</span> :
</span></span></code></pre></div></li><li>stdout:
终端: line buffer
pipe , file :full buffer (除非显示地调用fflush)<pre tabindex=0><code></code></pre></li><li><strong>fork</strong><ul><li>程序就是状态机，正在执行的程序也是状态机，fork创建状态机的副本；</li><li>创建的进程返回+1，子进程返回为0</li><li>把所有的寄存器和内存都复制</li></ul></li><li><strong>execve</strong><ul><li>将当前运行的状态机重置成成另一个程序的初始状态</li></ul></li><li><strong>_exit</strong></li></ul><h2 id=p12-进程的地址空间-pmap-vdso-mmap-游戏修改器外挂>p12 进程的地址空间 (pmap; vdso; mmap; 游戏修改器/外挂)<a hidden class=anchor aria-hidden=true href=#p12-进程的地址空间-pmap-vdso-mmap-游戏修改器外挂>¶</a></h2><ul><li>端序<ul><li>大端 (big endian): 低地址存放<em>高</em>有效字节</li><li>小端 (little endian): 低字节存放<em>低</em>有效字节</li></ul></li><li>工具使用<ul><li>gdb</li><li>readelf</li><li>pmap</li></ul></li><li>计算机世界没有魔法。因为程序就是状态机。</li><li>vdso:不进入操作系统内核，实现系统调用</li><li>mmap：</li><li>文件=字节序列；内存=字节序列； everything is a file</li></ul><h2 id=p13-系统调用和-shell-freestanding-shell-终端和-job-control>p13 系统调用和 Shell (freestanding shell, 终端和 job control)<a hidden class=anchor aria-hidden=true href=#p13-系统调用和-shell-freestanding-shell-终端和-job-control>¶</a></h2><ul><li>cd是内部命令：改变当前目录是用系统调用实现的</li><li><code>strace -f gcc a.c 2>&amp;1 | vim -</code> This will pipe both stdout and stderr to vim. The <code>-</code> argument tells vim to read from stdin.</li><li><code>strace pmap 152 |& vim -</code>
<code>|&</code> : This is a shorthand for <code>2>&amp;1 |</code> in bash and zsh. It passes both standard output and standard error of one command as input to another.</li><li>fish, zsh 和 bash 都是常用的命令行 shell; sh是比较原始的</li><li>clear 清屏</li><li><code>,./a.out &</code> 后台执行./a.out</li></ul><h2 id=p14-c-标准库的实现-系统调用的封装内存空间管理>p14 C 标准库的实现 (系统调用的封装；内存空间管理)<a hidden class=anchor aria-hidden=true href=#p14-c-标准库的实现-系统调用的封装内存空间管理>¶</a></h2><ul><li>文件描述符还是不理解。印象中这是第二次谈到了"everything is a file"<ul><li>os的对象和对象的访问</li></ul></li><li>gdn的使用<ul><li><code>No symbol table is loaded. Use the "file" command</code>。可能是编译选项未包含debug信息,如gcc没有添加-g选项。</li></ul></li><li>premature optimization is the root of all evil.</li><li>脱离workload谈优化就是耍流氓</li><li>经典的设计：<ul><li>fast path</li><li>slow path</li></ul></li></ul><h2 id=p15-fork-的应用-文件描述符的复制写时复制创建平行宇宙的魔法>p15 fork 的应用 (文件描述符的复制；写时复制；创建平行宇宙的魔法)<a hidden class=anchor aria-hidden=true href=#p15-fork-的应用-文件描述符的复制写时复制创建平行宇宙的魔法>¶</a></h2><ul><li>fork 状态机复制包括持有的所有操作系统对象</li><li>包括持有的所有操作系统对象</li><li>文件描述符（file discriptor）<ul><li>一个指向操作系统内对象的 “指针”</li><li>dup() 的两个文件描述符是共享 offset</li></ul></li><li>访问空指针也会造成缺页中断</li><li>“Copy-on-write” 只有被写入的页面才会复制一份<ul><li>被复制后，整个地址空间都被标记为 “只读”</li><li>操作系统捕获 Page Fault 后酌情复制页面</li><li>fork-execve 效率得到提升</li></ul></li><li>操作系统会维护每个页面的引用计数</li><li>定义进程所占用的内存</li><li>page是归os所有的，而非进程</li><li>使用fork来搜索并行化。</li></ul><h2 id=p16-什么是可执行文件-调试信息stack-unwinding静态链接中的重定位>p16 什么是可执行文件 (调试信息；Stack Unwinding；静态链接中的重定位)<a hidden class=anchor aria-hidden=true href=#p16-什么是可执行文件-调试信息stack-unwinding静态链接中的重定位>¶</a></h2><ul><li>可执行文件描述了状态机，是一个描述了状态机的初始状态 + 迁移的数据结构</li><li>os没有魔法，所有东西都有解释</li><li><code>She-bang</code> <code>#! interpreter [optional-arg]</code></li><li>GNU binutils<ul><li>生成可执行文件<ul><li>ld (linker), as (assembler)</li><li>ar, ranlib</li></ul></li><li>分析可执行文件<ul><li>objcopy/objdump/readelf</li><li>addr2line, size, nm</li></ul></li></ul></li><li><code>objdump -d a.out | less</code> disasm</li><li><code>addr2line 401122 a.out</code></li><li>elf: 小精灵；dwarf：矮人</li><li>将一个 assembly (机器) 状态映射到 “C 世界” 状态很难</li><li>gcc等仍存在着许多不完美</li><li>编译器，汇编器，链接器</li></ul><h2 id=p17-动态链接和加载-静态-elf-加载器实现调试-linux-内核动态链接和加载>p17 动态链接和加载 (静态 ELF 加载器实现；调试 Linux 内核；动态链接和加载)<a hidden class=anchor aria-hidden=true href=#p17-动态链接和加载-静态-elf-加载器实现调试-linux-内核动态链接和加载>¶</a></h2><ul><li>自定义了一个二进制格式文件</li><li>GOT ： global offset table</li><li>PLT : procedure linkage table</li></ul><h2 id=p23-1-bit-数据的存储-延迟线磁芯dramsram磁带磁盘光盘flash-ssd>p23 1-Bit 数据的存储 (延迟线/磁芯/DRAM/SRAM/磁带/磁盘/光盘/Flash SSD)<a hidden class=anchor aria-hidden=true href=#p23-1-bit-数据的存储-延迟线磁芯dramsram磁带磁盘光盘flash-ssd>¶</a></h2><ul><li>volatile: 确保该变量的实际值与内存中的值一致,每次读取都是最新值,也禁止编译器对其进行优化。</li><li>core dumped 磁性内存年代开始的概念。</li><li>局部性原理 -> 可以按照大块来读写</li></ul><h2 id=p24-输入输出设备模型-串口键盘磁盘打印机总线中断控制器dma-和-gpu>p24 输入输出设备模型 (串口/键盘/磁盘/打印机/总线/中断控制器/DMA 和 GPU<a hidden class=anchor aria-hidden=true href=#p24-输入输出设备模型-串口键盘磁盘打印机总线中断控制器dma-和-gpu>¶</a></h2><ul><li>DMA: direct memory access : 一个专门执行"memcpy"程序的cpu</li><li>IPC: Instruction per second</li><li>GPU:<ul><li>一个通用计算设备</li><li>大量并行相似的任务</li></ul></li><li>异构计算：都能做，但选那个最合适的。（jjy在22年说的现在已经能感觉到有相关的趋势了。不过倒不是里面举例的挖矿，而是llm模型）</li></ul><h2 id=p25-设备驱动程序-linux-设备驱动-gpu-和-cuda-存储设备抽象>p25 设备驱动程序 (Linux 设备驱动; GPU 和 CUDA; 存储设备抽象)<a hidden class=anchor aria-hidden=true href=#p25-设备驱动程序-linux-设备驱动-gpu-和-cuda-存储设备抽象>¶</a></h2><ul><li>设备抽象成 支持各类操作的对象 (文件)<ul><li>read - 从设备某个指定的位置读出数据</li><li>write - 向设备某个指定位置写入数据</li><li>ioctl - 读取/设置设备的状态</li></ul></li><li><code>stty -a</code></li><li>GPU<ul><li>Single Instruction, Multiple Thread</li></ul></li><li>读优先的正确性</li></ul><h2 id=p26-文件系统-api-设备在应用间的共享目录和文件-api>p26 文件系统 API (设备在应用间的共享；目录和文件 API)<a hidden class=anchor aria-hidden=true href=#p26-文件系统-api-设备在应用间的共享目录和文件-api>¶</a></h2><ul><li>信息的局部性</li><li>Windows从c盘开始时是受其前身Dos系统的影响，那个有a、b</li><li><code>mount disk.img /mnt</code></li><li><code>umount /mnt</code></li><li>硬（hard）链接<ul><li><code>ln /usr/local/python3 python</code></li><li>目录中仅存储指向文件数据的指针</li><li>允许一个文件被多个目录引用.</li><li>无法用来链接目录，也不能跨文件系统</li><li>通过<code>ls -i</code>查看是否为硬链接</li></ul></li><li>软 (symbolic) 链接<ul><li>“快捷方式”</li><li><code>ln -s ../p24 p24</code></li><li>目录从“树”变为了“图”，还是有环图</li></ul></li><li><code>cd</code>的特殊性<ul><li>每个进程都有一个对应的工作目录（pwd），而这个目录只有系统调用才能够修改</li></ul></li></ul><h2 id=p27-fat-和-unix-文件系统-数据结构视角的文件系统-fat-手册导读和目录树遍历>p27 FAT 和 UNIX 文件系统 (数据结构视角的文件系统; FAT 手册导读和目录树遍历)<a hidden class=anchor aria-hidden=true href=#p27-fat-和-unix-文件系统-数据结构视角的文件系统-fat-手册导读和目录树遍历>¶</a></h2><ul><li>数据结构的假设：数据是以字节来存储的。</li><li>RAM 和 block的区别</li><li>FAT(File Allocation Table)<ul><li>将指针集中存放在文件系统的某个区域</li><li>适合小文件</li><li>会产生碎片（fragmentation）</li><li>基本假设<ul><li>链表无环且长度和文件大小一致</li><li>FREE的cluster不能有入边</li></ul></li></ul></li><li>cluster</li><li>sector</li><li>ext2<ul><li>大文件的随机读写性能提升明显 (O(1))</li><li>支持链接 (一定程度减少空间浪费)</li><li>inode 在磁盘上连续存储，便于缓存/预取</li><li>碎片</li></ul></li></ul><h2 id=p28-持久数据的可靠性-raid-崩溃一致性-fsck-和日志>p28 持久数据的可靠性 (RAID; 崩溃一致性; FSCK 和日志)<a hidden class=anchor aria-hidden=true href=#p28-持久数据的可靠性-raid-崩溃一致性-fsck-和日志>¶</a></h2><ul><li>虚拟化<ul><li>cpu的虚拟化：通过分时等技术让多个进程并行，相当于虚拟出了多个cpu</li><li>内存的虚拟化：一份内存通过mmu，虚拟成每个进程的地址空间</li><li>RAID：反向的虚拟化：多个磁盘虚拟化一个磁盘</li></ul></li><li>RAID<ul><li>RAID0 : 交错排列： 提升容量和带宽</li><li>RAID1 : 提升容错和读带宽</li><li>RAID4 : 额外的一块校验盘<ul><li>致命缺陷：随机写的性能只能有校验盘性能的一半</li></ul></li><li>RAID5 : Rotating Parity</li></ul></li><li>RAID带来的联想：
多个磁盘虚拟化为一个又大又快又可靠的磁盘，多台电脑虚拟化为一个又大又快又可靠的电脑
那能不能多个神经网络虚拟化为一个更好的神经网络</li><li>崩溃一致性 (Crash Consistency)<ul><li>场景：写入的时候突然断电了怎么办？</li><li>方法1：按照一定顺序来写，且 “all or nothing”<ul><li>困难：磁盘不提供多块读写 “all or nothing” 的支持，甚至为了性能，没有顺序保证。</li></ul></li><li>方法2： File System Checking (FSCK)<ul><li>根据磁盘上已有的信息，恢复出 “最可能” 的数据结构</li><li>困难：难；如果修复的时候再掉一次电？</li></ul></li><li>方法3： 日志</li><li>具体：<ul><li>数据结构操作发生时，用 (2) append-only 记录日志</li><li>日志落盘后，用 (1) 更新数据结构</li><li>崩溃后，重放日志并清除 (称为 redo log；相应也可以 undo log)</li></ul></li><li>优化: journaling (jdb2)</li></ul></li></ul><h2 id=p30-现代存储系统-关系数据库和分布式存储系统>p30 现代存储系统 (关系数据库和分布式存储系统)<a hidden class=anchor aria-hidden=true href=#p30-现代存储系统-关系数据库和分布式存储系统>¶</a></h2><ul><li>数据库<ul><li>关键<ul><li>索引</li><li>查询优化</li></ul></li><li>magic：你只管写sql语句，相应的搜索优化它来做</li><li>要求：acid<ul><li>Atoming</li><li>Consistency</li><li>Isolation</li><li>Durability</li></ul></li></ul></li><li>图灵奖<ul><li>这门课听下来，听到了好多知识点背后都是获得过图灵奖的研究，甚至开创了一整个产业。</li></ul></li><li>关系型数据库跟不上社交网络的需求</li><li>cap theorem<ul><li>Consistency</li><li>Availability</li><li>Partition Tolerance</li></ul></li><li>分布式存储系统</li></ul><h2 id=感想>感想<a hidden class=anchor aria-hidden=true href=#感想>¶</a></h2><p>蒋炎炎这门课还是别人推荐的。第一次看到还不以为意，但出现的次数多了就觉得有必要去看看。发现是一大惊喜。</p><h2 id=收获>收获<a hidden class=anchor aria-hidden=true href=#收获>¶</a></h2><ol><li>原版书能看得下来了。大段的英文，之前看着有点怕，现在觉得也能看下来，并且速度还可以。</li></ol><h2 id=课外资料>课外资料<a hidden class=anchor aria-hidden=true href=#课外资料>¶</a></h2><ul><li><a href=https://plantegg.github.io/2022/06/05/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E5%BC%80%E9%94%80/ target=_blank rel=noopener>上下文切换的代价</a></li><li><a href=https://plantegg.github.io/2021/06/01/CPU%E7%9A%84%E5%88%B6%E9%80%A0%E5%92%8C%E6%A6%82%E5%BF%B5/ target=_blank rel=noopener>CPU的制造和概念</a></li></ul></div><footer class=post-footer><nav class=paginav><a class=prev href=https://euds63.github.io/2023/rust_learning/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></svg>&nbsp;</span><br><span>Rust_Learning</span></a>
<a class=next href=https://euds63.github.io/2023/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/><span class=title>&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span><br><span>操作系统复习笔记</span></a></nav></footer><div class=comments-separator></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://euds63.github.io/>EuDs's Blog</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a></span>
<span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n=""=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script>
<script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a="1"=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script></body></html>