<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>操作系统复习笔记 | EuDs's Blog</title><meta name=keywords content="笔记,操作系统"><meta name=description content="操作系统复习笔记"><meta name=author content="euds63"><link rel=canonical href=https://euds63.github.io/2023/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.min.be037ed91db9b40ac53dc29e76d73dfc6f41c682c03e19f95a9472905dc1395c.css integrity="sha256-vgN+2R25tArFPcKedtc9/G9BxoLAPhn5WpRykF3BOVw=" rel="preload stylesheet" as=style><link rel=icon href=https://euds63.github.io/favicon.ico><link rel=apple-touch-icon href=https://euds63.github.io/apple-touch-icon.png><meta name=twitter:card content="summary"><meta name=twitter:title content="操作系统复习笔记 | EuDs's Blog"><meta name=twitter:description content="操作系统复习笔记"><meta property="og:title" content="操作系统复习笔记 | EuDs's Blog"><meta property="og:description" content="操作系统复习笔记"><meta property="og:type" content="article"><meta property="og:url" content="https://euds63.github.io/2023/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"><meta property="og:image" content="https://euds63.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-19T18:35:11+08:00"><meta property="article:modified_time" content="2023-06-19T18:35:11+08:00"><meta property="og:site_name" content="EuDs's Blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://euds63.github.io/posts/"},{"@type":"ListItem","position":2,"name":"操作系统复习笔记","item":"https://euds63.github.io/2023/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"操作系统复习笔记 | EuDs's Blog","name":"操作系统复习笔记","description":"操作系统复习笔记","keywords":["笔记","操作系统"],"wordCount":"3210","inLanguage":"en","datePublished":"2023-06-19T18:35:11+08:00","dateModified":"2023-06-19T18:35:11+08:00","author":{"@type":"Person","name":"euds63"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://euds63.github.io/2023/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"EuDs's Blog","logo":{"@type":"ImageObject","url":"https://euds63.github.io/favicon.ico"}}}</script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://euds63.github.io/ accesskey=h title="EuDs's Blog (Alt + H)">EuDs's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://euds63.github.io/discover/ title="Discover (Alt + /)" data-no-instant accesskey=/>Discover</a></li><li><a href=https://euds63.github.io/about/ title=about>about</a></li><li><a href=https://euds63.github.io/archives/ title=archives>archives</a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><h1 class=post-title>操作系统复习笔记</h1><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>June 19, 2023</span></span><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://euds63.github.io/tags/%E7%AC%94%E8%AE%B0/>笔记</a><a href=https://euds63.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a></span></span></div></header><div class="toc side right"><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%9c%9f%e6%9c%ab%e5%a4%8d%e4%b9%a0 aria-label=期末复习>期末复习</a><ul><li><a href=#chpter-3-process aria-label="Chpter 3 Process">Chpter 3 Process</a><ul><li><a href=#process-scheduling aria-label="Process Scheduling">Process Scheduling</a></li><li><a href=#operations-on-processes aria-label="Operations on Processes">Operations on Processes</a></li><li><a href=#interprocess-communication aria-label="Interprocess Communication">Interprocess Communication</a></li><li><a href=#%e5%90%8d%e8%af%8d%e8%a7%a3%e9%87%8a aria-label=名词解释：>名词解释：</a></li></ul></li><li><a href=#chapter-4-thread aria-label="Chapter 4 Thread">Chapter 4 Thread</a><ul><li><a href=#multithreading-models aria-label="Multithreading Models">Multithreading Models</a></li></ul></li><li><a href=#chapter-5-cpu-scheduling aria-label="Chapter 5 CPU Scheduling">Chapter 5 CPU Scheduling</a><ul><li><a href=#basic-concepts aria-label="Basic Concepts">Basic Concepts</a></li><li><a href=#scheduling-criteria aria-label="Scheduling Criteria">Scheduling Criteria</a></li><li><a href=#scheduling-algorithms aria-label="Scheduling Algorithms">Scheduling Algorithms</a></li><li><a href=#multiple-processor-scheduling aria-label="Multiple-Processor Scheduling">Multiple-Processor Scheduling</a></li></ul></li><li><a href=#chapter-6-process-synchronization aria-label="Chapter 6 Process synchronization">Chapter 6 Process synchronization</a><ul><li><a href=#the-critical-section-problem aria-label="The Critical-Section Problem">The Critical-Section Problem</a></li><li><a href=#semaphores aria-label=Semaphores>Semaphores</a></li></ul></li><li><a href=#chapter-7-deadlocks aria-label="Chapter 7 Deadlocks">Chapter 7 Deadlocks</a><ul><li><a href=#methods-for-handling-deadlocks aria-label="Methods for Handling Deadlocks">Methods for Handling Deadlocks</a></li></ul></li><li><a href=#chapter-8 aria-label="Chapter 8">Chapter 8</a><ul><li><a href=#logical-vs-physical-address-space aria-label="Logical vs. Physical Address Space">Logical vs. Physical Address Space</a></li><li><a href=#contiguous-memory-allocation aria-label="Contiguous Memory Allocation">Contiguous Memory Allocation</a></li><li><a href=#paging aria-label=paging>paging</a></li><li><a href=#structure-of-the-page-table aria-label="Structure of the Page Table">Structure of the Page Table</a></li><li><a href=#segmentation aria-label=segmentation>segmentation</a></li></ul></li><li><a href=#chapter-9-virtual-memory aria-label="Chapter 9 Virtual Memory">Chapter 9 Virtual Memory</a><ul><li><a href=#demand-paging aria-label="Demand paging">Demand paging</a></li><li><a href=#page-replacement aria-label="Page Replacement">Page Replacement</a></li><li><a href=#allocation-of-frames aria-label="Allocation of Frames">Allocation of Frames</a></li><li><a href=#thrashing aria-label=Thrashing>Thrashing</a></li><li><a href=#other-considerations aria-label="Other Considerations">Other Considerations</a></li></ul></li><li><a href=#chapter-10-file-system-interface aria-label="Chapter 10 File-System Interface">Chapter 10 File-System Interface</a><ul><li><a href=#access-methods aria-label="Access Methods">Access Methods</a></li><li><a href=#directory-structure aria-label="Directory Structure">Directory Structure</a></li></ul></li><li><a href=#file-system-implementation aria-label="File-System Implementation">File-System Implementation</a><ul><li><a href=#allocation-methods aria-label="Allocation Methods">Allocation Methods</a></li><li><a href=#free-space-management aria-label="Free-Space Management">Free-Space Management</a></li></ul></li><li><a href=#mass-storage-systems aria-label="Mass-Storage Systems">Mass-Storage Systems</a><ul><li><a href=#disk-scheduling aria-label="Disk Scheduling">Disk Scheduling</a></li><li><a href=#disk-management aria-label="Disk Management">Disk Management</a></li><li><a href=#raid-structure aria-label="RAID Structure">RAID Structure</a></li></ul></li><li><a href=#%e5%b8%b8%e7%94%a8%e5%8d%95%e8%af%8d aria-label=常用单词>常用单词</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=期末复习>期末复习<a hidden class=anchor aria-hidden=true href=#期末复习>¶</a></h1><h2 id=chpter-3-process>Chpter 3 Process<a hidden class=anchor aria-hidden=true href=#chpter-3-process>¶</a></h2><ul><li>操作系统进行任务调度和资源分配的基本单位</li><li>Process include:<ol><li>Program code</li></ol><ul><li>text section</li></ul><ol start=2><li>program counter and processors’ registers</li><li>Stack</li></ol><ul><li>Function parameters</li><li>Return address</li><li>Local variables</li></ul><ol start=4><li>data section</li></ol><ul><li>Global variables</li></ul><ol start=5><li>Heap</li></ol><ul><li>Dynamically allocated memory</li></ul></li><li>Process State<ul><li>五态模型<ul><li>new</li><li>ready:waiting to be assigned to a processor</li><li>waiting: waiting for some event to occur</li><li>running</li><li>terminated</li></ul></li></ul></li><li>Process control block（PCB）<ul><li>包含信息有：<ul><li>Process number</li><li>Process state</li><li>Program counter<ul><li>下条指令的地址</li></ul></li><li>CPU registers</li><li>CPU scheduling information</li><li>Memory-management information</li><li>Accounting information</li><li>I/O status information</li></ul></li></ul></li></ul><h3 id=process-scheduling>Process Scheduling<a hidden class=anchor aria-hidden=true href=#process-scheduling>¶</a></h3><ul><li><p>Scheduling queues</p><ol><li>Job queue</li></ol><ul><li>set of all processes in the system</li><li>As processes/job enter the system，they are put into the job queue</li></ul><ol start=2><li>Ready queue</li></ol><ul><li>set of all processes residing in “(main) memory”, ready and “waiting” to execute</li></ul><ol start=3><li>Device queues</li></ol><ul><li>set of processes waiting for an I/O device</li></ul></li><li><p>Scheduler(调度器)</p><ol><li>Long-term scheduler or job scheduler</li></ol><ul><li>job queue -> ready queue</li><li>may be absent on Time-sharing system such as UNIX and Windows<ul><li>They put every new process in memory for the short-term scheduler</li></ul></li></ul><ol start=2><li>Short-term scheduler Or CPU scheduler: 进程调度</li></ol><ul><li>selects which process should be executed next and allocates CPU</li><li>因为其执行十分频繁，所以每次选择不能耗时太长，否则就overhead</li></ul><ol start=3><li>Medium-term scheduler Or swapping</li></ol><ul><li>swap out: removes processes from memory to disk and reduces the degree of multiprogramming</li><li>swap in: introduce process into memory</li></ul></li><li><p>Context Switch</p><ul><li>CPU switches to another process</li></ul></li></ul><h3 id=operations-on-processes>Operations on Processes<a hidden class=anchor aria-hidden=true href=#operations-on-processes>¶</a></h3><ol><li>fork()<ul><li>The new process consists of a copy of the address space of the original process</li><li>The return code for the fork() is zero for the child process</li><li>子进程会复制父进程的地址空间和资源，但并不会复制父进程的线程</li></ul></li></ol><h3 id=interprocess-communication>Interprocess Communication<a hidden class=anchor aria-hidden=true href=#interprocess-communication>¶</a></h3><ul><li>Shared memory</li><li>Message passing</li></ul><h3 id=名词解释>名词解释：<a hidden class=anchor aria-hidden=true href=#名词解释>¶</a></h3><ul><li>multiprogramming： is to have some process running at all times, to maximize CPU utilization</li><li>time sharing ： is to switch the CPU among processes so frequently that users can interact with each process</li></ul><h2 id=chapter-4-thread>Chapter 4 Thread<a hidden class=anchor aria-hidden=true href=#chapter-4-thread>¶</a></h2><ul><li>进程 vs 线程<ul><li>线程是CPU的分布单位</li><li>进程是资源的分布单位</li><li>线程是进程中的执行单元<ul><li>一个进程可以包含多个线程，它们共享相同的地址空间和系统资源，如open files, signals。</li><li>每个线程有自己的栈空间和执行上下文，但它们在同一个进程内共享代码段、数据段和堆等资源。</li></ul></li></ul></li><li>benefits of multithreaded programming<ol><li>Responsiveness</li><li>Resource sharing</li><li>Economy</li><li>utilization of multiprocessor architectures</li></ol></li></ul><h3 id=multithreading-models>Multithreading Models<a hidden class=anchor aria-hidden=true href=#multithreading-models>¶</a></h3><ul><li><p>两种线程</p><ul><li>User Threads<ul><li>Provided by a thread library at the user level</li></ul></li><li>Kernel Threads<ul><li>Provided and managed by the OS directly</li></ul></li></ul></li><li><p>Relationship between kernel threads and user threads</p><ol><li>Many-to-one model</li><li>One-to-one model-</li><li>Many-to-many model</li><li>Two-level Model<ul><li>主体是Many-to-many model</li><li>A user thread (important task) can be bound to a kernel thread</li></ul></li></ol></li><li><p>Two versions of fork() in UNIX systems</p><ol><li>To duplicate all the threads<ul><li>If exec() is not called after forking, then to duplicate all threads</li></ul></li><li>To only duplicate the thread that invoked the fork() system call<ul><li>If exec() is called immediately after forking, then only to duplicate the calling threads</li></ul></li></ol></li></ul><h2 id=chapter-5-cpu-scheduling>Chapter 5 CPU Scheduling<a hidden class=anchor aria-hidden=true href=#chapter-5-cpu-scheduling>¶</a></h2><h3 id=basic-concepts>Basic Concepts<a hidden class=anchor aria-hidden=true href=#basic-concepts>¶</a></h3><ul><li>CPU scheduling decisions may take place when a process:<ol><li>Switches from running to waiting state<ul><li>The result of an I/O request</li><li>An invocation of wait for the termination of one of the child processes （e.g. wait(NULL);）</li></ul></li><li>Switches from running to ready state<ul><li>When a interrupt occurs</li></ul></li><li>Switches from waiting to ready<ul><li>Completion of I/O</li></ul></li><li>Terminates</li></ol></li><li>Non-preemptive (非剥夺)<ul><li>Once the CPU has been allocated to a process, the process keeps the CPU until it releases the CPU</li><li>调度只可能发生在情况 1. 和 4.</li><li>简单，硬件要求低</li></ul></li><li>Preemptive(剥夺)</li></ul><h3 id=scheduling-criteria>Scheduling Criteria<a hidden class=anchor aria-hidden=true href=#scheduling-criteria>¶</a></h3><ol><li>CPU utilization</li><li>CPU throughout<ul><li>number of processes that complete their execution per time unit.</li></ul></li><li>Process turnaround time<ul><li>From the time of submission of a process to the time of completion, include<ul><li>Waiting to get into memory</li><li>Waiting in the ready queue</li><li>Executing on the CPU</li><li>Doing I/O</li></ul></li></ul></li><li>Process waiting time (等待时间)<ul><li>amount of time that a process spent waiting in the ready queue.</li></ul></li><li>Process response time (响应时间)<ul><li>amount of the time from the submission of a request until the first response/result is produced</li></ul></li></ol><h3 id=scheduling-algorithms>Scheduling Algorithms<a hidden class=anchor aria-hidden=true href=#scheduling-algorithms>¶</a></h3><ol><li>First come first served (FCFS)<ul><li>non-preemptive</li><li>Convoy effect (护航效应)</li></ul></li><li>Shortest job first (SJF)<ul><li>minimum average waiting time</li><li>种类<ol><li>Preemptive SJF allows to preempt the currently executing process</li><li>Non-preemptive</li></ol></li><li>比较适用于长程调度</li></ul></li><li>Priority scheduling<ul><li>问题：starvation</li><li>解决： Aging (时效) – as time progresses increase the priority of the process</li></ul></li><li>Round robin (RR)<ul><li>Is designed for especially for time-sharing systems</li><li>preemptive</li><li>time quantum<ul><li>需要保证 80%的cpu bursts &lt; the time quantum</li></ul></li><li>Response time = 2*(n-1)*q</li></ul></li><li>Multilevel queue algorithm</li><li>Multilevel feedback queue algorithm<ul><li>the most general scheduling algorithm</li></ul></li></ol><h3 id=multiple-processor-scheduling>Multiple-Processor Scheduling<a hidden class=anchor aria-hidden=true href=#multiple-processor-scheduling>¶</a></h3><ul><li>homogeneous vs. heterogeneous CPUs<ul><li>homogeneous: 各处理器都一样</li></ul></li><li>Approaches to multiple-processor scheduling<ul><li>Asymmetric multiprocessing<ul><li>only one processor (the master server) has all scheduling decision, I/O processing</li></ul></li><li>Symmetric multiprocessing<ul><li>each processor is self-scheduling</li></ul></li></ul></li></ul><h2 id=chapter-6-process-synchronization>Chapter 6 Process synchronization<a hidden class=anchor aria-hidden=true href=#chapter-6-process-synchronization>¶</a></h2><ul><li>Race condition<ul><li>The situation where several processes access and manipulate shared data concurrently.</li><li>The final value of the shared data depends upon which process finishes last.</li></ul></li></ul><h3 id=the-critical-section-problem>The Critical-Section Problem<a hidden class=anchor aria-hidden=true href=#the-critical-section-problem>¶</a></h3><ul><li><p>critical section</p><ul><li>Each process has a code segment, called critical section, in which the shared data is accessed</li><li>有几个共享变量就有几个临界区</li></ul></li><li><p>Criteria for the critical section problem solution</p><ol><li>Mutual exclusion 互斥</li><li>progress 空闲让进</li><li>Bounded waiting 有限等待</li></ol></li><li><p>Peterson’s Solution</p><ul><li>举手+令牌</li></ul></li><li><p>hardware-based solution</p><ul><li>关中断<ul><li>多处理机不适合</li></ul></li><li>原子操作</li></ul></li></ul><h3 id=semaphores>Semaphores<a hidden class=anchor aria-hidden=true href=#semaphores>¶</a></h3><ul><li><p>A Semaphore S – integer variable</p><ul><li>may be initialized via a non-negative value</li><li>Can only be accessed via two indivisible (atomic) operations: P() and V()</li></ul></li><li><p>P(): the wait() operation</p><pre tabindex=0><code>wait (S) { 
  while (S.value &lt;= 0) ; 	// no-op
    S.value--;
}
</code></pre></li><li><p>V() The signal() operation</p><pre tabindex=0><code>signal(S){
  S.value++;
}
</code></pre></li><li><p>main problem : busy waiting (spinlock)</p><ul><li>advantages<ol><li>No context switch is required when a process must wait on a lock</li><li>If locks are expected to be held for short times, the spinlocks are useful</li></ol></li><li>disadvantages<ol><li>wastes the CPU cycles that can be used by other processes productively</li></ol></li><li>解决：modify the definition of the wait() and signal() <strong>适用于 multiprocessor system</strong><ul><li>Wait(): the process can block() itself rather than engaging in busy waiting</li><li>Signal(): change the blocking process from the waiting state to the ready state</li></ul></li></ul></li><li><p>implementation</p><ol><li>In a single-processor environment</li></ol><ul><li>Disable interrupt</li></ul><ol start=2><li>In a multi-processor environment</li></ol><ul><li>Critical section can be applied</li></ul></li></ul><h2 id=chapter-7-deadlocks>Chapter 7 Deadlocks<a hidden class=anchor aria-hidden=true href=#chapter-7-deadlocks>¶</a></h2><ul><li>Necessary conditions<ol><li>Mutual exclusion</li><li>Hold and wait</li><li>No preemption</li><li>Circular wait</li></ol></li></ul><h3 id=methods-for-handling-deadlocks>Methods for Handling Deadlocks<a hidden class=anchor aria-hidden=true href=#methods-for-handling-deadlocks>¶</a></h3><ol><li><p>Prevention</p><ul><li>Provides a set of methods for ensuring that at least one of necessary conditions cannot be held</li><li>针对条件2： all or nothing; 没有资源的时候才去申请</li><li>针对条件3： 谦让； 抢夺</li><li>针对条件4： 顺序执行</li><li>缺点： low device utilization and reduce system throughput.</li></ul></li><li><p>Avoidance</p><ul><li>using the addition information,decide whether the current request can be satisfied or must be delay</li><li>方法：<ol><li>Resource-allocation graph<ul><li>有环：处于unsafe state;可能处于死锁状态</li></ul></li><li>Banker&rsquo;s algorithm</li></ol></li></ul></li><li><p>Detection and recovery</p><ul><li>方法:<ul><li>Wait-for graph<ul><li>not appilcable to a resource-allocation system with multiple instances of each resource type</li></ul></li><li>Banker’s Algorithm</li></ul></li><li>When, and how often, to invoke detection algorithm. it depends on:<ul><li>How often a deadlock is likely to occur?</li><li>How many processes will need to be rolled back?</li></ul></li></ul></li><li><p>Ignorance</p></li></ol><h2 id=chapter-8>Chapter 8<a hidden class=anchor aria-hidden=true href=#chapter-8>¶</a></h2><ul><li><p>Address may be represented in</p><ol><li>symbolic address</li><li>re-locatable address</li><li>absolute address</li></ol></li><li><p>address binding</p><ul><li>转换：<ul><li>symbolic address -> re-locatable address : compiler</li><li>re-locatable address -> absolute address : linkage editor or loader</li></ul></li><li>发生的时期<ol><li>Compile time<ul><li>If memory location known at compile time, absolute code can be generated</li><li>If memory location is not known at compile time, Must generate re-locatable code</li></ul></li><li>Load time （+linkage time）<ul><li>if memory location is known at load time, absolute code can be generated at this time</li></ul></li><li>Execution time<ul><li>If memory location is not known at compile time and load time, Binding is delayed until run time</li><li>absolute code must be generated at run time</li></ul></li></ol></li></ul></li></ul><h3 id=logical-vs-physical-address-space>Logical vs. Physical Address Space<a hidden class=anchor aria-hidden=true href=#logical-vs-physical-address-space>¶</a></h3><ul><li><p>Logical address ：CPU</p><ul><li>also referred to as virtual address</li><li>重定位地址和逻辑地址没有直接关系</li></ul></li><li><p>Physical address ：memory unit</p></li><li><p>logical (virtual) and physical addresses differ in execution-time address-binding scheme</p><ul><li>re-locatable code are seen by CPU</li><li>absolute code are seen by the memory unit</li></ul></li><li><p>Memory-Management Unit (MMU)</p><ul><li>Hardware device that maps virtual address to physical address in the run-time</li></ul></li><li><p>Dynamic load</p><ul><li>not loaded the entire program and data of a process be in physical memory for the process to execute until it is called</li><li>好处：<ol><li>Better memory-space utilization</li><li>No special support is required from the operating system</li></ol></li></ul></li><li><p>Dynamic linking</p><ul><li>Linking is postponed until execution time</li><li>requires help from the OS</li></ul></li></ul><h3 id=contiguous-memory-allocation>Contiguous Memory Allocation<a hidden class=anchor aria-hidden=true href=#contiguous-memory-allocation>¶</a></h3><ol><li>Fixed-Sized Contiguous Partition<ul><li>Strengths (advantages)<ul><li>Simple to implement</li><li>little overhead</li></ul></li><li>Weaknesses(drawbacks)<ul><li>internal fragmentation<ul><li>allocated memory may be larger than requested memory</li></ul></li><li>fixed number of processes</li></ul></li></ul></li><li>Dynamic Contiguous partition（可变分区）<ul><li>Hole – block of available memory</li><li>Allocation algorithms<ol><li>first fit:<ul><li>从头开始，或者是从当前位置开始</li></ul></li><li>best-fit<ul><li>Need to search all entire list, unless the list is ordered by size</li><li>produces the smallest leftover hole that may be wasted</li></ul></li><li>worst-fit<ul><li>Need to search all entire list, unless the list is ordered by size</li><li>小进程多的 效果好</li></ul></li></ol></li><li>问题：<ul><li>External Fragmentation</li></ul></li></ul></li></ol><ul><li><p>Solutions to fragmentation</p><ol><li>Compaction(紧凑)<ul><li>To reduce external fragmentation</li><li>Shuffle memory contents to place all free memory together in one large block</li><li>It is done at execution time， it’s possible only if relocation is dynamic</li><li>May be expensive in moving the processes and the holes</li></ul></li><li>paging</li><li>segmentation</li></ol></li><li><p>Disadvantage of Contiguous Memory Allocation</p><ul><li>Fragmentation in main memory</li><li>Compaction is impossible on the disk</li></ul></li></ul><h3 id=paging>paging<a hidden class=anchor aria-hidden=true href=#paging>¶</a></h3><ul><li><p>frame: Divide physical memory into fixed-sized blocks</p></li><li><p>page : Divide logical memory into fixed-sized blocks</p><ul><li>page size is equal to frame size</li><li>Finding n free frames for loading a program of size n pages</li></ul></li><li><p>Translating logical address to physical address
If the address space is 2^m and the page size is 2^n</p><ul><li>Every logical address generated by CPU is divided into:<ol><li>Page number (p: 页号)<ul><li>used as an index into a page table</li><li>页表中包含每一页在physical memory 的 base address (f:块号)</li><li>p =address/2^n is equal to m-n bit of the address</li></ul></li><li>Page offset (d: 偏移)<ul><li>combined with base address (f:块号) to define the physical memory address that is sent to the memory unit</li><li>d =address%2n is equal to n bit of the address</li></ul></li></ol></li><li>Physical address<ol><li>frame number（f: 帧号、块号)</li><li>page offset (d:页偏移、块偏移)</li></ol></li></ul></li><li><p>page size的选择</p><ul><li>越大：<ul><li>Disk I/O is more efficient</li><li>page table size 越小</li></ul></li><li>越小：<ul><li>internal fragmentation 越小</li></ul></li></ul></li><li><p>Frame table (主存分块表)</p><ul><li>Has one entry for each physical page frame
Indicating<ul><li>whether the frame is free or it is allocated to which process</li></ul></li></ul></li><li><p>page table</p><ul><li>each process must maintain a copy of the page table</li><li>计算<ul><li>if page-table entry is 4 bytes long<ul><li>Can point to one of 2^32 physical page frames (1比特=8字节)</li><li>If frame size(= page size) is 4KB, the system can address 2^44 bytes(2^32×2^12=16TB) of physical memory</li></ul></li><li>对于32位cpu<ul><li>page size: 4k (=2^12)</li><li>Table size：2^32/2^12=1M</li><li>each entry&rsquo;s size : 4 bytes</li><li>page table 的大小为： 4 MB</li></ul></li></ul></li><li>位置<ol><li>直接存放在寄存器中：<ul><li>Efficient and expensive</li><li>当page table is reasonable small 时可以</li></ul></li><li>存放在main memory ，然后用Page-table base register (PTBR：页表基址寄存器)存放其位置<ul><li>进程切换时，加载页表只需要改变PTBR</li><li>every data/instruction access requires two memory accesses<ul><li>One for the page table</li><li>One for the data/instruction</li></ul></li></ul></li><li>Translation Look-aside Buffer (TLB) also called Associate Memory(联想寄存器)<ul><li>并行查找</li><li>contains only a few of page-table entries</li></ul></li></ol></li></ul></li></ul><h3 id=structure-of-the-page-table>Structure of the Page Table<a hidden class=anchor aria-hidden=true href=#structure-of-the-page-table>¶</a></h3><ul><li>问题: The page table can be excessively large</li><li>Solution： Divide the page table into smaller pieces<ol><li>Hierarchical Paging （分层页表）</li><li>Hashed Page Tables（哈希页表）</li><li>Inverted Page Tables（反置页表）</li></ol></li></ul><ol><li>Hierarchical Paging （分层页表）<ul><li>缺陷：</li></ul><ol><li>需遍历，进程太多</li><li>可能有共享，而进程号只能填一个</li><li>不适用于64位</li></ol><ul><li>好：<ol><li>需要的空间小</li></ol></li></ul></li><li>Hashed Page Tables<ul><li>hash table -> 在链表中遍历匹配</li></ul></li><li>Inverted Page Table(反置页表/主存分块表)</li></ol><ul><li>Only a page table in the system</li><li>One entry for each real page (or physical frame) of memory</li><li>缺点：<ul><li>increases time needed to search the table when a page reference occurs</li><li>Lead to memory share difficulty</li></ul></li></ul><h3 id=segmentation>segmentation<a hidden class=anchor aria-hidden=true href=#segmentation>¶</a></h3><ul><li>User’s View of a Program: A program is a collection of segments，a segment is a logical unit such as:<ul><li>main program<ul><li>procedure ，function，method，object</li><li>local variables, global variables</li><li>common block</li><li>stack</li><li>symbol table</li><li>arrays</li></ul></li></ul></li></ul><h2 id=chapter-9-virtual-memory>Chapter 9 Virtual Memory<a hidden class=anchor aria-hidden=true href=#chapter-9-virtual-memory>¶</a></h2><ul><li><p>the entire program is not needed to be in physical memory.这样的好处有：</p><ul><li>程序的大小不再受内存所限制</li><li>更多程序可以同时运行</li><li>Less I/O would be needed to load or swap each user program into memory, so program would start to run faster</li></ul></li><li><p>Virtual memory management</p><ul><li>a term used to describe a technique whereby the computer appears to have much more memory than it actually does</li></ul></li><li><p>Virtual memory can be implemented via:</p><ul><li>Demand paging</li><li>Demand segmentation</li></ul></li></ul><h3 id=demand-paging>Demand paging<a hidden class=anchor aria-hidden=true href=#demand-paging>¶</a></h3><ul><li><p>思想： Bring a page into memory only when it is needed</p><ul><li>Be similar to a paging system with swapping</li></ul></li><li><p>Hardware</p><ul><li>Page table. 需要加一位valid–invalid bit<ul><li>v -》 The page is legal and in memory</li></ul></li><li>Secondary memory<ul><li>A high-speed disk, Swap space</li><li>Hold those page that are not present in memory</li></ul></li></ul></li><li><p>Page Fault</p><ul><li>Access to a page marked invalid causes a page-fault trap</li><li>handle<ol><li>Operating system looks at another table (PCB) to decide:<ul><li>Invalid reference -> abort</li><li>Just not in memory （go on to 2））</li></ul></li><li>Get empty frame</li><li>Swap the desired page into the frame</li><li>modify the page table, Set validation bit = v</li><li>Restart the instruction that caused the page fault</li></ol></li><li>特殊：<ol><li>一条指令可产生多个缺页中断</li><li>指令复执</li><li>在指令执行时中断。</li></ol></li><li>对比普通中断：<ul><li>一条指令在执行完后，检查是否有中断请求<ul><li>有：执行中断</li><li>无：执行下一条指令</li></ul></li></ul></li></ul></li></ul><h3 id=page-replacement>Page Replacement<a hidden class=anchor aria-hidden=true href=#page-replacement>¶</a></h3><p><strong>替换算法</strong></p><ol><li><p>FIFO page Replacement</p><ul><li>Belady’s Anomaly : more frames -> more page faults</li></ul></li><li><p>Optimal Page Replacement (OPT)</p><ul><li>替换最晚才用的页 或 后面最长时间用不到的页</li></ul></li><li><p>Least Recently Used (LRU) Algorithm</p><ul><li>思想： The recent past as an approximation of the near future</li><li>实现：</li><li>counters</li><li>stack</li></ul></li><li><p>LRU Approximation Algorithms</p><ol><li>Additional-reference-bits algorithm</li><li>Second chance (clock)</li><li>Enhanced second-chance algorithm</li></ol></li><li><p>Counting-Based Page Replacement</p><ul><li>Least Frequently used</li><li>Most Frequently used</li></ul></li><li><p>Page-Buffering Algorithm</p><ul><li>Assistant procedure to a page-replacement algorithm</li></ul></li></ol><h3 id=allocation-of-frames>Allocation of Frames<a hidden class=anchor aria-hidden=true href=#allocation-of-frames>¶</a></h3><ul><li><p>Two major allocation schemes</p><ol><li>fixed allocation<ul><li>Equal allocation</li><li>Proportional allocation</li></ul></li><li>priority allocation<ul><li>Use a proportional allocation scheme using priorities rather than size</li></ul></li></ol></li><li><p>Global vs. Local Allocation</p><ol><li>Local replacement<ul><li>To allow a process to select from only its own set of allocated frames.</li><li>Cannot increase the number of frames allocated</li><li>Not affected by external circumstances</li></ul></li><li>Global replacement<ul><li>To allow a process to select a replacement frame from the set of all frames, even if that frame is currently allocated to some other process</li><li>Can increase the number of frames allocated</li><li>Cannot control its page-fault rate.</li></ul></li></ol><ul><li>In general, global replacement is better.</li></ul></li></ul><h3 id=thrashing>Thrashing<a hidden class=anchor aria-hidden=true href=#thrashing>¶</a></h3><ul><li>A process is thrashing （颠簸）if it is spending more time paging than executing</li><li>approach<ol><li>Using a local replacement algorithm</li><li>Working-set strategy<ul><li>To compute the working-set size for each process in the system</li></ul></li><li>Page-Fault Frequency (PFF) Scheme (水多了加面，面多了加水)<ul><li>If actual rate too low, remove a frame from the process</li><li>If actual rate too high, allocate another frame to the process</li><li>If no frames are free, suspend it</li></ul></li></ol></li></ul><h3 id=other-considerations>Other Considerations<a hidden class=anchor aria-hidden=true href=#other-considerations>¶</a></h3><ul><li>page size 大小的选择要考虑到：<ol><li>内碎片</li><li>页表的大小</li><li>I/O overhead (seek time, latency time, transfer time)</li><li>Locality</li><li>Page fault rate<ul><li>顺序访问： page size越大，则缺页中断率越小</li><li>随机访问： page size越大，则more paging action could ensue because fewer pages can be kept in memory and more data is transferred per page fault.</li></ul></li></ol></li><li>Install a faster hard disk, or multiple controllers with multiple hard disks<ul><li>for as the disk bottleneck is removed by faster response and more throughput to the disks, the CPU will get more data more quickly</li></ul></li></ul><h2 id=chapter-10-file-system-interface>Chapter 10 File-System Interface<a hidden class=anchor aria-hidden=true href=#chapter-10-file-system-interface>¶</a></h2><ul><li>File<ul><li>A file is named collection of related information that is recorded on secondary storage</li><li>Six basic operations<ol><li>create</li><li>read/write/seek</li><li>delete</li><li>truncate: to erase the contents of a file but keep its attributes except for it’s length</li></ol></li><li>Assistant operations<ul><li>open(F):<ol><li>search the directory structure on disk for entry F</li><li>copy the directory entry into the open-file table</li><li>allocate a file descriptor</li></ol></li><li>close(F):<ol><li>copy the directory entry in the open-file table to the directory structure on disk</li><li>free the file descriptor</li></ol></li></ul></li></ul></li></ul><h3 id=access-methods>Access Methods<a hidden class=anchor aria-hidden=true href=#access-methods>¶</a></h3><ul><li>The information in the file can be accessed in<ol><li>sequentical access</li><li>direct access</li><li>other access<ul><li>involve the construction of an index for the file</li></ul></li></ol></li></ul><h3 id=directory-structure>Directory Structure<a hidden class=anchor aria-hidden=true href=#directory-structure>¶</a></h3><ul><li><p>symbol table</p><ul><li>The directory can be viewed as a symbol table that translates file names into their directory entries</li></ul></li><li><p>Criteria</p><ol><li>efficiency</li><li>naming</li><li>grouping</li></ol></li><li><p>shemes</p><ol><li>Single-Level Directory</li><li>Two-Level Directory<ul><li>Positive<ul><li>Efficient searching</li></ul></li><li>Negative<ul><li>No grouping capability</li><li>Difficult to share file among different users</li></ul></li></ul></li><li>Tree-Structured Directories<ul><li>Positive<ul><li>Efficient searching</li><li>Grouping Capability</li></ul></li><li>Negative<ul><li>Difficult to share file among different users</li></ul></li></ul></li><li>Acyclic-Graph Directories<ul><li>Tree-structured directory + shared subdirectories or files</li><li>Created a new directory entry called a link to implement sharing</li><li>The difficulty is to avoid cycles as new links are added</li></ul></li><li>General Graph Directory<ul><li>Add the links to an existing tree-structure directory</li><li>Acyclic-Graph Directories更好</li></ul></li></ol></li><li><p>硬（hard）链接</p><ul><li><code>ln /usr/local/python3 python</code></li><li>目录中仅存储指向文件数据的指针</li><li>允许一个文件被多个目录引用.</li><li>无法用来链接目录，也不能跨文件系统</li><li>通过<code>ls -i</code>查看是否为硬链接</li></ul></li><li><p>软 (symbolic) 链接</p><ul><li>“快捷方式”</li><li>软链接也是一个文件</li><li><code>ln -s ../p24 p24</code></li><li>目录从“树”变为了“图”，还是有环图</li></ul></li><li><p>ACL: access-control list</p><ul><li>Each file or directory has an ACL</li></ul></li></ul><h2 id=file-system-implementation>File-System Implementation<a hidden class=anchor aria-hidden=true href=#file-system-implementation>¶</a></h2><ul><li>File system organized into layers<ol><li>application program</li><li>logical file system<ul><li>FCB: file control blocks</li></ul></li><li>file-organizational module</li><li>basic file system</li><li>I/O control</li><li>devices</li></ol></li></ul><h3 id=allocation-methods>Allocation Methods<a hidden class=anchor aria-hidden=true href=#allocation-methods>¶</a></h3><ul><li><p>An allocation method refers to how disk blocks are allocated for files</p></li><li><p>Contiguous allocation</p><ul><li>Each file occupies a set of contiguous blocks on the disk</li><li>Supports both sequential access and direct access （Random access）</li><li>问题：<ol><li>External fragmentation</li><li>Files cannot grow</li></ol></li></ul></li><li><p>Linked allocation</p><ul><li>Each file is a linked list of disk blocks: blocks may be scattered anywhere on the disk</li><li>优点<ol><li>容易实现</li><li>无外碎片</li><li>文件增长方便</li></ol></li><li>缺点：<ol><li>No random access</li><li>Poor reliability</li><li>慢（链表是保存在磁盘上的，所以需要多次查询）</li></ol></li><li>改进： File-allocation table (FAT)<ul><li>把链表信息放到了一个单独的FAT表中，而不是各个数据块中，且进行备份</li></ul></li></ul></li><li><p>Indexed allocation</p><ul><li><p>Bringing all the pointers together into one location: index block</p></li><li><p>Solutions to large files</p><ol><li>Linked sheme<ul><li>Link blocks of index table</li></ul></li><li>Multilevel index</li><li>Combined scheme<ul><li>一部分是 direct pointers ，一部分是multi-indirect block</li></ul></li></ol></li><li><p>Criteria</p><ol><li>storage utilization efficiency</li><li>data block access time</li></ol><ul><li>Contiguous allocation: Good for known-size file</li><li>Linked allocation: Good for storage utilization</li><li>Indexed allocation: Access time depends on index structure, file size, block position</li></ul></li></ul></li></ul><h3 id=free-space-management>Free-Space Management<a hidden class=anchor aria-hidden=true href=#free-space-management>¶</a></h3><ul><li>The free-space list 的实现<ol><li>Bit vector<ul><li>优点<ul><li>Simple to implement</li><li>Efficient to find the first free block</li></ul></li><li>缺点<ul><li>Bit map requires extra space</li><li>Inefficient unless the entire vector is kept in main memory</li></ul></li></ul></li><li>Linked Lists (free list)<ul><li>优点<ul><li>No waste of space</li></ul></li><li>缺点<ul><li>Inefficient when traversing the list</li></ul></li></ul></li><li>Grouping</li></ol><ul><li>The first free block store the addresses of n free blocks</li><li>Easier to find a large number of free blocks</li></ul></li></ul><h2 id=mass-storage-systems>Mass-Storage Systems<a hidden class=anchor aria-hidden=true href=#mass-storage-systems>¶</a></h2><ul><li><p>Magnetic disk&rsquo;s structure</p><ul><li>Disk platter</li><li>track</li><li>sector<ul><li>each track is subdivided into several sectors</li></ul></li><li>cylinder<ul><li>is the set of tracks that are at one arm position</li></ul></li></ul></li><li><p>CLV vs. CAV</p><ol><li>ClV : constant linear velocity<ul><li>CD-ROM， DVD-ROM</li><li>Tracks in the outermost zone hold more sectors</li></ul></li><li>CAV : constant angular velocity<ul><li>Magnetic disk</li><li>The density of bits decreases from inner tracks to outer tracks to keep the data rate constant</li></ul></li></ol></li></ul><h3 id=disk-scheduling>Disk Scheduling<a hidden class=anchor aria-hidden=true href=#disk-scheduling>¶</a></h3><ul><li>Access time<ol><li>Seek time is the time for the disk are to move the heads to the cylinder containing the desired sector<ul><li>Seek time  seek distance</li></ul></li><li>Rotational latency<ul><li>waiting for the disk to rotate the desired sector to the disk head</li></ul></li></ol></li><li>Disk bandwidth<ul><li>The total number of bytes transferred / the total time between the first request for service and the completion of the last transfer</li></ul></li></ul><ol><li>FCFS Scheduling</li><li>SSTF：Shortest-seek-time-first (SSTF)<ul><li>最短寻道时间优先</li><li>问题：<ul><li>往返跑&mdash;距离很短，但速度不一定很快</li><li>may cause starvation of some requests</li></ul></li></ul></li><li>SCAN</li></ol><ul><li>Sometimes called the elevator algorithm</li></ul><ol start=4><li>C-SCAN (Circular SCAN)</li></ol><ul><li>The head moves from one end of the disk to the other, servicing requests as it goes</li><li>When it reaches the other end, however, it immediately returns to the beginning of the disk, without servicing any requests on the return trip</li><li>回途不载客</li></ul><ol start=5><li>LOOK / C-LOOK</li></ol><ul><li><p>Similar to SCAN/C-SCAN</p></li><li><p>Arm only goes as far as the last request in each direction, then reverses direction immediately, without first going all the way to the end of the disk.</p></li><li><p>选择
<strong>Performance depends on the number and types of requests</strong></p><ul><li>SCAN and C-SCAN perform better for systems that place a heavy load on the disk</li><li>Either SSTF or LOOK is a reasonable choice for the default algorithm</li></ul></li></ul><h3 id=disk-management>Disk Management<a hidden class=anchor aria-hidden=true href=#disk-management>¶</a></h3><ul><li>Disk formatting<ul><li>Low-Level Formatting (physical formatting )<ul><li>Dividing a disk into sectors that the disk controller can read and write</li></ul></li><li>logical Formatting<ul><li>Creation of a file system</li><li>Build the metadata structures for a file system</li></ul></li></ul></li></ul><h3 id=raid-structure>RAID Structure<a hidden class=anchor aria-hidden=true href=#raid-structure>¶</a></h3><ul><li><p>Redundant Array of Inexpensive Disks (past)</p></li><li><p>Redundant Array of Independent Disks (now)</p><ul><li>Used for their higher reliability and higher data-transfer rate(performance)</li></ul></li><li><p>levels</p><ol><li>RAID 0<ul><li>Disk arrays with data striping at the level of blocks but without any redundancy</li></ul></li><li>RAID 1<ul><li>Disk mirroring</li></ul></li><li>RAID 2<ul><li>Bit-level striping or Byte-level striping</li><li>Memory-style error-correcting-code (ECC)</li></ul></li><li>RAID 3<ul><li>Bit-interleaved parity</li></ul></li><li>RAID 4<ul><li>Block-interleaved parity organization</li></ul></li><li>RAID 5<ul><li>Block-interleaved distributed parity</li></ul></li></ol></li></ul><hr><h2 id=常用单词>常用单词<a hidden class=anchor aria-hidden=true href=#常用单词>¶</a></h2><ul><li>simultaneously : 同时地</li><li>idle : 空闲，懒</li><li>reside : 位于，居住</li><li>uni-processor : 单处理器</li><li>interleave: 交织</li><li>allocation : 分配</li><li>dashed line ： 虚线</li><li>minuscule : 微小的</li><li>concrete : 具体的</li><li>mandatory: 强制的</li><li>mediate : 调解</li><li>strip : 脱掉；条</li></ul></div><footer class=post-footer><nav class=paginav><a class=prev href=https://euds63.github.io/2023/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></svg>&nbsp;</span><br><span>《操作系统：设计与实现》笔记</span></a>
<a class=next href=https://euds63.github.io/2023/%E8%BD%AF%E5%B7%A5%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/><span class=title>&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span><br><span>软工导论复习笔记</span></a></nav></footer><div class=comments-separator></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://euds63.github.io/>EuDs's Blog</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a></span>
<span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n=""=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script>
<script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a="1"=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script></body></html>