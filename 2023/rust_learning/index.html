<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rust_Learning | EuDs's Blog</title><meta name=keywords content="Rust,记录"><meta name=description content="no panic"><meta name=author content="euds63"><link rel=canonical href=https://euds63.github.io/2023/rust_learning/><link crossorigin=anonymous href=/assets/css/stylesheet.min.be037ed91db9b40ac53dc29e76d73dfc6f41c682c03e19f95a9472905dc1395c.css integrity="sha256-vgN+2R25tArFPcKedtc9/G9BxoLAPhn5WpRykF3BOVw=" rel="preload stylesheet" as=style><link rel=icon href=https://euds63.github.io/favicon.ico><link rel=apple-touch-icon href=https://euds63.github.io/apple-touch-icon.png><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust_Learning | EuDs's Blog"><meta name=twitter:description content="no panic"><meta property="og:title" content="Rust_Learning | EuDs's Blog"><meta property="og:description" content="no panic"><meta property="og:type" content="article"><meta property="og:url" content="https://euds63.github.io/2023/rust_learning/"><meta property="og:image" content="https://euds63.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-18T16:25:21+08:00"><meta property="article:modified_time" content="2023-07-18T16:25:21+08:00"><meta property="og:site_name" content="EuDs's Blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://euds63.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Rust_Learning","item":"https://euds63.github.io/2023/rust_learning/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust_Learning | EuDs's Blog","name":"Rust_Learning","description":"no panic","keywords":["Rust","记录"],"wordCount":"2320","inLanguage":"en","datePublished":"2023-07-18T16:25:21+08:00","dateModified":"2023-07-18T16:25:21+08:00","author":{"@type":"Person","name":"euds63"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://euds63.github.io/2023/rust_learning/"},"publisher":{"@type":"Organization","name":"EuDs's Blog","logo":{"@type":"ImageObject","url":"https://euds63.github.io/favicon.ico"}}}</script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://euds63.github.io/ accesskey=h title="EuDs's Blog (Alt + H)">EuDs's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://euds63.github.io/discover/ title="Discover (Alt + /)" data-no-instant accesskey=/>Discover</a></li><li><a href=https://euds63.github.io/about/ title=about>about</a></li><li><a href=https://euds63.github.io/archives/ title=archives>archives</a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><h1 class=post-title>Rust_Learning</h1><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>July 18, 2023</span></span><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://euds63.github.io/tags/rust/>Rust</a><a href=https://euds63.github.io/tags/%E8%AE%B0%E5%BD%95/>记录</a></span></span></div></header><div class="toc side right"><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#rust_learning aria-label=Rust_Learning>Rust_Learning</a><ul><li><a href=#cargo%e4%bd%bf%e7%94%a8 aria-label=Cargo使用>Cargo使用</a></li><li><a href=#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5 aria-label=参考链接>参考链接</a></li><li><a href=#rust%e7%89%b9%e7%82%b9 aria-label=Rust特点>Rust特点</a></li><li><a href=#chapter3-common-programming-concepts aria-label="Chapter3 Common Programming Concepts">Chapter3 Common Programming Concepts</a></li><li><a href=#chapter4-understanding-ownship aria-label="Chapter4 Understanding Ownship">Chapter4 Understanding Ownship</a><ul><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></li><li><a href=#chapter5-struct aria-label="Chapter5 Struct">Chapter5 Struct</a></li><li><a href=#chapter6-enum aria-label="Chapter6 Enum">Chapter6 Enum</a></li><li><a href=#chapter7-managing-growing-projects-with-packages-crates-and-modules aria-label="Chapter7 Managing Growing Projects with Packages, Crates, and Modules">Chapter7 Managing Growing Projects with Packages, Crates, and Modules</a><ul><li><a href=#packages-a-cargo-feature-that-lets-you-build-test-and-share-crates aria-label="Packages: A Cargo feature that lets you build, test, and share crates">Packages: A Cargo feature that lets you build, test, and share crates</a></li><li><a href=#crates-a-tree-of-modules-that-produces-a-library-or-executable aria-label="Crates: A tree of modules that produces a library or executable">Crates: A tree of modules that produces a library or executable</a></li><li><a href=#modules-and-use-let-you-control-the-organization-scope-and-privacy-of-paths aria-label="Modules and use: Let you control the organization, scope, and privacy of paths">Modules and use: Let you control the organization, scope, and privacy of paths</a></li><li><a href=#paths-a-way-of-naming-an-item-such-as-a-struct-function-or-module aria-label="Paths: A way of naming an item, such as a struct, function, or module">Paths: A way of naming an item, such as a struct, function, or module</a></li></ul></li><li><a href=#chapter8 aria-label=Chapter8>Chapter8</a><ul><li><a href=#vector aria-label=Vector>Vector</a></li><li><a href=#string aria-label=String>String</a></li><li><a href=#hash-map aria-label="hash map">hash map</a></li></ul></li><li><a href=#chapter10 aria-label=chapter10>chapter10</a><ul><li><a href=#generic-data-types aria-label="Generic Data Types">Generic Data Types</a></li><li><a href=#trait aria-label=trait>trait</a></li><li><a href=#lifetime aria-label=lifetime>lifetime</a></li></ul></li><li><a href=#chapter11 aria-label=chapter11>chapter11</a><ul><li><a href=#the-output-from-running-the-automatically-generated-test aria-label="The output from running the automatically generated test">The output from running the automatically generated test</a></li><li><a href=#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4 aria-label=常用命令>常用命令</a></li><li><a href=#running-tests-in-parallel-or-consecutively aria-label="Running Tests in Parallel or Consecutively">Running Tests in Parallel or Consecutively</a></li><li><a href=#test-organization aria-label=test-organization>test-organization</a></li></ul></li><li><a href=#chapter12 aria-label=chapter12>chapter12</a></li><li><a href=#chapter13 aria-label=chapter13>chapter13</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=rust_learning>Rust_Learning<a hidden class=anchor aria-hidden=true href=#rust_learning>¶</a></h1><p><strong>记录我的Rust学习</strong></p><h2 id=cargo使用>Cargo使用<a hidden class=anchor aria-hidden=true href=#cargo使用>¶</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>cargo new
</span></span><span class=line><span class=cl>cargo build 
</span></span><span class=line><span class=cl>cargo run
</span></span><span class=line><span class=cl>cargo check
</span></span><span class=line><span class=cl>cargo doc --open <span class=c1>#build documentation provided by all your dependencies locally and open it in your browser</span>
</span></span></code></pre></div><h2 id=参考链接>参考链接<a hidden class=anchor aria-hidden=true href=#参考链接>¶</a></h2><ul><li><a href=https://course.rs/ target=_blank rel=noopener>Rust语言圣经</a></li><li><a href=https://rust-book.cs.brown.edu/ target=_blank rel=noopener>The Rust Programming Language</a></li><li><a href=https://zh.practice.rs/ target=_blank rel=noopener>Rust语言实战</a></li><li><a href=https://picklenerd.github.io/ target=_blank rel=noopener>PNGme</a></li></ul><h2 id=rust特点>Rust特点<a hidden class=anchor aria-hidden=true href=#rust特点>¶</a></h2><ul><li>Patterns and the match construct</li><li>a strong, static type system.</li><li>type inference</li><li>shadow</li><li>Rust uses the term panicking when a program exits with an error</li><li>requiring type annotations in function definitions</li><li>Rust&rsquo;s goal is to compile programs into efficient binaries that <em>require as few runtime checks as possible</em></li><li>A foundational goal of Rust is to ensure that your programs never have undefined behavior</li></ul><h2 id=chapter3-common-programming-concepts>Chapter3 Common Programming Concepts<a hidden class=anchor aria-hidden=true href=#chapter3-common-programming-concepts>¶</a></h2><ul><li>constant v.s. variable<ol><li>Constants aren’t just immutable by default;they’re always immutable.</li><li>Constants can be declared in any scope</li><li>Constants may be set only to a constant expression, not the result of a value that could only be computed at runtime.</li></ol></li><li>shadow ends until<ol><li>it itself is shadowed</li><li>the scope ends</li></ol></li><li>Integer division truncates toward zero to the nearest integer</li><li>tuple和array区别<ol><li>tuple的各类型可以不同；</li><li>array的大小固定,在定义时就指定了</li><li>tuple更灵活,可存储不同类型,一般用于临时组合数据</li><li>array大小固定,用于存储大量相同类型的数据</li></ol></li><li>expression and statement<ol><li>Expressions do not include ending semicolons</li><li>statement does not return a value</li><li>the return value of the function is synonymous with <em>the value of the final expression in the block of the body of a function</em></li></ol></li><li>Control Flow<ol><li>This means the values that have the potential to be results from each arm of the if must be the same type</li><li>Rust does not have a concept of &ldquo;truthy&rdquo; or &ldquo;falsy&rdquo; values.So <em>The condition to an if-expression must be a boolean</em></li></ol></li></ul><h2 id=chapter4-understanding-ownship>Chapter4 Understanding Ownship<a hidden class=anchor aria-hidden=true href=#chapter4-understanding-ownship>¶</a></h2><ul><li>The stack holds data associated with a specific function, while the heap holds data that can outlive a function</li><li>Rust does not allow programs to manually deallocate memory. That policy avoids the kinds of undefined behaviors shown above.</li><li>Box deallocation principle : If a variable owns a box, when Rust deallocates the variable&rsquo;s frame, then Rust deallocates the box&rsquo;s heap memory.</li><li>Moved heap data principle: if a variable x moves ownership of heap data to another variable y, then x cannot be used after the move.</li><li>A reference is a kind of pointer.</li><li>Rust implicitly inserts dereferences and references in certain cases, such as calling a method with the dot operator</li><li><em>Pointer Safety Principle</em>: data should never be aliased and mutated at the same time.</li><li>Permissions are defined on <em>paths</em> and not just variables. A path is anything you can put on the left-hand side of an assignment.</li><li>Creating a reference to data ("<em>borrowing</em>" it) causes that data to be temporarily read-only until the reference is no longer used.</li><li>Rust&rsquo;s borrow checker does not contain different paths for a[0], a[1], and so on. It uses a single path a[_] that represents all indexes of a.</li><li>Slices are special kinds of references because they are &ldquo;fat&rdquo; pointers, or pointers with metadata. Here, the metadata is the length of the slice.</li></ul><h3 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>¶</a></h3><ul><li>优势<ol><li>improving runtime performance by avoiding garbage collection</li><li>improving predictability by preventing accidental &ldquo;leaks&rdquo; of data.</li></ol></li><li>Pointers can be created through<ol><li>boxes (pointers owning data on the heap)</li><li>references (non-owning pointers).</li></ol></li><li>move v.s. borrow<ul><li>A move of a variable with a non-copyable type (like Box or String) requires the RO permissions, and the move eliminates all permissions on the variable. That rule prevents the use of moved variables:</li><li>Borrowing a variable (creating a reference to it) temporarily removes some of the variable&rsquo;s permissions<ul><li>An immutable borrow creates an immutable reference, and also <em>disables the borrowed data from being mutated or moved.</em></li><li>A mutable borrow creates a mutable reference, which* disables the borrowed data from being read, written, or moved*</li></ul></li></ul></li><li>use-after-free: <em>Immutable borrows</em> remove the W permission to avoid use-after-free,</li><li>double-frees: Dereferences of references to non-copyable data do not have the O permission to avoid double-frees</li></ul><h2 id=chapter5-struct>Chapter5 Struct<a hidden class=anchor aria-hidden=true href=#chapter5-struct>¶</a></h2><ul><li>Rust <em>does not have a keyword for constructor functions</em>. The idiomatic way to define a constructor function is to make an associated function called new, but that is not enforced by the language.</li><li>tuple struct. e.g. <code>struct Color (i32,i32,i32);</code></li><li>Rust will insert as many references and dereferences as needed to make the types match up for the self parameter</li><li>Rust does not auto-derive Copy for stability across API changes. <code>#[derive(Copy, Clone)]</code></li><li>when you see an error like &ldquo;cannot move out of *self&rdquo;, that&rsquo;s usually because you&rsquo;re trying to call a self method on a reference like &amp;self or &amp;mut self. Rust is protecting you from a double-free</li></ul><h2 id=chapter6-enum>Chapter6 Enum<a hidden class=anchor aria-hidden=true href=#chapter6-enum>¶</a></h2><ul><li>advantage to using an enum rather than a struct:</li></ul><ol><li>each variant can have different types and amounts of associated data</li><li>the name of each enum variant that we define also becomes a function that constructs an instance of the enum</li><li>you can put any kind of data inside an enum variant: strings, numeric types, or structs, for example. You can even include another enum</li></ol><ul><li><p>The Option Enum</p><ol><li>the compiler can check whether you’ve handled all the cases you should be handling</li><li>a null is a value that is currently invalid or absent for some reason.</li><li>Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent.</li><li>The function Option::unwrap expects <em>self</em>, meaning it expects <em>ownership</em> of arg. However arg is an <em>immutable reference</em> to an option, so it cannot provide ownership of the option.</li></ol></li><li><p>match</p></li><li><p>Each match is tried from top to bottom</p></li><li><p>opt is a plain enum — its type is Option and not a reference like &amp;Option. Therefore a match on opt will move non-ignored fields like s.</p></li><li><p>If we want to peek into opt without moving its contents, the idiomatic solution is to match on a reference:</p></li><li><p><code>if let</code></p><ul><li>if let as syntax sugar for a match that runs code when the value matches one pattern and then ignores all other values.</li><li>The block of code that goes with the else is the same as the block of code that would go with the _ case in the match expression that is equivalent to the if let and else</li></ul></li></ul><h2 id=chapter7-managing-growing-projects-with-packages-crates-and-modules>Chapter7 Managing Growing Projects with Packages, Crates, and Modules<a hidden class=anchor aria-hidden=true href=#chapter7-managing-growing-projects-with-packages-crates-and-modules>¶</a></h2><h3 id=packages-a-cargo-feature-that-lets-you-build-test-and-share-crates>Packages: A Cargo feature that lets you build, test, and share crates<a hidden class=anchor aria-hidden=true href=#packages-a-cargo-feature-that-lets-you-build-test-and-share-crates>¶</a></h3><ul><li>a bundle of one or more crates that provides a set of functionality.</li><li>A package can contain as many binary crates as you like, but at most only one library crate.</li><li>Using External Packages<ol><li>the standard std library is also a crate that’s external to our package.we <em>don’t</em> need to change Cargo.toml to include std. But <em>we do need to refer to it</em> with use to bring items from there into our package’s scope</li></ol></li></ul><h3 id=crates-a-tree-of-modules-that-produces-a-library-or-executable>Crates: A tree of modules that produces a library or executable<a hidden class=anchor aria-hidden=true href=#crates-a-tree-of-modules-that-produces-a-library-or-executable>¶</a></h3><ul><li>Binary create: must have a function called <code>main</code></li><li>Library crates : define functionality intended to be shared with multiple projects.
Rustaceans say “crate”, they mean library crate, and they use “crate” interchangeably with the general programming concept of a <em>“library"</em>.</li></ul><h3 id=modules-and-use-let-you-control-the-organization-scope-and-privacy-of-paths>Modules and use: Let you control the organization, scope, and privacy of paths<a hidden class=anchor aria-hidden=true href=#modules-and-use-let-you-control-the-organization-scope-and-privacy-of-paths>¶</a></h3><ul><li>用处<ol><li>let us organize code within a crate for readability and easy reuse</li><li>allow us to control the privacy of items, because code within a module is private by default</li></ol></li><li>parent and child<ol><li>all items (functions, methods, structs, enums, modules, and constants) <em>are private to parent modules</em> by default.</li><li>Items in a parent module can’t use the private items inside child modules, but items in child modules can use the items in their ancestor modules.</li></ol></li></ul><h3 id=paths-a-way-of-naming-an-item-such-as-a-struct-function-or-module>Paths: A way of naming an item, such as a struct, function, or module<a hidden class=anchor aria-hidden=true href=#paths-a-way-of-naming-an-item-such-as-a-struct-function-or-module>¶</a></h3><ul><li>the idiomatic way<ol><li>Bringing the function’s parent module into scope with use</li><li>when bringing in structs, enums, and other items with use, it’s idiomatic to specify the full path</li></ol></li><li><code>use std::io::Result as IoResult;</code></li><li>we can use nested paths to bring the same items into scope in one line.<code>use std::{cmp::Ordering, io};</code>,<code>use std::io::{self, Write};</code></li></ul><h2 id=chapter8>Chapter8<a hidden class=anchor aria-hidden=true href=#chapter8>¶</a></h2><h3 id=vector>Vector<a hidden class=anchor aria-hidden=true href=#vector>¶</a></h3><ul><li>Reason for a reference to the first element care about changes at the end of the vector<ol><li>adding a new element onto the end of the vector might require allocating new memory and copying the old elements <em>to the new space</em></li><li>the reference to the first element would be pointing to <em>deallocated memory</em></li></ol></li><li>Vec::push moves its argument, so s is not usable after calling v.push(s)</li><li>When the vector gets dropped, all of its contents are also dropped, meaning the integers it holds will be cleaned up.</li></ul><h3 id=string>String<a hidden class=anchor aria-hidden=true href=#string>¶</a></h3><ul><li>the compiler can coerce the &amp;String argument into a &amp;str</li><li>Rust strings don’t support indexing to <em>avoid returning an unexpected value and causing bugs that might not be discovered immediately</em></li><li>three relevant ways to look at strings from Rust’s perspective<ol><li>bytes</li><li>scalar values</li><li>grapheme clusters</li></ol></li><li>The best way to operate on pieces of strings is to <em>be explicit about whether you want</em> characters or bytes</li><li>&amp;str is a promise that the byte sequence it points to will always be valid UTF-8</li></ul><h3 id=hash-map>hash map<a hidden class=anchor aria-hidden=true href=#hash-map>¶</a></h3><ul><li>Hash maps are useful when you want to look up data not by using an index, as you can with vectors, but by using a key that can be of any type</li><li>For types that implement the Copy trait, like i32, the values are copied into the hash map. - For <em>owned values</em> like String, the values will be moved and the hash map will be <em>the owner of those values</em></li></ul><h2 id=chapter10>chapter10<a hidden class=anchor aria-hidden=true href=#chapter10>¶</a></h2><h3 id=generic-data-types>Generic Data Types<a hidden class=anchor aria-hidden=true href=#generic-data-types>¶</a></h3><ul><li>Rust instead requires you to state the expected capabilities of generic types up front</li><li>Without restrictions, a generic type T has no capabilities: it cannot be printed, cloned, or mutated (although it can be dropped).</li><li>Rust does not have inheritance-like mechanisms for specializing methods as you might find in an object-oriented language,</li><li>Monomorphization is the process of turning generic code into specific code by filling in the concrete types that are used when compiled</li><li>const 泛型： <code>const N : usize</code></li></ul><h3 id=trait>trait<a hidden class=anchor aria-hidden=true href=#trait>¶</a></h3><ul><li>A trait defines functionality a particular type has and can share with other types.</li><li>One restriction to note is that we can implement a trait on a type only if at least one of the trait or the type is local to our crate.</li><li>Default implementations can call other methods in the same trait, even if those other methods don’t have a default implementation</li><li>traits in parameter<div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>some_function</span><span class=o>&lt;</span><span class=n>T</span>:<span class=nc>Display</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Clone</span><span class=w> </span><span class=p>,</span><span class=n>U</span>: <span class=nb>Clone</span> <span class=o>+</span><span class=w> </span><span class=n>Debug</span><span class=o>&gt;</span><span class=p>(</span><span class=n>t</span>:<span class=kp>&amp;</span><span class=nc>T</span><span class=p>,</span><span class=n>u</span>:<span class=kp>&amp;</span><span class=nc>U</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Clearer Trait Bounds with where Clauses
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>some_function</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=n>U</span><span class=o>&gt;</span><span class=p>()(</span><span class=n>t</span>:<span class=kp>&amp;</span><span class=nc>T</span><span class=p>,</span><span class=n>u</span>:<span class=kp>&amp;</span><span class=nc>U</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span>
</span></span><span class=line><span class=cl><span class=nc>where</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>T</span>:<span class=nc>Display</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Clone</span><span class=w> </span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>U</span>: <span class=nb>Clone</span> <span class=o>+</span><span class=w> </span><span class=n>Debug</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{}</span><span class=w>
</span></span></span></code></pre></div></li><li>can only use impl Trait if you’re returning a single type</li><li>Using Trait Bounds to Conditionally Implement Methods<div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>fmt</span>::<span class=n>Display</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>Pair</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>x</span>: <span class=nc>T</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>y</span>: <span class=nc>T</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>Pair</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>x</span>: <span class=nc>T</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>Self</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span>: <span class=nc>Display</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>PartialOrd</span><span class=o>&gt;</span><span class=w> </span><span class=n>Pair</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>cmp_display</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>x</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>y</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;The largest member is x = </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>x</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;The largest member is y = </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>y</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li><li>conditionally implement a trait for any type that implements another trait<div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span>: <span class=nc>Display</span><span class=o>&gt;</span><span class=w> </span><span class=nb>ToString</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>T</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// --snip--
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li></ul><h3 id=lifetime>lifetime<a hidden class=anchor aria-hidden=true href=#lifetime>¶</a></h3><ul><li>Lifetime annotations don’t change how long any of the references live. Rather, they describe the relationships of the lifetimes of multiple references to each other without affecting the lifetimes</li><li>the names of lifetime parameters must start with an apostrophe (&rsquo;) and are usually all lowercase and very short</li><li>when we specify the lifetime parameters in this function signature, we’re not changing the lifetimes of any values passed in or returned. Rather, we’re specifying that the borrow checker should reject any values that don’t adhere to these constraints.</li><li>in early versions (pre-1.0) of Rust,every reference needed an explicit lifetime</li><li>The compiler uses <em>three rules</em> to figure out the lifetimes of the references when there aren’t explicit annotations.<ol><li>the compiler assigns a different lifetime parameter to each lifetime in each input type.</li><li>if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters</li><li>if there are multiple input lifetime parameters, but one of them is <code>&amp;self</code> or <code>&amp;mut self</code> because this is a <em>method</em>, the lifetime of self is assigned to all output lifetime parameters.</li></ol></li><li>The Static Lifetime <code>'static</code><ul><li>The string literals is <em>stored directly in the program’s binary</em>, which is always available. Therefore, <em>the lifetime of all string literals is <code>'static</code>.</em></li><li>&lsquo;static means &ldquo;live for the entire program&rdquo;, and so data under a static reference must never be deallocated.</li></ul></li><li>生命周期标注并不会改变任何引用的实际作用域</li></ul><h2 id=chapter11>chapter11<a hidden class=anchor aria-hidden=true href=#chapter11>¶</a></h2><h3 id=the-output-from-running-the-automatically-generated-test>The output from running the automatically generated test<a hidden class=anchor aria-hidden=true href=#the-output-from-running-the-automatically-generated-test>¶</a></h3><ul><li>The 0 measured statistic is for benchmark tests that measure performance.</li><li><code>Doc-tests</code> is for the results of any documentation tests</li></ul><h3 id=常用命令>常用命令<a hidden class=anchor aria-hidden=true href=#常用命令>¶</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=fm>assert!</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>assert_ne</span><span class=o>!</span><span class=w> </span><span class=c1>//  will pass if the two values we give it are not equal and fail if they’re equal.
</span></span></span></code></pre></div><h3 id=running-tests-in-parallel-or-consecutively>Running Tests in Parallel or Consecutively<a hidden class=anchor aria-hidden=true href=#running-tests-in-parallel-or-consecutively>¶</a></h3><ul><li>When you run multiple tests, <em>by default</em> they run in parallel using threads</li><li><code>cargo test -- --test-threads=1</code></li><li><code>cargo test -- --show-output</code></li><li><code>cargo test --help</code></li><li><code>cargo test -- --help</code></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=cp>#[test]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[ignore]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>cargo</span><span class=w> </span><span class=n>test</span><span class=w> </span><span class=o>--</span><span class=w> </span><span class=o>--</span><span class=n>ignored</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>cargo</span><span class=w> </span><span class=n>test</span><span class=w> </span><span class=o>--</span><span class=w> </span><span class=o>--</span><span class=n>include</span><span class=o>-</span><span class=n>ignored</span><span class=w>
</span></span></span></code></pre></div></li><li>We can specify part of a test name, and <em>any test whose name matches that value</em> will be run.</li></ul><h3 id=test-organization>test-organization<a hidden class=anchor aria-hidden=true href=#test-organization>¶</a></h3><ul><li>Unit tests exercise different parts of a library separately and can test private implementation details.</li><li>Unit tests exercise different parts of a library separately and can test private implementation details.</li></ul><h2 id=chapter12>chapter12<a hidden class=anchor aria-hidden=true href=#chapter12>¶</a></h2><ul><li>in cases where the desired function is nested in more than one module, we’ve chosen to <em>bring the parent module into scope</em> rather than the function.</li><li>TDD(Test Driven Develop)</li><li>Write a test that fails and run it to make sure it fails for the reason you expect.</li><li>Write or modify just enough code to make the new test pass.</li><li>Refactor the code you just added or changed and make sure the tests continue to pass.</li><li>Repeat from step 1!</li></ul><h2 id=chapter13>chapter13<a hidden class=anchor aria-hidden=true href=#chapter13>¶</a></h2><ul><li>Rust will infer the types of arguments/returns for closures, but not top-level functions</li><li>Closures can capture values from their environment in three ways<ol><li>borrowing immutably</li><li>borrowing mutably</li><li>taking ownership.</li></ol></li><li>Fn traits<ol><li>FnOnce</li><li>FnMut</li><li>Fn</li></ol></li><li>iterator adaptors are lazy, and we need to consume the iterator here.</li></ul></div><footer class=post-footer><nav class=paginav><a class=prev href=https://euds63.github.io/2023/%E6%8D%A2%E5%9F%9F%E5%90%8D%E5%96%BD/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></svg>&nbsp;</span><br><span>换域名喽</span></a>
<a class=next href=https://euds63.github.io/2023/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/><span class=title>&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span><br><span>《操作系统：设计与实现》笔记</span></a></nav></footer><div class=comments-separator></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://euds63.github.io/>EuDs's Blog</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a></span>
<span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n=""=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script>
<script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a="1"=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script></body></html>