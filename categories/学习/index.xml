<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>学习 on EuDs&#39;s Blog</title>
    <link>https://euds63.github.io/categories/%E5%AD%A6%E4%B9%A0/</link>
    <description>Recent content in 学习 on EuDs&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 21 Oct 2023 12:50:17 +0800</lastBuildDate><atom:link href="https://euds63.github.io/categories/%E5%AD%A6%E4%B9%A0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>博客迁移记</title>
      <link>https://euds63.github.io/2023/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%AE%B0/</link>
      <pubDate>Sat, 21 Oct 2023 12:50:17 +0800</pubDate>
      
      <guid>https://euds63.github.io/2023/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%AE%B0/</guid>
      <description>nice to use Hugo</description>
      <content:encoded><![CDATA[<ol>
<li>尝试修改代码栏背景，无果</li>
<li>更换主题至<a href="https://reorx.github.io/hugo-PaperModX/"  target="_blank" rel="noopener" >PaperModX</a></li>
<li>设置文章中链接以新标签的方式打开
参考：<a href="https://dvel.me/posts/hugo-goldmark-markdown-new-tab/"  target="_blank" rel="noopener" >在 Hugo Goldmark Markdown 中设置以新标签打开链接 - Dvel&rsquo;s Blog</a></li>
<li>统一风格</li>
<li>使用<a href="https://www.jinrishici.com/"  target="_blank" rel="noopener" >今日诗词 - 一言API</a>作为slogan。步骤如下：
<ol>
<li>找到位置，发现位于<code>themes\PaperModX\layouts\partials\home_info.html</code></li>
<li>根据api文档添加调用代码</li>
</ol>
</li>
<li>参考<a href="https://www.sulvblog.cn/posts/blog/hugo_tag_cloud/"  target="_blank" rel="noopener" >Hugo博客添加标签云 | Sulv&rsquo;s Blog</a>美化标签页</li>
<li>添加archive页。步骤如下：
<ol>
<li>新增archive.md文件</li>
<li>在<code>themes\PaperModX\assets\css\common\archive.css</code>替换并添加相应代码
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-css" data-lang="css"><span class="line"><span class="cl">  <span class="p">.</span><span class="nc">archive-entry</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">position</span><span class="p">:</span> <span class="kc">relative</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="k">padding</span><span class="p">:</span> <span class="mi">5</span><span class="kt">px</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="k">margin</span><span class="p">:</span> <span class="mi">10</span><span class="kt">px</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="k">transition</span><span class="p">:</span> <span class="nf">var</span><span class="p">(</span><span class="o">--</span><span class="n">link</span><span class="o">-</span><span class="n">transition</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="c">/* 添加过渡效果，使颜色和阴影变化平滑 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="nc">archive-entry</span><span class="p">:</span><span class="nd">hover</span> <span class="p">.</span><span class="nc">archive-entry-title</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">color</span><span class="p">:</span> <span class="nf">var</span><span class="p">(</span><span class="o">--</span><span class="n">link</span><span class="o">-</span><span class="n">hover</span><span class="o">-</span><span class="kc">color</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="c">/* 鼠标悬停时的文字颜色 */</span>
</span></span><span class="line"><span class="cl">     <span class="k">box-shadow</span><span class="p">:</span> <span class="nf">var</span><span class="p">(</span><span class="o">--</span><span class="n">link</span><span class="o">-</span><span class="n">hover</span><span class="o">-</span><span class="kc">underline</span><span class="o">-</span><span class="n">shadow</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="c">/* 鼠标悬停时的下划线阴影效果 */</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="nc">archive-entry-title</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="k">margin</span><span class="p">:</span> <span class="mi">5</span><span class="kt">px</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="k">font-weight</span><span class="p">:</span> <span class="mi">400</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="k">transition</span><span class="p">:</span> <span class="nf">var</span><span class="p">(</span><span class="o">--</span><span class="n">link</span><span class="o">-</span><span class="n">transition</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="k">display</span><span class="p">:</span> <span class="kc">inline-block</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div></li>
</ol>
</li>
<li>添加搜索功能，步骤如下
<ol>
<li>新增search.md文件</li>
<li>在<code>hugo.yml</code>新增
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yml" data-lang="yml"><span class="line"><span class="cl"><span class="nt">outputs</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">home</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span>- <span class="l">HTML</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span>- <span class="l">RSS</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span>- <span class="l">JSON</span><span class="w"> </span><span class="c"># is necessary</span><span class="w">
</span></span></span></code></pre></div></li>
</ol>
</li>
<li>整合search,category,tags至discover，以使导航栏更为简洁，步骤如下
<ol>
<li>参考<a href="https://loyayz.com/website/220609-hugo-papermodx-tags-in-search-page/"  target="_blank" rel="noopener" >PaperMod 搜索页展示标签列表 | loyayz</a></li>
<li>修改对应标题、url</li>
<li>修改<code>themes\PaperModX\layouts\_default\search.html</code>中的代码</li>
</ol>
</li>
<li>修改profile-mode中的副标题为一言诗句，步骤如下:
<ol>
<li>找到对应位置<code>themes\PaperModX\layouts\partials\index_profile.html</code></li>
<li>参考第五步</li>
</ol>
</li>
<li>添加Records页面，步骤如下
<ol>
<li>参考<a href="https://eallion.com/neodb/#back-to-top"  target="_blank" rel="noopener" >NeoDB API 创建观影页面 - 大大的小蜗牛</a></li>
<li>添加<code>themes\PaperModX\layouts\_default\records.html</code>与<code>static\css\records.css</code></li>
<li>添加<code>content\records.md</code></li>
</ol>
</li>
<li>添加rss_subscription页面，步骤如下
<ol>
<li>大体上与第11步相同</li>
<li>在<code>themes\PaperModX\layouts\_default\single.html</code>的基础上进行修改，得到<code>themes\PaperModX\layouts\_default\rss_subscription.html</code></li>
</ol>
</li>
<li>部署
参考<a href="https://gohugo.io/hosting-and-deployment/hosting-on-github/"  target="_blank" rel="noopener" >Host on GitHub Pages | Hugo</a></li>
<li>添加social icons
参考<a href="https://adityatelange.github.io/hugo-PaperMod/posts/papermod/papermod-icons/"  target="_blank" rel="noopener" >Icons | PaperMod</a></li>
</ol>
<h2 id="待修复问题">待修复问题</h2>
<ol>
<li><input checked="" disabled="" type="checkbox"> 部署后<a href="https://ds63.eu.org/rss_subscription/"  target="_blank" rel="noopener" >My Rss Subscription | EuDs&rsquo;s Blog</a>无法正常显示</li>
<li><input checked="" disabled="" type="checkbox"> 网站icon时有时无</li>
</ol>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://liujiacai.net/blog/2020/12/05/hexo-to-hugo/#headline-3"  target="_blank" rel="noopener" >博客系统迁移：Hexo 到 Hugo</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1702561"  target="_blank" rel="noopener" >将hexo文章头转为hugo格式-腾讯云开发者社区-腾讯云</a></li>
<li><a href="https://io-oi.me/tech/hugo-vs-hexo/"  target="_blank" rel="noopener" >Hugo 与 Hexo 的异同 | reuixiy</a></li>
<li><a href="https://www.sulvblog.cn/posts/blog/hugo_toc_side/"  target="_blank" rel="noopener" >Hugo博客目录放在侧边 | PaperMod主题 | Sulv&rsquo;s Blog</a></li>
<li><a href="https://hugo.aiaide.com/post/hugo%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"  target="_blank" rel="noopener" >Hugo的工作原理 - Hugo 中文帮助文档</a></li>
<li><a href="https://www.sulvblog.cn/posts/blog/hugo_tag_cloud/"  target="_blank" rel="noopener" >Hugo博客添加标签云 | Sulv&rsquo;s Blog</a></li>
<li><a href="https://www.fusejs.io/api/options.html#keys"  target="_blank" rel="noopener" >Options | Fuse.js</a></li>
<li><a href="https://loyayz.com/website/220609-hugo-papermodx-tags-in-search-page/"  target="_blank" rel="noopener" >PaperMod 搜索页展示标签列表 | loyayz</a></li>
<li><a href="https://eallion.com/neodb/#back-to-top"  target="_blank" rel="noopener" >NeoDB API 创建观影页面 - 大大的小蜗牛</a></li>
<li><a href="https://gohugo.io/hosting-and-deployment/hosting-on-github/"  target="_blank" rel="noopener" >Host on GitHub Pages | Hugo</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>qqBot 搭建</title>
      <link>https://euds63.github.io/2023/qqbot-%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Wed, 11 Oct 2023 01:23:34 +0800</pubDate>
      
      <guid>https://euds63.github.io/2023/qqbot-%E6%90%AD%E5%BB%BA/</guid>
      <description>短时间内也不想再进一步折腾了</description>
      <content:encoded><![CDATA[<h1 id="qqbot-搭建">qqBot 搭建</h1>
<p><strong>这两天在搭qqBot，记录一下</strong></p>
<h2 id="整体技术">整体技术</h2>
<p>我使用的是<a href="https://github.com/Mrs4s/go-cqhttp"  target="_blank" rel="noopener" >go-cqhttp</a>和<a href="https://github.com/nonebot/nonebot2"  target="_blank" rel="noopener" >nonebot2</a>。</p>
<p>在遇到风控问题时，我使用了<a href="https://github.com/fuqiuluo/unidbg-fetch-qsign"  target="_blank" rel="noopener" >unidbg-fetch-qsign</a>。</p>
<h2 id="过程">过程</h2>
<ul>
<li>
<p>整个过程比我着手搭建前所想的要困难许多，踩了许多坑。不过很棒的一点是，这三个项目的issue都十分活跃。我踩的坑，在issue中几乎都能搜到。我使用过的开源项目不多，但这三个给了我很好的印象，希望自己以后能做些自己的贡献。</p>
</li>
<li>
<p>之前没想到最难的一点不是机器人程序的编写，而在于登录。我使用的号是新号（创建一个礼拜左右），风控等级比较高。</p>
</li>
</ul>
<p>而我的需求是：将bot部署在地点在非我所在地的一个服务器上，这更是增加了被风控的概率。</p>
<p>尝试许多种方法后，我最终的解决方法是：</p>
<ol>
<li>在本地先使用手表协议扫码登录。( <code>&quot;sort_version_name&quot;:8.9.73</code>,<code>protocol：2</code>)</li>
<li>成功登录后将得到的文件移至服务器上并配置<code>signsever</code>,再次进行登录</li>
</ol>
<ul>
<li>
<p>但最后bot还是被风控，无法发送群消息。</p>
<p>我短时间内也不想再进一步折腾了。</p>
</li>
<li>
<p>今天把自己写的插件<a href="https://github.com/EuDs63/nonebot-plugin-yesman"  target="_blank" rel="noopener" >EuDs63/nonebot-plugin-yesman: nonebot2 插件</a>发布到<a href="https://nonebot.dev/store/plugins"  target="_blank" rel="noopener" >插件商店 | NoneBot</a>了。过了一遍插件发布的流程，还蛮有意思的。有几点值得说下:</p>
<ol>
<li><a href="https://pypi.org/account/register/"  target="_blank" rel="noopener" >Create an account · PyPI</a>的username要求是我见过的最苛刻的。但也能理解。
<blockquote>
<p>Choose a strong password that contains letters (uppercase and lowercase), numbers and special characters. Avoid common words or repetition.</p>
</blockquote>
</li>
<li><a href="https://github.com/apps/noneflow"  target="_blank" rel="noopener" >About NoneFlow</a> 好强大。有机会想自己试试写一个类似的，或者了解是怎么做到的。</li>
</ol>
</li>
</ul>
<h2 id="感想">感想</h2>
<ol>
<li>想起搭telegram bot时，只需要申请一个token，甚至教程官方都有在写。而这里却是道高一尺魔高一丈般的猫鼠游戏。不免五味杂陈。</li>
<li>nonebot这种插件系统我觉得很棒。省了不少力气。</li>
<li>感觉qqBot可玩性还是蛮高的，在其他群里也常常能见到些有趣的bot。但可惜的是腾讯的态度。</li>
</ol>
<h2 id="收获">收获</h2>
<ol>
<li><code>nohup</code></li>
</ol>
<ul>
<li>使用: 例: <code>nphup nb run</code></li>
<li>关闭: 例:
<code>ps aux | grep `nb` #找到对应的进程号 kill $进程号</code></li>
</ul>
<ol start="2">
<li>
<p><code>守护进程（Systemd）</code></p>
<p><em>注：以下复制自<a href="https://blog.cysi.me/2022/04/make-a-qqbot.html#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8Bsystemd"  target="_blank" rel="noopener" >使用 NoneBot2 和 go-cqhttp 打造自己的 FF14 QQ 机器人</a></em></p>
<ul>
<li>创建</li>
</ul>
<pre tabindex="0"><code># vim /lib/systemd/system/go-cqhttp.service

    [Unit]
    Description=GO-CQHTTP
    Wants=network-online.target
    After=network-online.target
    [Service]
    Type=simple
    User=root
    WorkingDirectory= GO-CQHTTP的运行目录
    ExecStart= nohup go-cqhttp
    KillMode=process

    [Install]
    WantedBy=multi-user.target
</code></pre><ul>
<li>使用</li>
</ul>
<pre tabindex="0"><code>systemctl status go-cqhttp #查看状态
systemctl enable go-cqhttp #启用开机自启
systemctl restart go-cqhttp #重启进程
systemctl stop go-cqhttp #停止进程
systemctl start go-cqhttp #开始进程
</code></pre></li>
<li>
<p>python虚拟环境</p>
<ul>
<li>新建</li>
</ul>
<pre tabindex="0"><code>python -m venv myenv # 创建一个名为myenv的虚拟环境
</code></pre><ul>
<li>激活</li>
</ul>
<pre tabindex="0"><code>source ./qqVenv/bin/activate # bash

source ./qqVenv/bin/activate.fish # fish
</code></pre></li>
</ol>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://github.com/nonebot/nonebot2"  target="_blank" rel="noopener" >nonebot/nonebot2: 跨平台 Python 异步聊天机器人框架 / Asynchronous multi-platform chatbot framework written in Python</a></li>
<li><a href="https://github.com/fuqiuluo/unidbg-fetch-qsign"  target="_blank" rel="noopener" >fuqiuluo/unidbg-fetch-qsign: 获取QQSign通过Unidbg</a></li>
<li><a href="https://blog.cysi.me/2022/04/make-a-qqbot.html#%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6"  target="_blank" rel="noopener" >使用 NoneBot2 和 go-cqhttp 打造自己的 FF14 QQ 机器人</a></li>
<li><a href="https://github.com/Mrs4s/go-cqhttp"  target="_blank" rel="noopener" >Mrs4s/go-cqhttp: cqhttp的golang实现，轻量、原生跨平台.</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>服务器迁移记</title>
      <link>https://euds63.github.io/2023/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%81%E7%A7%BB%E8%AE%B0/</link>
      <pubDate>Sat, 07 Oct 2023 19:32:21 +0800</pubDate>
      
      <guid>https://euds63.github.io/2023/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%81%E7%A7%BB%E8%AE%B0/</guid>
      <description>虽然早就知道是这样。但是这次还是第一次这么切身地体验到。很感慨。</description>
      <content:encoded><![CDATA[<h2 id="起因">起因</h2>
<p>我之前使用的是阿里云的ecs。因为要到期了，而续费又过于昂贵。（2核2g一年要六百多。）</p>
<p>对比了下几家云服务器提供商，发现华为云价格最为理想（2核2g3M带宽一年89）。</p>
<h2 id="迁移过程">迁移过程</h2>
<p>我其实并没有用服务器来做多少事情。主要就两个：telegram bot和ttrss。它们都是使用docker进行部署的，所以能省不少事。</p>
<ol>
<li>docker安装
没想到第一步安装docker就花了一晚上。3m的带宽，下载时只有可怜的十几kb。等到最后还下不了。</li>
</ol>
<p>最后我是自己手动下载软件包，再安装的。</p>
<pre tabindex="0"><code># “package.deb”为下载的软件包
sudo dpkg -i /path/to/package.deb
</code></pre><p>我其实应该一开始就去配置镜像源的&hellip;</p>
<ol start="2">
<li>
<p>设置网络
<a href="https://ds63.eu.org/2023/03/11/network/"  target="_blank" rel="noopener" >network - EuDs&rsquo;s blog</a></p>
</li>
<li>
<p>Faye_Bot
<a href="https://github.com/EuDs63/Faye_Bot"  target="_blank" rel="noopener" >EuDs63/Faye_Bot: my telegram Bot</a></p>
</li>
<li>
<p>ttrss</p>
</li>
</ol>
<ul>
<li><a href="https://ds63.eu.org/2023/03/08/RssTossing/"  target="_blank" rel="noopener" >RSS折腾记 - EuDs&rsquo;s blog</a></li>
<li><a href="https://ttrss.henry.wang/zh/#%E5%85%B3%E4%BA%8E"  target="_blank" rel="noopener" >🐋 Awesome TTRSS </a></li>
</ul>
<h2 id="尾巴">尾巴</h2>
<p>本来没打算再买一个服务器的。因为vscode+WSL2其实已经满足我绝大部分的linux使用需求了。但想着说不定呢？以后哪天就有需求了。而那时候再重新搭环境，没了现有的作参考，怕是要发更多的时间，于是还是买了。</p>
<p>还是要想办法用起来。</p>
<h2 id="尾巴的尾巴">尾巴的尾巴</h2>
<p>没想到这么快就又有了一个服务器。今天（隔天）逛博客看到Azure学生包注册教程。想着之前也有试着搞过，但不知道为什么没成功。今天抱着试一试的想法，就又点进去。没想到直接就成了。</p>
<p>于是参考<a href="https://zbttl-github-io.vercel.app/github-xue-sheng-bao-he-azure-yang-mao/"  target="_blank" rel="noopener" >github 学生包和 azure 羊毛</a>，申请了台linux虚拟机。还是用的ubuntu的镜像。</p>
<p>结果十分地流畅。安装docker不到三分钟，也不需要额外配置什么代理。昨天没成功的<a href="https://github.com/yihong0618/tg_bing_dalle"  target="_blank" rel="noopener" >yihong0618/tg_bing_dalle: tg bing dalle-3</a>也成了。</p>
<p>虽然早就知道是这样。但是这次还是第一次这么切身地体验到。很感慨。</p>
<h2 id="参考链接">参考链接</h2>
<ul>
<li><a href="https://zbttl-github-io.vercel.app/github-xue-sheng-bao-he-azure-yang-mao/"  target="_blank" rel="noopener" >github 学生包和 azure 羊毛</a></li>
<li><a href="https://github.com/yihong0618/tg_bing_dalle"  target="_blank" rel="noopener" >yihong0618/tg_bing_dalle: tg bing dalle-3</a></li>
<li><a href="https://ttrss.henry.wang/zh/#%E5%85%B3%E4%BA%8E"  target="_blank" rel="noopener" >🐋 Awesome TTRSS </a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>换域名喽</title>
      <link>https://euds63.github.io/2023/%E6%8D%A2%E5%9F%9F%E5%90%8D%E5%96%BD/</link>
      <pubDate>Thu, 17 Aug 2023 23:50:11 +0800</pubDate>
      
      <guid>https://euds63.github.io/2023/%E6%8D%A2%E5%9F%9F%E5%90%8D%E5%96%BD/</guid>
      <description>更换域名为ds63.eu.org</description>
      <content:encoded><![CDATA[<h2 id="缘起">缘起</h2>
<p>我博客有相当一段时间，一直是使用默认的域名。而且我其实并不太想去修改，原因是我博客使用的是Github Page。我想信：背靠着微软，GitHub所提供的这项服务的可靠性会比我私人所申请的域名要可靠得多。而我一直秉持着这样一个观点：一个博客的死亡并不是其不再更新，而是无法访问。也就是说，我认为博客的持续性是要优先于其他很多方面的。</p>
<p>但今天意外发现邮箱里有封邮件，通知我说申请的域名通过了。十分惊喜，因为我已经忘了这件事了。既然手头上有一个域名，上学期也学了相关的知识，干脆就试一试，在此次梳理下相应的步骤。</p>
<h2 id="步骤">步骤</h2>
<ol>
<li>
<p>申请/购买域名</p>
<p>我使用的是<a href="https://nic.eu.org/"  target="_blank" rel="noopener" >EU.org</a>。好处是免费，但所需时间很长。我在5月27日申请的，直到昨天（8月16日）才通过。</p>
</li>
<li>
<p>选择域名解析服务商</p>
<p>我选择的是<a href="https://hostry.com/"  target="_blank" rel="noopener" >hostry</a>,原因是免费。</p>
</li>
<li>
<p>Navigate to your DNS provider and create either an ALIAS, ANAME, or A record.</p>
<p>以下是我设置中的一部分：</p>
<table>
<thead>
<tr>
<th>SUBDOMAIN</th>
<th>TYPE</th>
<th>VALUE</th>
<th>TTL, SEC</th>
</tr>
</thead>
<tbody>
<tr>
<td>@</td>
<td>A</td>
<td>185.199.108.153</td>
<td>86400</td>
</tr>
<tr>
<td>@</td>
<td>AAAA</td>
<td>2606:50c0:8000::153</td>
<td>86400</td>
</tr>
<tr>
<td>www</td>
<td>CNAME</td>
<td>euds63.github.io</td>
<td>86400</td>
</tr>
</tbody>
</table>
</li>
</ol>
<p>在Claude的帮助下，我知道：</p>
<ul>
<li>A记录(Address Record):将域名直接映射到一个IPv4地址。它是最基本的域名记录类型。GitHub提供了4个IP地址,而不是一个IP,主要出于负载均衡和容错的考虑</li>
<li>AAAA记录(Quad-A record):用于将域名映射到IPv6地址。</li>
<li>CNAME记录(Canonical Name Record):将域名映射到另一个域名,实现域名别名的作用</li>
</ul>
<p>值得注意的是<code>www CNAME euds63.github.io 86400</code>，我看到其他的教程有的是将SUBDOMAIN设置为<code>@</code>,但我的情况下会报错<code>Existing record 'SOA' conflicts with the code you are trying to create Cname should not have the same name as other records</code></p>
<ol start="4">
<li>Github配置
<ul>
<li>Under &ldquo;Custom domain&rdquo;, type your custom domain, then click Save.</li>
<li>勾选Enforce HTTPS</li>
</ul>
</li>
</ol>
<p><strong>很明显，这里Github帮我们简化了许多操作。包括哪些呢?</strong></p>
<p>由<a href="https://docs.github.com/en/pages/getting-started-with-github-pages/securing-your-github-pages-site-with-https"  target="_blank" rel="noopener" >Securing your GitHub Pages site with HTTPS</a>可知，当set or change your custom domain in the Pages setting后，GitHub</p>
<ol>
<li>begin an automatic DNS check . This check determines if your DNS settings are configured to allow GitHub to obtain a certificate automatically.</li>
<li>If the check is successful, GitHub queues a job to request a TLS certificate from Let&rsquo;s Encrypt.</li>
<li>On receiving a valid certificate, GitHub automatically uploads it to the servers that handle TLS termination for Pages. When this process completes successfully, a check mark is displayed beside your custom domain name.</li>
</ol>
<p><strong>但如果不是用的Github Page，要怎么做呢？</strong></p>
<h2 id="验证">验证</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ ping ds63.eu.org
</span></span><span class="line"><span class="cl">正在 Ping ds63.eu.org <span class="o">[</span>185.199.108.153<span class="o">]</span> 具有 <span class="m">32</span> 字节的数据:
</span></span><span class="line"><span class="cl">来自 185.199.108.153 的回复: <span class="nv">字节</span><span class="o">=</span><span class="m">32</span> <span class="nv">时间</span><span class="o">=</span>77ms <span class="nv">TTL</span><span class="o">=</span><span class="m">54</span>
</span></span><span class="line"><span class="cl">来自 185.199.108.153 的回复: <span class="nv">字节</span><span class="o">=</span><span class="m">32</span> <span class="nv">时间</span><span class="o">=</span>103ms <span class="nv">TTL</span><span class="o">=</span><span class="m">54</span>
</span></span><span class="line"><span class="cl">来自 185.199.108.153 的回复: <span class="nv">字节</span><span class="o">=</span><span class="m">32</span> <span class="nv">时间</span><span class="o">=</span>76ms <span class="nv">TTL</span><span class="o">=</span><span class="m">54</span>
</span></span><span class="line"><span class="cl">来自 185.199.108.153 的回复: <span class="nv">字节</span><span class="o">=</span><span class="m">32</span> <span class="nv">时间</span><span class="o">=</span>77ms <span class="nv">TTL</span><span class="o">=</span><span class="m">54</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">185.199.108.153 的 Ping 统计信息:
</span></span><span class="line"><span class="cl">    数据包: <span class="nv">已发送</span> <span class="o">=</span> 4，已接收 <span class="o">=</span> 4，丢失 <span class="o">=</span> <span class="m">0</span> <span class="o">(</span>0% 丢失<span class="o">)</span>，
</span></span><span class="line"><span class="cl">往返行程的估计时间<span class="o">(</span>以毫秒为单位<span class="o">)</span>:
</span></span><span class="line"><span class="cl">    <span class="nv">最短</span> <span class="o">=</span> 76ms，最长 <span class="o">=</span> 103ms，平均 <span class="o">=</span> 83ms
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ ping -6 ds63.eu.org
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">正在 Ping ds63.eu.org <span class="o">[</span>2606:50c0:8001::153<span class="o">]</span> 具有 <span class="m">32</span> 字节的数据:
</span></span><span class="line"><span class="cl">来自 2606:50c0:8001::153 的回复: <span class="nv">时间</span><span class="o">=</span>74ms
</span></span><span class="line"><span class="cl">来自 2606:50c0:8001::153 的回复: <span class="nv">时间</span><span class="o">=</span>81ms
</span></span><span class="line"><span class="cl">来自 2606:50c0:8001::153 的回复: <span class="nv">时间</span><span class="o">=</span>74ms
</span></span><span class="line"><span class="cl">来自 2606:50c0:8001::153 的回复: <span class="nv">时间</span><span class="o">=</span>72ms
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">2606:50c0:8001::153 的 Ping 统计信息:
</span></span><span class="line"><span class="cl">    数据包: <span class="nv">已发送</span> <span class="o">=</span> 4，已接收 <span class="o">=</span> 4，丢失 <span class="o">=</span> <span class="m">0</span> <span class="o">(</span>0% 丢失<span class="o">)</span>，
</span></span><span class="line"><span class="cl">往返行程的估计时间<span class="o">(</span>以毫秒为单位<span class="o">)</span>:
</span></span><span class="line"><span class="cl">    <span class="nv">最短</span> <span class="o">=</span> 72ms，最长 <span class="o">=</span> 81ms，平均 <span class="o">=</span> 75ms
</span></span></code></pre></div><h1 id="参考资料">参考资料</h1>
<ul>
<li><a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site"  target="_blank" rel="noopener" >Managing a custom domain for your GitHub Pages site</a></li>
<li><a href="https://www.yong.eu.org/detail/15112.html"  target="_blank" rel="noopener" >GitHub Pages绑定个人域名并启用https</a></li>
<li><a href="https://docs.github.com/en/pages/getting-started-with-github-pages/securing-your-github-pages-site-with-https"  target="_blank" rel="noopener" >Securing your GitHub Pages site with HTTPS</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Rust_Learning</title>
      <link>https://euds63.github.io/2023/rust_learning/</link>
      <pubDate>Tue, 18 Jul 2023 16:25:21 +0800</pubDate>
      
      <guid>https://euds63.github.io/2023/rust_learning/</guid>
      <description>no panic</description>
      <content:encoded><![CDATA[<h1 id="rust_learning">Rust_Learning</h1>
<p><strong>记录我的Rust学习</strong></p>
<h2 id="cargo使用">Cargo使用</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">cargo new
</span></span><span class="line"><span class="cl">cargo build 
</span></span><span class="line"><span class="cl">cargo run
</span></span><span class="line"><span class="cl">cargo check
</span></span><span class="line"><span class="cl">cargo doc --open <span class="c1">#build documentation provided by all your dependencies locally and open it in your browser</span>
</span></span></code></pre></div><h2 id="参考链接">参考链接</h2>
<ul>
<li><a href="https://course.rs/"  target="_blank" rel="noopener" >Rust语言圣经</a></li>
<li><a href="https://rust-book.cs.brown.edu/"  target="_blank" rel="noopener" >The Rust Programming Language</a></li>
<li><a href="https://zh.practice.rs/"  target="_blank" rel="noopener" >Rust语言实战</a></li>
<li><a href="https://picklenerd.github.io/"  target="_blank" rel="noopener" >PNGme</a></li>
</ul>
<h2 id="rust特点">Rust特点</h2>
<ul>
<li>Patterns and the match construct</li>
<li>a strong, static type system.</li>
<li>type inference</li>
<li>shadow</li>
<li>Rust uses the term panicking when a program exits with an error</li>
<li>requiring type annotations in function definitions</li>
<li>Rust&rsquo;s goal is to compile programs into efficient binaries that <em>require as few runtime checks as possible</em></li>
<li>A foundational goal of Rust is to ensure that your programs never have undefined behavior</li>
</ul>
<h2 id="chapter3-common-programming-concepts">Chapter3 Common Programming Concepts</h2>
<ul>
<li>constant v.s. variable
<ol>
<li>Constants aren’t just immutable by default;they’re always immutable.</li>
<li>Constants can be declared in any scope</li>
<li>Constants may be set only to a constant expression, not the result of a value that could only be computed at runtime.</li>
</ol>
</li>
<li>shadow ends until
<ol>
<li>it itself is shadowed</li>
<li>the scope ends</li>
</ol>
</li>
<li>Integer division truncates toward zero to the nearest integer</li>
<li>tuple和array区别
<ol>
<li>tuple的各类型可以不同；</li>
<li>array的大小固定,在定义时就指定了</li>
<li>tuple更灵活,可存储不同类型,一般用于临时组合数据</li>
<li>array大小固定,用于存储大量相同类型的数据</li>
</ol>
</li>
<li>expression and statement
<ol>
<li>Expressions do not include ending semicolons</li>
<li>statement does not return a value</li>
<li>the return value of the function is synonymous with <em>the value of the final expression in the block of the body of a function</em></li>
</ol>
</li>
<li>Control Flow
<ol>
<li>This means the values that have the potential to be results from each arm of the if must be the same type</li>
<li>Rust does not have a concept of &ldquo;truthy&rdquo; or &ldquo;falsy&rdquo; values.So <em>The condition to an if-expression must be a boolean</em></li>
</ol>
</li>
</ul>
<h2 id="chapter4-understanding-ownship">Chapter4 Understanding Ownship</h2>
<ul>
<li>The stack holds data associated with a specific function, while the heap holds data that can outlive a function</li>
<li>Rust does not allow programs to manually deallocate memory. That policy avoids the kinds of undefined behaviors shown above.</li>
<li>Box deallocation principle : If a variable owns a box, when Rust deallocates the variable&rsquo;s frame, then Rust deallocates the box&rsquo;s heap memory.</li>
<li>Moved heap data principle: if a variable x moves ownership of heap data to another variable y, then x cannot be used after the move.</li>
<li>A reference is a kind of pointer.</li>
<li>Rust implicitly inserts dereferences and references in certain cases, such as calling a method with the dot operator</li>
<li><em>Pointer Safety Principle</em>: data should never be aliased and mutated at the same time.</li>
<li>Permissions are defined on <em>paths</em> and not just variables. A path is anything you can put on the left-hand side of an assignment.</li>
<li>Creating a reference to data (&quot;<em>borrowing</em>&quot; it) causes that data to be temporarily read-only until the reference is no longer used.</li>
<li>Rust&rsquo;s borrow checker does not contain different paths for a[0], a[1], and so on. It uses a single path a[_] that represents all indexes of a.</li>
<li>Slices are special kinds of references because they are &ldquo;fat&rdquo; pointers, or pointers with metadata. Here, the metadata is the length of the slice.</li>
</ul>
<h3 id="总结">总结</h3>
<ul>
<li>优势
<ol>
<li>improving runtime performance by avoiding garbage collection</li>
<li>improving predictability by preventing accidental &ldquo;leaks&rdquo; of data.</li>
</ol>
</li>
<li>Pointers can be created through
<ol>
<li>boxes (pointers owning data on the heap)</li>
<li>references (non-owning pointers).</li>
</ol>
</li>
<li>move v.s. borrow
<ul>
<li>A move of a variable with a non-copyable type (like Box<!-- raw HTML omitted --> or String) requires the RO permissions, and the move eliminates all permissions on the variable. That rule prevents the use of moved variables:</li>
<li>Borrowing a variable (creating a reference to it) temporarily removes some of the variable&rsquo;s permissions
<ul>
<li>An immutable borrow creates an immutable reference, and also <em>disables the borrowed data from being mutated or moved.</em></li>
<li>A mutable borrow creates a mutable reference, which* disables the borrowed data from being read, written, or moved*</li>
</ul>
</li>
</ul>
</li>
<li>use-after-free: <em>Immutable borrows</em> remove the W permission to avoid use-after-free,</li>
<li>double-frees: Dereferences of references to non-copyable data do not have the O permission to avoid double-frees</li>
</ul>
<h2 id="chapter5-struct">Chapter5 Struct</h2>
<ul>
<li>Rust <em>does not have a keyword for constructor functions</em>. The idiomatic way to define a constructor function is to make an associated function called new, but that is not enforced by the language.</li>
<li>tuple struct. e.g. <code>struct Color (i32,i32,i32);</code></li>
<li>Rust will insert as many references and dereferences as needed to make the types match up for the self parameter</li>
<li>Rust does not auto-derive Copy for stability across API changes. <code>#[derive(Copy, Clone)]</code></li>
<li>when you see an error like &ldquo;cannot move out of *self&rdquo;, that&rsquo;s usually because you&rsquo;re trying to call a self method on a reference like &amp;self or &amp;mut self. Rust is protecting you from a double-free</li>
</ul>
<h2 id="chapter6-enum">Chapter6 Enum</h2>
<ul>
<li>advantage to using an enum rather than a struct:</li>
</ul>
<ol>
<li>each variant can have different types and amounts of associated data</li>
<li>the name of each enum variant that we define also becomes a function that constructs an instance of the enum</li>
<li>you can put any kind of data inside an enum variant: strings, numeric types, or structs, for example. You can even include another enum</li>
</ol>
<ul>
<li>
<p>The Option Enum</p>
<ol>
<li>the compiler can check whether you’ve handled all the cases you should be handling</li>
<li>a null is a value that is currently invalid or absent for some reason.</li>
<li>Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent.</li>
<li>The function Option::unwrap expects <em>self</em>, meaning it expects <em>ownership</em> of arg. However arg is an <em>immutable reference</em> to an option, so it cannot provide ownership of the option.</li>
</ol>
</li>
<li>
<p>match</p>
</li>
<li>
<p>Each match is tried from top to bottom</p>
</li>
<li>
<p>opt is a plain enum — its type is Option<!-- raw HTML omitted --> and not a reference like &amp;Option<!-- raw HTML omitted -->. Therefore a match on opt will move non-ignored fields like s.</p>
</li>
<li>
<p>If we want to peek into opt without moving its contents, the idiomatic solution is to match on a reference:</p>
</li>
<li>
<p><code>if let</code></p>
<ul>
<li>if let as syntax sugar for a match that runs code when the value matches one pattern and then ignores all other values.</li>
<li>The block of code that goes with the else is the same as the block of code that would go with the _ case in the match expression that is equivalent to the if let and else</li>
</ul>
</li>
</ul>
<h2 id="chapter7-managing-growing-projects-with-packages-crates-and-modules">Chapter7 Managing Growing Projects with Packages, Crates, and Modules</h2>
<h3 id="packages-a-cargo-feature-that-lets-you-build-test-and-share-crates">Packages: A Cargo feature that lets you build, test, and share crates</h3>
<ul>
<li>a bundle of one or more crates that provides a set of functionality.</li>
<li>A package can contain as many binary crates as you like, but at most only one library crate.</li>
<li>Using External Packages
<ol>
<li>the standard std library is also a crate that’s external to our package.we <em>don’t</em> need to change Cargo.toml to include std. But <em>we do need to refer to it</em> with use to bring items from there into our package’s scope</li>
</ol>
</li>
</ul>
<h3 id="crates-a-tree-of-modules-that-produces-a-library-or-executable">Crates: A tree of modules that produces a library or executable</h3>
<ul>
<li>Binary create: must have a function called <code>main</code></li>
<li>Library crates : define functionality intended to be shared with multiple projects.
Rustaceans say “crate”, they mean library crate, and they use “crate” interchangeably with the general programming concept of a <em>“library&quot;</em>.</li>
</ul>
<h3 id="modules-and-use-let-you-control-the-organization-scope-and-privacy-of-paths">Modules and use: Let you control the organization, scope, and privacy of paths</h3>
<ul>
<li>用处
<ol>
<li>let us organize code within a crate for readability and easy reuse</li>
<li>allow us to control the privacy of items, because code within a module is private by default</li>
</ol>
</li>
<li>parent and child
<ol>
<li>all items (functions, methods, structs, enums, modules, and constants) <em>are private to parent modules</em> by default.</li>
<li>Items in a parent module can’t use the private items inside child modules, but items in child modules can use the items in their ancestor modules.</li>
</ol>
</li>
</ul>
<h3 id="paths-a-way-of-naming-an-item-such-as-a-struct-function-or-module">Paths: A way of naming an item, such as a struct, function, or module</h3>
<ul>
<li>the idiomatic way
<ol>
<li>Bringing the function’s parent module into scope with use</li>
<li>when bringing in structs, enums, and other items with use, it’s idiomatic to specify the full path</li>
</ol>
</li>
<li><code>use std::io::Result as IoResult;</code></li>
<li>we can use nested paths to bring the same items into scope in one line.<code>use std::{cmp::Ordering, io};</code>,<code>use std::io::{self, Write};</code></li>
</ul>
<h2 id="chapter8">Chapter8</h2>
<h3 id="vector">Vector</h3>
<ul>
<li>Reason for a reference to the first element care about changes at the end of the vector
<ol>
<li>adding a new element onto the end of the vector might require allocating new memory and copying the old elements <em>to the new space</em></li>
<li>the reference to the first element would be pointing to <em>deallocated memory</em></li>
</ol>
</li>
<li>Vec::push moves its argument, so s is not usable after calling v.push(s)</li>
<li>When the vector gets dropped, all of its contents are also dropped, meaning the integers it holds will be cleaned up.</li>
</ul>
<h3 id="string">String</h3>
<ul>
<li>the compiler can coerce the &amp;String argument into a &amp;str</li>
<li>Rust strings don’t support indexing to <em>avoid returning an unexpected value and causing bugs that might not be discovered immediately</em></li>
<li>three relevant ways to look at strings from Rust’s perspective
<ol>
<li>bytes</li>
<li>scalar values</li>
<li>grapheme clusters</li>
</ol>
</li>
<li>The best way to operate on pieces of strings is to <em>be explicit about whether you want</em> characters or bytes</li>
<li>&amp;str is a promise that the byte sequence it points to will always be valid UTF-8</li>
</ul>
<h3 id="hash-map">hash map</h3>
<ul>
<li>Hash maps are useful when you want to look up data not by using an index, as you can with vectors, but by using a key that can be of any type</li>
<li>For types that implement the Copy trait, like i32, the values are copied into the hash map. - For <em>owned values</em> like String, the values will be moved and the hash map will be <em>the owner of those values</em></li>
</ul>
<h2 id="chapter10">chapter10</h2>
<h3 id="generic-data-types">Generic Data Types</h3>
<ul>
<li>Rust instead requires you to state the expected capabilities of generic types up front</li>
<li>Without restrictions, a generic type T has no capabilities: it cannot be printed, cloned, or mutated (although it can be dropped).</li>
<li>Rust does not have inheritance-like mechanisms for specializing methods as you might find in an object-oriented language,</li>
<li>Monomorphization is the process of turning generic code into specific code by filling in the concrete types that are used when compiled</li>
<li>const 泛型： <code>const N : usize</code></li>
</ul>
<h3 id="trait">trait</h3>
<ul>
<li>A trait defines functionality a particular type has and can share with other types.</li>
<li>One restriction to note is that we can implement a trait on a type only if at least one of the trait or the type is local to our crate.</li>
<li>Default implementations can call other methods in the same trait, even if those other methods don’t have a default implementation</li>
<li>traits in parameter
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">some_function</span><span class="o">&lt;</span><span class="n">T</span>:<span class="nc">Display</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Clone</span><span class="w"> </span><span class="p">,</span><span class="n">U</span>: <span class="nb">Clone</span> <span class="o">+</span><span class="w"> </span><span class="n">Debug</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>:<span class="kp">&amp;</span><span class="nc">T</span><span class="p">,</span><span class="n">u</span>:<span class="kp">&amp;</span><span class="nc">U</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Clearer Trait Bounds with where Clauses
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span> <span class="nf">some_function</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">t</span>:<span class="kp">&amp;</span><span class="nc">T</span><span class="p">,</span><span class="n">u</span>:<span class="kp">&amp;</span><span class="nc">U</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span>
</span></span><span class="line"><span class="cl"><span class="nc">where</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">T</span>:<span class="nc">Display</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Clone</span><span class="w"> </span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">U</span>: <span class="nb">Clone</span> <span class="o">+</span><span class="w"> </span><span class="n">Debug</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{}</span><span class="w">
</span></span></span></code></pre></div></li>
<li>can only use impl Trait if you’re returning a single type</li>
<li>Using Trait Bounds to Conditionally Implement Methods
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span>::<span class="n">Display</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">x</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">y</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Pair</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">x</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Display</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">PartialOrd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Pair</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">cmp_display</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The largest member is x = </span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The largest member is y = </span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
<li>conditionally implement a trait for any type that implements another trait
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Display</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">ToString</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">// --snip--
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<h3 id="lifetime">lifetime</h3>
<ul>
<li>Lifetime annotations don’t change how long any of the references live. Rather, they describe the relationships of the lifetimes of multiple references to each other without affecting the lifetimes</li>
<li>the names of lifetime parameters must start with an apostrophe (&rsquo;) and are usually all lowercase and very short</li>
<li>when we specify the lifetime parameters in this function signature, we’re not changing the lifetimes of any values passed in or returned. Rather, we’re specifying that the borrow checker should reject any values that don’t adhere to these constraints.</li>
<li>in early versions (pre-1.0) of Rust,every reference needed an explicit lifetime</li>
<li>The compiler uses <em>three rules</em> to figure out the lifetimes of the references when there aren’t explicit annotations.
<ol>
<li>the compiler assigns a different lifetime parameter to each lifetime in each input type.</li>
<li>if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters</li>
<li>if there are multiple input lifetime parameters, but one of them is <code>&amp;self</code> or <code>&amp;mut self</code> because this is a <em>method</em>, the lifetime of self is assigned to all output lifetime parameters.</li>
</ol>
</li>
<li>The Static Lifetime <code>'static</code>
<ul>
<li>The string literals is <em>stored directly in the program’s binary</em>, which is always available. Therefore, <em>the lifetime of all string literals is <code>'static</code>.</em></li>
<li>&lsquo;static means &ldquo;live for the entire program&rdquo;, and so data under a static reference must never be deallocated.</li>
</ul>
</li>
<li>生命周期标注并不会改变任何引用的实际作用域</li>
</ul>
<h2 id="chapter11">chapter11</h2>
<h3 id="the-output-from-running-the-automatically-generated-test">The output from running the automatically generated test</h3>
<ul>
<li>The 0 measured statistic is for benchmark tests that measure performance.</li>
<li><code>Doc-tests</code>  is for the results of any documentation tests</li>
</ul>
<h3 id="常用命令">常用命令</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="line"><span class="cl"><span class="fm">assert!</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="fm">assert_eq!</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">assert_ne</span><span class="o">!</span><span class="w"> </span><span class="c1">//  will pass if the two values we give it are not equal and fail if they’re equal.
</span></span></span></code></pre></div><h3 id="running-tests-in-parallel-or-consecutively">Running Tests in Parallel or Consecutively</h3>
<ul>
<li>When you run multiple tests, <em>by default</em> they run in parallel using threads</li>
<li><code>cargo test -- --test-threads=1</code></li>
<li><code>cargo test -- --show-output</code></li>
<li><code>cargo test --help</code></li>
<li><code>cargo test -- --help</code></li>
<li>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="line"><span class="cl"><span class="cp">#[test]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[ignore]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">cargo</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="o">--</span><span class="w"> </span><span class="o">--</span><span class="n">ignored</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">cargo</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="o">--</span><span class="w"> </span><span class="o">--</span><span class="n">include</span><span class="o">-</span><span class="n">ignored</span><span class="w">
</span></span></span></code></pre></div></li>
<li>We can specify part of a test name, and <em>any test whose name matches that value</em> will be run.</li>
</ul>
<h3 id="test-organization">test-organization</h3>
<ul>
<li>Unit tests exercise different parts of a library separately and can test private implementation details.</li>
<li>Unit tests exercise different parts of a library separately and can test private implementation details.</li>
</ul>
<h2 id="chapter12">chapter12</h2>
<ul>
<li>in cases where the desired function is nested in more than one module, we’ve chosen to <em>bring the parent module into scope</em> rather than the function.</li>
<li>TDD(Test Driven Develop)</li>
<li>Write a test that fails and run it to make sure it fails for the reason you expect.</li>
<li>Write or modify just enough code to make the new test pass.</li>
<li>Refactor the code you just added or changed and make sure the tests continue to pass.</li>
<li>Repeat from step 1!</li>
</ul>
<h2 id="chapter13">chapter13</h2>
<ul>
<li>Rust will infer the types of arguments/returns for closures, but not top-level functions</li>
<li>Closures can capture values from their environment in three ways
<ol>
<li>borrowing immutably</li>
<li>borrowing mutably</li>
<li>taking ownership.</li>
</ol>
</li>
<li>Fn traits
<ol>
<li>FnOnce</li>
<li>FnMut</li>
<li>Fn</li>
</ol>
</li>
<li>iterator adaptors are lazy, and we need to consume the iterator here.</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>《操作系统：设计与实现》笔记</title>
      <link>https://euds63.github.io/2023/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 27 Jun 2023 18:37:47 +0800</pubDate>
      
      <guid>https://euds63.github.io/2023/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/</guid>
      <description>操作系统就是状态机</description>
      <content:encoded><![CDATA[<p><strong><a href="https://space.bilibili.com/202224425/channel/collectiondetail?sid=192498"  target="_blank" rel="noopener" >操作系统：设计与实现 (2022 春季学期)</a>的学习笔记</strong></p>
<h3 id="p3-多处理器编程从入门到放弃-线程库现代处理器和宽松内存模型">p3 多处理器编程：从入门到放弃 (线程库；现代处理器和宽松内存模型)</h3>
<ul>
<li>
<p>并发程序的三个麻烦</p>
<ul>
<li>原子性</li>
<li>顺序</li>
<li>可见性</li>
</ul>
</li>
<li>
<p>gcc 编译</p>
<ul>
<li>不优化,并查看汇编代码
<code>gcc -c -O1 sum.c &amp;&amp; objdump -d sum.o</code></li>
<li><code>asm volatile(&quot;&quot; : : &quot;memory&quot;); // compiler barrier</code></li>
</ul>
</li>
<li>
<p>统计次数
<code> ./a.out | head -n 1000 | sort | uniq -c</code></p>
</li>
<li>
<p>现代处理器</p>
<ul>
<li>也是动态编译器：汇编指令也是由多个uop所组成的。</li>
<li>维护一个uop的“池子” 指令的有向无环图</li>
<li>乱序执行，顺序提交</li>
</ul>
</li>
</ul>
<h3 id="p4-理解并发程序执行-peterson算法模型检验与软件自动化工具">p4 理解并发程序执行 (Peterson算法、模型检验与软件自动化工具)</h3>
<ul>
<li>C语言的形式语义
<ul>
<li>全局变量加多个栈帧；每个栈帧有其局部变量和pc</li>
</ul>
</li>
<li>Peterson算法
<ul>
<li>看上去是谦让的，但其实是自私的</li>
<li>证明正确性：画出状态机
<ul>
<li>困境：不敢不画，不敢乱画</li>
<li>解决： <a href="https://jyywiki.cn/pages/OS/2022/demos/model-checker.py"  target="_blank" rel="noopener" >model-checker</a></li>
<li>把程序的问题变成图论的问题
<ul>
<li>safety 红色状态不可达</li>
<li>liveness : 从任意状态出发，都能到达绿/蓝色状态 强连通分量</li>
</ul>
</li>
</ul>
</li>
<li>许多重要的想法，凝练以后就是概念</li>
</ul>
</li>
<li>并发程序 = 状态机</li>
<li>Python generator
<ul>
<li>e.g.
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">numbers</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">n</span> <span class="o">=</span> <span class="n">init</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">Trye</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">n</span> <span class="o">+=</span> <span class="n">step</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl"><span class="n">g</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">g</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span>
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
<h3 id="p5-并发控制互斥-自旋锁互斥锁和-futex">p5 并发控制：互斥 (自旋锁、互斥锁和 futex)</h3>
<ul>
<li>不能解决问题的时候，可以找到所依赖的假设，并大胆地打破它</li>
<li>spin 线程直接共享 locked</li>
<li>mutex 通过系统调用访问 locked</li>
<li>futex(Fast Userspace muTexes)
<ul>
<li>Fast path: 一条原子指令，上锁成功立即返回</li>
<li>Slow path: 上锁失败，执行系统调用睡眠</li>
</ul>
</li>
</ul>
<h2 id="p6-并发控制同步-条件变量信号量生产者-消费者和哲学家吃饭问题">p6 并发控制：同步 (条件变量、信号量、生产者-消费者和哲♂学家吃饭问题)</h2>
<ul>
<li>思考： 有一堆任务，平均切分成n堆。有x个线程负责完成该任务(x &lt; n) 一个线程一次只能完成一个任务，完成后会自动去做下一个任务。要怎么实现？</li>
<li>有万能的方法，就要用万能的方法。
<ul>
<li>他是这样诠释的。当项目代码量不大（一千行以内），项目还是比较好维护的，这时候用写聪明的写法没问题。但当项目到了几万行甚至几百万行时，这时候就需要多个人来进行协作。而人和人之间最大的障碍就是无法完全沟通，理解对方的心意。</li>
<li>不要试图用聪明的办法解决并发问题</li>
<li>个人想法：第一次听这种说法，有一定道理。</li>
</ul>
</li>
<li>万能同步方法 —— 条件变量(Conditional Variables )
<ul>
<li>API
<ul>
<li>wait(cv, mutex) 💤
调用时必须保证已经获得 mutex
释放 mutex、进入睡眠状态</li>
<li>signal/notify(cv) 💬 私信：走起
如果有线程正在等待 cv，则唤醒其中一个线程</li>
<li>broadcast/notifyAll(cv) 📣 所有人：走起
唤醒全部正在等待 cv 的线程</li>
</ul>
</li>
<li>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 需要等待条件满足时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">cond</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">assert</span><span class="p">(</span><span class="n">cond</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1">// 互斥锁保证了在此期间条件 cond 总是成立
</span></span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 其他线程条件可能被满足时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">);</span>
</span></span></code></pre></div></li>
<li>debug -&gt; 隔离出bug触发的最小条件</li>
</ul>
</li>
</ul>
<h2 id="p7-真实世界的并发编程-高性能计算数据中心人机交互中的并发编程">p7 真实世界的并发编程 (高性能计算/数据中心/人机交互中的并发编程)</h2>
<ul>
<li>谈block chain &gt; 是个很好的技术。但觉得不太对。因为造成了相当大的资源浪费。</li>
<li><a href="https://www.youtube.com/watch?v=FFftmWSzgmk&amp;ab_channel=Numberphile"  target="_blank" rel="noopener" >What&rsquo;s so special about the Mandelbrot Set? - Numberphile</a></li>
<li><a href="https://github.com/atanunq/viu"  target="_blank" rel="noopener" >atanunq/viu</a></li>
<li>搜索降低了知识的获取成本，ChatGPT等再一次降低了成本。</li>
<li>go语言，编程友好、性能优化</li>
<li>博客是web2.0 的第一步</li>
<li>Ajax (Asynchronous JavaScript + XML)</li>
<li>这次课中讲了三种并发编程，根据不同的需要，实现并发的方式也不同。</li>
</ul>
<h2 id="p8-并发-bug-和应对-死锁数据竞争原子性违反防御性编程和动态分析">p8 并发 bug 和应对 (死锁/数据竞争/原子性违反；防御性编程和动态分析)</h2>
<ul>
<li>软件是需求在计算机数字世界的投影。</li>
<li>assert的使用</li>
<li>没有工具不做系统</li>
<li>premature optimization is root of all evil</li>
<li>编程语言的缺陷——对程序员的完全信任：因为计算资源的宝贵</li>
<li>动态分析工具 <code>-fsanitize</code></li>
<li>Canary msvc 中 debug mode 的canary  <code>(b'\xcc' * 80).decode('gb2312')</code></li>
</ul>
<h2 id="p9-操作系统的状态机模型-操作系统的加载-thread-os-代码讲解">p9 操作系统的状态机模型 (操作系统的加载; thread-os 代码讲解)</h2>
<ul>
<li>大学的真正意义:f将已有的知识和方法重新消化，为大家建立好 “台阶”，在有限的时间里迅速赶上数十年来建立起的学科体系。</li>
</ul>
<h2 id="p10-状态机模型的应用-细胞自动机-gdbrrperf-代码验证工具">p10 状态机模型的应用 (细胞自动机; gdb/rr/perf; 代码验证工具)</h2>
<ul>
<li>分布式系统也是一种并发程序，但要更复杂。因为并发程序假设了每个thread都能正常运行，而分布式系统则要考虑节点丢失的情况。</li>
</ul>
<h2 id="p11-操作系统上的进程-最小-linux-fork-execve-和-exit">p11 操作系统上的进程 (最小 Linux; fork, execve 和 exit)</h2>
<ul>
<li>Linux 操作系统启动流程
CPU Reset → Firmware → Loader → Kernel _start() → 第一个程序 /bin/init → 程序 (状态机) 执行 + 系统调用</li>
<li>Fork Bomb:
<code>:(){:|:&amp;};:</code>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">:<span class="o">()</span> <span class="o">{</span>         <span class="c1"># 格式化一下</span>
</span></span><span class="line"><span class="cl">: <span class="p">|</span> : <span class="p">&amp;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span><span class="p">;</span> :
</span></span></code></pre></div></li>
<li>stdout:
终端: line buffer
pipe , file :full buffer (除非显示地调用fflush)
<pre tabindex="0"><code></code></pre></li>
<li><strong>fork</strong>
<ul>
<li>程序就是状态机，正在执行的程序也是状态机，fork创建状态机的副本；</li>
<li>创建的进程返回+1，子进程返回为0</li>
<li>把所有的寄存器和内存都复制</li>
</ul>
</li>
<li><strong>execve</strong>
<ul>
<li>将当前运行的状态机重置成成另一个程序的初始状态</li>
</ul>
</li>
<li><strong>_exit</strong></li>
</ul>
<h2 id="p12-进程的地址空间-pmap-vdso-mmap-游戏修改器外挂">p12 进程的地址空间 (pmap; vdso; mmap; 游戏修改器/外挂)</h2>
<ul>
<li>端序
<ul>
<li>大端 (big endian): 低地址存放<em>高</em>有效字节</li>
<li>小端 (little endian): 低字节存放<em>低</em>有效字节</li>
</ul>
</li>
<li>工具使用
<ul>
<li>gdb</li>
<li>readelf</li>
<li>pmap</li>
</ul>
</li>
<li>计算机世界没有魔法。因为程序就是状态机。</li>
<li>vdso:不进入操作系统内核，实现系统调用</li>
<li>mmap：</li>
<li>文件=字节序列；内存=字节序列； everything is a file</li>
</ul>
<h2 id="p13-系统调用和-shell-freestanding-shell-终端和-job-control">p13 系统调用和 Shell (freestanding shell, 终端和 job control)</h2>
<ul>
<li>cd是内部命令：改变当前目录是用系统调用实现的</li>
<li><code>strace -f gcc a.c 2&gt;&amp;1 | vim -</code> This will pipe both stdout and stderr to vim. The <code>-</code> argument tells vim to read from stdin.</li>
<li><code>strace pmap 152 |&amp; vim - </code>
<code>|&amp;</code> : This is a shorthand for <code>2&gt;&amp;1 |</code> in bash and zsh. It passes both standard output and standard error of one command as input to another.</li>
<li>fish, zsh 和 bash 都是常用的命令行 shell; sh是比较原始的</li>
<li>clear 清屏</li>
<li><code>,./a.out &amp;</code>  后台执行./a.out</li>
</ul>
<h2 id="p14-c-标准库的实现-系统调用的封装内存空间管理">p14 C 标准库的实现 (系统调用的封装；内存空间管理)</h2>
<ul>
<li>文件描述符还是不理解。印象中这是第二次谈到了&quot;everything is a file&quot;
<ul>
<li>os的对象和对象的访问</li>
</ul>
</li>
<li>gdn的使用
<ul>
<li><code>No symbol table is loaded.  Use the &quot;file&quot; command</code>。可能是编译选项未包含debug信息,如gcc没有添加-g选项。</li>
</ul>
</li>
<li>premature optimization is the root of all evil.</li>
<li>脱离workload谈优化就是耍流氓</li>
<li>经典的设计：
<ul>
<li>fast path</li>
<li>slow path</li>
</ul>
</li>
</ul>
<h2 id="p15-fork-的应用-文件描述符的复制写时复制创建平行宇宙的魔法">p15 fork 的应用 (文件描述符的复制；写时复制；创建平行宇宙的魔法)</h2>
<ul>
<li>fork 状态机复制包括持有的所有操作系统对象</li>
<li>包括持有的所有操作系统对象</li>
<li>文件描述符（file discriptor）
<ul>
<li>一个指向操作系统内对象的 “指针”</li>
<li>dup() 的两个文件描述符是共享 offset</li>
</ul>
</li>
<li>访问空指针也会造成缺页中断</li>
<li>“Copy-on-write” 只有被写入的页面才会复制一份
<ul>
<li>被复制后，整个地址空间都被标记为 “只读”</li>
<li>操作系统捕获 Page Fault 后酌情复制页面</li>
<li>fork-execve 效率得到提升</li>
</ul>
</li>
<li>操作系统会维护每个页面的引用计数</li>
<li>定义进程所占用的内存</li>
<li>page是归os所有的，而非进程</li>
<li>使用fork来搜索并行化。</li>
</ul>
<h2 id="p16-什么是可执行文件-调试信息stack-unwinding静态链接中的重定位">p16 什么是可执行文件 (调试信息；Stack Unwinding；静态链接中的重定位)</h2>
<ul>
<li>可执行文件描述了状态机，是一个描述了状态机的初始状态 + 迁移的数据结构</li>
<li>os没有魔法，所有东西都有解释</li>
<li><code>She-bang</code> <code>#! interpreter [optional-arg]</code></li>
<li>GNU binutils
<ul>
<li>生成可执行文件
<ul>
<li>ld (linker), as (assembler)</li>
<li>ar, ranlib</li>
</ul>
</li>
<li>分析可执行文件
<ul>
<li>objcopy/objdump/readelf</li>
<li>addr2line, size, nm</li>
</ul>
</li>
</ul>
</li>
<li><code>objdump -d a.out | less</code> disasm</li>
<li><code>addr2line 401122 a.out</code></li>
<li>elf: 小精灵；dwarf：矮人</li>
<li>将一个 assembly (机器) 状态映射到 “C 世界” 状态很难</li>
<li>gcc等仍存在着许多不完美</li>
<li>编译器，汇编器，链接器</li>
</ul>
<h2 id="p17-动态链接和加载-静态-elf-加载器实现调试-linux-内核动态链接和加载">p17 动态链接和加载 (静态 ELF 加载器实现；调试 Linux 内核；动态链接和加载)</h2>
<ul>
<li>自定义了一个二进制格式文件</li>
<li>GOT ： global offset table</li>
<li>PLT : procedure linkage table</li>
</ul>
<h2 id="p23-1-bit-数据的存储-延迟线磁芯dramsram磁带磁盘光盘flash-ssd">p23 1-Bit 数据的存储 (延迟线/磁芯/DRAM/SRAM/磁带/磁盘/光盘/Flash SSD)</h2>
<ul>
<li>volatile: 确保该变量的实际值与内存中的值一致,每次读取都是最新值,也禁止编译器对其进行优化。</li>
<li>core dumped 磁性内存年代开始的概念。</li>
<li>局部性原理 -&gt; 可以按照大块来读写</li>
</ul>
<h2 id="p24-输入输出设备模型-串口键盘磁盘打印机总线中断控制器dma-和-gpu">p24 输入输出设备模型 (串口/键盘/磁盘/打印机/总线/中断控制器/DMA 和 GPU</h2>
<ul>
<li>DMA: direct memory access : 一个专门执行&quot;memcpy&quot;程序的cpu</li>
<li>IPC: Instruction per second</li>
<li>GPU:
<ul>
<li>一个通用计算设备</li>
<li>大量并行相似的任务</li>
</ul>
</li>
<li>异构计算：都能做，但选那个最合适的。（jjy在22年说的现在已经能感觉到有相关的趋势了。不过倒不是里面举例的挖矿，而是llm模型）</li>
</ul>
<h2 id="p25-设备驱动程序-linux-设备驱动-gpu-和-cuda-存储设备抽象">p25 设备驱动程序 (Linux 设备驱动; GPU 和 CUDA; 存储设备抽象)</h2>
<ul>
<li>设备抽象成 支持各类操作的对象 (文件)
<ul>
<li>read - 从设备某个指定的位置读出数据</li>
<li>write - 向设备某个指定位置写入数据</li>
<li>ioctl - 读取/设置设备的状态</li>
</ul>
</li>
<li><code>stty -a</code></li>
<li>GPU
<ul>
<li>Single Instruction, Multiple Thread</li>
</ul>
</li>
<li>读优先的正确性</li>
</ul>
<h2 id="p26-文件系统-api-设备在应用间的共享目录和文件-api">p26 文件系统 API (设备在应用间的共享；目录和文件 API)</h2>
<ul>
<li>信息的局部性</li>
<li>Windows从c盘开始时是受其前身Dos系统的影响，那个有a、b</li>
<li><code>mount disk.img  /mnt</code></li>
<li><code>umount /mnt</code></li>
<li>硬（hard）链接
<ul>
<li><code>ln /usr/local/python3 python</code></li>
<li>目录中仅存储指向文件数据的指针</li>
<li>允许一个文件被多个目录引用.</li>
<li>无法用来链接目录，也不能跨文件系统</li>
<li>通过<code>ls -i</code>查看是否为硬链接</li>
</ul>
</li>
<li>软 (symbolic) 链接
<ul>
<li>“快捷方式”</li>
<li><code> ln -s ../p24 p24</code></li>
<li>目录从“树”变为了“图”，还是有环图</li>
</ul>
</li>
<li><code>cd</code>的特殊性
<ul>
<li>每个进程都有一个对应的工作目录（pwd），而这个目录只有系统调用才能够修改</li>
</ul>
</li>
</ul>
<h2 id="p27-fat-和-unix-文件系统-数据结构视角的文件系统-fat-手册导读和目录树遍历">p27 FAT 和 UNIX 文件系统 (数据结构视角的文件系统; FAT 手册导读和目录树遍历)</h2>
<ul>
<li>数据结构的假设：数据是以字节来存储的。</li>
<li>RAM 和 block的区别</li>
<li>FAT(File Allocation Table)
<ul>
<li>将指针集中存放在文件系统的某个区域</li>
<li>适合小文件</li>
<li>会产生碎片（fragmentation）</li>
<li>基本假设
<ul>
<li>链表无环且长度和文件大小一致</li>
<li>FREE的cluster不能有入边</li>
</ul>
</li>
</ul>
</li>
<li>cluster</li>
<li>sector</li>
<li>ext2
<ul>
<li>大文件的随机读写性能提升明显 (O(1))</li>
<li>支持链接 (一定程度减少空间浪费)</li>
<li>inode 在磁盘上连续存储，便于缓存/预取</li>
<li>碎片</li>
</ul>
</li>
</ul>
<h2 id="p28-持久数据的可靠性-raid-崩溃一致性-fsck-和日志">p28 持久数据的可靠性 (RAID; 崩溃一致性; FSCK 和日志)</h2>
<ul>
<li>虚拟化
<ul>
<li>cpu的虚拟化：通过分时等技术让多个进程并行，相当于虚拟出了多个cpu</li>
<li>内存的虚拟化：一份内存通过mmu，虚拟成每个进程的地址空间</li>
<li>RAID：反向的虚拟化：多个磁盘虚拟化一个磁盘</li>
</ul>
</li>
<li>RAID
<ul>
<li>RAID0 : 交错排列： 提升容量和带宽</li>
<li>RAID1 : 提升容错和读带宽</li>
<li>RAID4 : 额外的一块校验盘
<ul>
<li>致命缺陷：随机写的性能只能有校验盘性能的一半</li>
</ul>
</li>
<li>RAID5 : Rotating Parity</li>
</ul>
</li>
<li>RAID带来的联想：
多个磁盘虚拟化为一个又大又快又可靠的磁盘，多台电脑虚拟化为一个又大又快又可靠的电脑
那能不能多个神经网络虚拟化为一个更好的神经网络</li>
<li>崩溃一致性  (Crash Consistency)
<ul>
<li>场景：写入的时候突然断电了怎么办？</li>
<li>方法1：按照一定顺序来写，且 “all or nothing”
<ul>
<li>困难：磁盘不提供多块读写 “all or nothing” 的支持，甚至为了性能，没有顺序保证。</li>
</ul>
</li>
<li>方法2： File System Checking (FSCK)
<ul>
<li>根据磁盘上已有的信息，恢复出 “最可能” 的数据结构</li>
<li>困难：难；如果修复的时候再掉一次电？</li>
</ul>
</li>
<li>方法3： 日志</li>
<li>具体：
<ul>
<li>数据结构操作发生时，用 (2) append-only 记录日志</li>
<li>日志落盘后，用 (1) 更新数据结构</li>
<li>崩溃后，重放日志并清除 (称为 redo log；相应也可以 undo log)</li>
</ul>
</li>
<li>优化: journaling (jdb2)</li>
</ul>
</li>
</ul>
<h2 id="p30-现代存储系统-关系数据库和分布式存储系统">p30 现代存储系统 (关系数据库和分布式存储系统)</h2>
<ul>
<li>数据库
<ul>
<li>关键
<ul>
<li>索引</li>
<li>查询优化</li>
</ul>
</li>
<li>magic：你只管写sql语句，相应的搜索优化它来做</li>
<li>要求：acid
<ul>
<li>Atoming</li>
<li>Consistency</li>
<li>Isolation</li>
<li>Durability</li>
</ul>
</li>
</ul>
</li>
<li>图灵奖
<ul>
<li>这门课听下来，听到了好多知识点背后都是获得过图灵奖的研究，甚至开创了一整个产业。</li>
</ul>
</li>
<li>关系型数据库跟不上社交网络的需求</li>
<li>cap theorem
<ul>
<li>Consistency</li>
<li>Availability</li>
<li>Partition Tolerance</li>
</ul>
</li>
<li>分布式存储系统</li>
</ul>
<h2 id="感想">感想</h2>
<p>蒋炎炎这门课还是别人推荐的。第一次看到还不以为意，但出现的次数多了就觉得有必要去看看。发现是一大惊喜。</p>
<h2 id="收获">收获</h2>
<ol>
<li>原版书能看得下来了。大段的英文，之前看着有点怕，现在觉得也能看下来，并且速度还可以。</li>
</ol>
<h2 id="课外资料">课外资料</h2>
<ul>
<li><a href="https://plantegg.github.io/2022/06/05/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E5%BC%80%E9%94%80/"  target="_blank" rel="noopener" >上下文切换的代价</a></li>
<li><a href="https://plantegg.github.io/2021/06/01/CPU%E7%9A%84%E5%88%B6%E9%80%A0%E5%92%8C%E6%A6%82%E5%BF%B5/"  target="_blank" rel="noopener" >CPU的制造和概念</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>操作系统复习笔记</title>
      <link>https://euds63.github.io/2023/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 19 Jun 2023 18:35:11 +0800</pubDate>
      
      <guid>https://euds63.github.io/2023/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>操作系统复习笔记</description>
      <content:encoded><![CDATA[<h1 id="期末复习">期末复习</h1>
<h2 id="chpter-3-process">Chpter 3 Process</h2>
<ul>
<li>操作系统进行任务调度和资源分配的基本单位</li>
<li>Process include:
<ol>
<li>Program code</li>
</ol>
<ul>
<li>text section</li>
</ul>
<ol start="2">
<li>program counter and processors’ registers</li>
<li>Stack</li>
</ol>
<ul>
<li>Function parameters</li>
<li>Return address</li>
<li>Local variables</li>
</ul>
<ol start="4">
<li>data section</li>
</ol>
<ul>
<li>Global variables</li>
</ul>
<ol start="5">
<li>Heap</li>
</ol>
<ul>
<li>Dynamically allocated memory</li>
</ul>
</li>
<li>Process State
<ul>
<li>五态模型
<ul>
<li>new</li>
<li>ready:waiting to be assigned to a processor</li>
<li>waiting: waiting for some event to occur</li>
<li>running</li>
<li>terminated</li>
</ul>
</li>
</ul>
</li>
<li>Process control block（PCB）
<ul>
<li>包含信息有：
<ul>
<li>Process number</li>
<li>Process state</li>
<li>Program counter
<ul>
<li>下条指令的地址</li>
</ul>
</li>
<li>CPU registers</li>
<li>CPU scheduling information</li>
<li>Memory-management information</li>
<li>Accounting information</li>
<li>I/O status information</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="process-scheduling">Process Scheduling</h3>
<ul>
<li>
<p>Scheduling queues</p>
<ol>
<li>Job queue</li>
</ol>
<ul>
<li>set of all processes in the system</li>
<li>As processes/job enter the system，they are put into the job queue</li>
</ul>
<ol start="2">
<li>Ready queue</li>
</ol>
<ul>
<li>set of all processes residing in “(main) memory”, ready and “waiting” to execute</li>
</ul>
<ol start="3">
<li>Device queues</li>
</ol>
<ul>
<li>set of processes waiting for an I/O device</li>
</ul>
</li>
<li>
<p>Scheduler(调度器)</p>
<ol>
<li>Long-term scheduler or job scheduler</li>
</ol>
<ul>
<li>job queue -&gt; ready queue</li>
<li>may  be absent on Time-sharing system such as UNIX  and Windows
<ul>
<li>They put every new process in memory for the short-term scheduler</li>
</ul>
</li>
</ul>
<ol start="2">
<li>Short-term scheduler Or CPU scheduler: 进程调度</li>
</ol>
<ul>
<li>selects which process should be executed next and allocates CPU</li>
<li>因为其执行十分频繁，所以每次选择不能耗时太长，否则就overhead</li>
</ul>
<ol start="3">
<li>Medium-term scheduler Or swapping</li>
</ol>
<ul>
<li>swap out: removes processes from memory to disk and reduces the degree of multiprogramming</li>
<li>swap in: introduce process into memory</li>
</ul>
</li>
<li>
<p>Context Switch</p>
<ul>
<li>CPU switches to another process</li>
</ul>
</li>
</ul>
<h3 id="operations-on-processes">Operations on Processes</h3>
<ol>
<li>fork()
<ul>
<li>The new process consists of a copy of the address space of the original process</li>
<li>The return code for the fork() is zero for the child process</li>
<li>子进程会复制父进程的地址空间和资源，但并不会复制父进程的线程</li>
</ul>
</li>
</ol>
<h3 id="interprocess-communication">Interprocess Communication</h3>
<ul>
<li>Shared memory</li>
<li>Message passing</li>
</ul>
<h3 id="名词解释">名词解释：</h3>
<ul>
<li>multiprogramming： is to have some process running at all times, to maximize CPU utilization</li>
<li>time sharing ： is to switch the CPU among processes so frequently that users can interact with each process</li>
</ul>
<h2 id="chapter-4-thread">Chapter 4 Thread</h2>
<ul>
<li>进程 vs 线程
<ul>
<li>线程是CPU的分布单位</li>
<li>进程是资源的分布单位</li>
<li>线程是进程中的执行单元
<ul>
<li>一个进程可以包含多个线程，它们共享相同的地址空间和系统资源，如open files, signals。</li>
<li>每个线程有自己的栈空间和执行上下文，但它们在同一个进程内共享代码段、数据段和堆等资源。</li>
</ul>
</li>
</ul>
</li>
<li>benefits of multithreaded programming
<ol>
<li>Responsiveness</li>
<li>Resource sharing</li>
<li>Economy</li>
<li>utilization of multiprocessor architectures</li>
</ol>
</li>
</ul>
<h3 id="multithreading-models">Multithreading Models</h3>
<ul>
<li>
<p>两种线程</p>
<ul>
<li>User Threads
<ul>
<li>Provided by a thread library at the user level</li>
</ul>
</li>
<li>Kernel Threads
<ul>
<li>Provided and managed by the OS directly</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Relationship between kernel threads and user threads</p>
<ol>
<li>Many-to-one model</li>
<li>One-to-one model-</li>
<li>Many-to-many model</li>
<li>Two-level Model
<ul>
<li>主体是Many-to-many model</li>
<li>A user thread (important task) can be bound to a kernel thread</li>
</ul>
</li>
</ol>
</li>
<li>
<p>Two versions of fork() in UNIX systems</p>
<ol>
<li>To duplicate all the threads
<ul>
<li>If exec() is not called after forking, then to duplicate all threads</li>
</ul>
</li>
<li>To only duplicate the thread that invoked the fork() system call
<ul>
<li>If exec() is called immediately after forking, then only to duplicate the calling threads</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="chapter-5-cpu-scheduling">Chapter 5 CPU Scheduling</h2>
<h3 id="basic-concepts">Basic Concepts</h3>
<ul>
<li>CPU scheduling decisions may take place when a process:
<ol>
<li>Switches from running to waiting state
<ul>
<li>The result of  an I/O request</li>
<li>An invocation of wait for the termination of one of the child processes （e.g. wait(NULL);）</li>
</ul>
</li>
<li>Switches from running to ready state
<ul>
<li>When a interrupt occurs</li>
</ul>
</li>
<li>Switches from waiting to ready
<ul>
<li>Completion of I/O</li>
</ul>
</li>
<li>Terminates</li>
</ol>
</li>
<li>Non-preemptive (非剥夺)
<ul>
<li>Once the CPU has been allocated to a process, the process keeps the CPU until it releases the CPU</li>
<li>调度只可能发生在情况 1. 和 4.</li>
<li>简单，硬件要求低</li>
</ul>
</li>
<li>Preemptive(剥夺)</li>
</ul>
<h3 id="scheduling-criteria">Scheduling Criteria</h3>
<ol>
<li>CPU utilization</li>
<li>CPU throughout
<ul>
<li>number of processes that complete their execution per time unit.</li>
</ul>
</li>
<li>Process turnaround time
<ul>
<li>From the time of submission of a process to the time of completion, include
<ul>
<li>Waiting to get into memory</li>
<li>Waiting in the ready queue</li>
<li>Executing on the CPU</li>
<li>Doing I/O</li>
</ul>
</li>
</ul>
</li>
<li>Process waiting time (等待时间)
<ul>
<li>amount of time that a process spent waiting in the ready queue.</li>
</ul>
</li>
<li>Process response time (响应时间)
<ul>
<li>amount of the time from the submission of a request until the first response/result is produced</li>
</ul>
</li>
</ol>
<h3 id="scheduling-algorithms">Scheduling Algorithms</h3>
<ol>
<li>First come first served (FCFS)
<ul>
<li>non-preemptive</li>
<li>Convoy effect (护航效应)</li>
</ul>
</li>
<li>Shortest job first (SJF)
<ul>
<li>minimum average waiting time</li>
<li>种类
<ol>
<li>Preemptive SJF allows to preempt the currently executing process</li>
<li>Non-preemptive</li>
</ol>
</li>
<li>比较适用于长程调度</li>
</ul>
</li>
<li>Priority scheduling
<ul>
<li>问题：starvation</li>
<li>解决： Aging (时效) – as time progresses increase the priority of the process</li>
</ul>
</li>
<li>Round robin (RR)
<ul>
<li>Is designed for especially for time-sharing systems</li>
<li>preemptive</li>
<li>time quantum
<ul>
<li>需要保证 80%的cpu bursts &lt; the time quantum</li>
</ul>
</li>
<li>Response time = 2*(n-1)*q</li>
</ul>
</li>
<li>Multilevel queue algorithm</li>
<li>Multilevel feedback queue algorithm
<ul>
<li>the most general scheduling algorithm</li>
</ul>
</li>
</ol>
<h3 id="multiple-processor-scheduling">Multiple-Processor Scheduling</h3>
<ul>
<li>homogeneous vs. heterogeneous CPUs
<ul>
<li>homogeneous: 各处理器都一样</li>
</ul>
</li>
<li>Approaches to multiple-processor scheduling
<ul>
<li>Asymmetric multiprocessing
<ul>
<li>only one processor (the master server) has all scheduling decision, I/O processing</li>
</ul>
</li>
<li>Symmetric multiprocessing
<ul>
<li>each processor is self-scheduling</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="chapter-6-process-synchronization">Chapter 6 Process synchronization</h2>
<ul>
<li>Race condition
<ul>
<li>The situation where several processes access and manipulate shared data concurrently.</li>
<li>The final value of the shared data depends upon which process finishes last.</li>
</ul>
</li>
</ul>
<h3 id="the-critical-section-problem">The Critical-Section Problem</h3>
<ul>
<li>
<p>critical section</p>
<ul>
<li>Each process has a code segment, called critical section, in which the shared data is accessed</li>
<li>有几个共享变量就有几个临界区</li>
</ul>
</li>
<li>
<p>Criteria for the critical section problem solution</p>
<ol>
<li>Mutual exclusion 互斥</li>
<li>progress 空闲让进</li>
<li>Bounded waiting 有限等待</li>
</ol>
</li>
<li>
<p>Peterson’s Solution</p>
<ul>
<li>举手+令牌</li>
</ul>
</li>
<li>
<p>hardware-based solution</p>
<ul>
<li>关中断
<ul>
<li>多处理机不适合</li>
</ul>
</li>
<li>原子操作</li>
</ul>
</li>
</ul>
<h3 id="semaphores">Semaphores</h3>
<ul>
<li>
<p>A Semaphore S – integer variable</p>
<ul>
<li>may be initialized via a non-negative value</li>
<li>Can only be accessed via two indivisible (atomic) operations: P() and V()</li>
</ul>
</li>
<li>
<p>P(): the wait() operation</p>
<pre tabindex="0"><code>wait (S) { 
  while (S.value &lt;= 0) ; 	// no-op
    S.value--;
}
</code></pre></li>
<li>
<p>V() The signal() operation</p>
<pre tabindex="0"><code>signal(S){
  S.value++;
}
</code></pre></li>
<li>
<p>main problem : busy waiting (spinlock)</p>
<ul>
<li>advantages
<ol>
<li>No context switch is required when a process must wait on a lock</li>
<li>If locks are expected to be held for short times, the spinlocks are useful</li>
</ol>
</li>
<li>disadvantages
<ol>
<li>wastes the CPU cycles that can be used by other processes productively</li>
</ol>
</li>
<li>解决：modify the definition of the wait() and signal() <strong>适用于 multiprocessor system</strong>
<ul>
<li>Wait(): the process can block() itself rather than engaging in busy waiting</li>
<li>Signal(): change the blocking process from the waiting state to the ready state</li>
</ul>
</li>
</ul>
</li>
<li>
<p>implementation</p>
<ol>
<li>In a single-processor environment</li>
</ol>
<ul>
<li>Disable interrupt</li>
</ul>
<ol start="2">
<li>In a multi-processor environment</li>
</ol>
<ul>
<li>Critical section can be applied</li>
</ul>
</li>
</ul>
<h2 id="chapter-7-deadlocks">Chapter 7 Deadlocks</h2>
<ul>
<li>Necessary conditions
<ol>
<li>Mutual exclusion</li>
<li>Hold and wait</li>
<li>No preemption</li>
<li>Circular wait</li>
</ol>
</li>
</ul>
<h3 id="methods-for-handling-deadlocks">Methods for Handling Deadlocks</h3>
<ol>
<li>
<p>Prevention</p>
<ul>
<li>Provides a set of methods for ensuring that at least one of necessary conditions cannot be held</li>
<li>针对条件2： all or nothing; 没有资源的时候才去申请</li>
<li>针对条件3： 谦让； 抢夺</li>
<li>针对条件4： 顺序执行</li>
<li>缺点： low device utilization and reduce system throughput.</li>
</ul>
</li>
<li>
<p>Avoidance</p>
<ul>
<li>using the addition information,decide whether the current request can be satisfied or must be delay</li>
<li>方法：
<ol>
<li>Resource-allocation graph
<ul>
<li>有环：处于unsafe state;可能处于死锁状态</li>
</ul>
</li>
<li>Banker&rsquo;s algorithm</li>
</ol>
</li>
</ul>
</li>
<li>
<p>Detection and recovery</p>
<ul>
<li>方法:
<ul>
<li>Wait-for graph
<ul>
<li>not appilcable to a resource-allocation system with multiple instances of each resource type</li>
</ul>
</li>
<li>Banker’s Algorithm</li>
</ul>
</li>
<li>When, and how often, to invoke detection algorithm. it depends on:
<ul>
<li>How often a deadlock is likely to occur?</li>
<li>How many processes will need to be rolled back?</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Ignorance</p>
</li>
</ol>
<h2 id="chapter-8">Chapter 8</h2>
<ul>
<li>
<p>Address may be represented in</p>
<ol>
<li>symbolic address</li>
<li>re-locatable address</li>
<li>absolute address</li>
</ol>
</li>
<li>
<p>address binding</p>
<ul>
<li>转换：
<ul>
<li>symbolic address -&gt; re-locatable address : compiler</li>
<li>re-locatable address -&gt; absolute address : linkage editor or loader</li>
</ul>
</li>
<li>发生的时期
<ol>
<li>Compile time
<ul>
<li>If memory location known at compile time, absolute code can be generated</li>
<li>If memory location is not known at compile time, Must generate re-locatable code</li>
</ul>
</li>
<li>Load time （+linkage time）
<ul>
<li>if memory location is known at load time, absolute code can be generated at this time</li>
</ul>
</li>
<li>Execution time
<ul>
<li>If memory location is not known at compile time and load time, Binding is delayed until run time</li>
<li>absolute code must be generated at run time</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="logical-vs-physical-address-space">Logical vs. Physical Address Space</h3>
<ul>
<li>
<p>Logical address ：CPU</p>
<ul>
<li>also referred to as virtual address</li>
<li>重定位地址和逻辑地址没有直接关系</li>
</ul>
</li>
<li>
<p>Physical address ：memory unit</p>
</li>
<li>
<p>logical (virtual) and physical addresses differ in execution-time address-binding scheme</p>
<ul>
<li>re-locatable code are seen by CPU</li>
<li>absolute code are seen by the memory unit</li>
</ul>
</li>
<li>
<p>Memory-Management Unit (MMU)</p>
<ul>
<li>Hardware device that maps virtual address to physical address in the run-time</li>
</ul>
</li>
<li>
<p>Dynamic load</p>
<ul>
<li>not loaded the entire program and data of a process be in physical memory for the process to execute until it is called</li>
<li>好处：
<ol>
<li>Better memory-space utilization</li>
<li>No special support is required from the operating system</li>
</ol>
</li>
</ul>
</li>
<li>
<p>Dynamic linking</p>
<ul>
<li>Linking is postponed until execution time</li>
<li>requires help from the OS</li>
</ul>
</li>
</ul>
<h3 id="contiguous-memory-allocation">Contiguous Memory Allocation</h3>
<ol>
<li>Fixed-Sized Contiguous Partition
<ul>
<li>Strengths (advantages)
<ul>
<li>Simple to implement</li>
<li>little overhead</li>
</ul>
</li>
<li>Weaknesses(drawbacks)
<ul>
<li>internal fragmentation
<ul>
<li>allocated memory may be larger than requested memory</li>
</ul>
</li>
<li>fixed number of processes</li>
</ul>
</li>
</ul>
</li>
<li>Dynamic Contiguous partition（可变分区）
<ul>
<li>Hole – block of available memory</li>
<li>Allocation algorithms
<ol>
<li>first fit:
<ul>
<li>从头开始，或者是从当前位置开始</li>
</ul>
</li>
<li>best-fit
<ul>
<li>Need to search all entire list, unless the list is ordered by size</li>
<li>produces the smallest leftover hole that may be wasted</li>
</ul>
</li>
<li>worst-fit
<ul>
<li>Need to search all entire list, unless the list is ordered by size</li>
<li>小进程多的 效果好</li>
</ul>
</li>
</ol>
</li>
<li>问题：
<ul>
<li>External Fragmentation</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>
<p>Solutions to fragmentation</p>
<ol>
<li>Compaction(紧凑)
<ul>
<li>To reduce external fragmentation</li>
<li>Shuffle memory contents to place all free memory together in one large block</li>
<li>It is done at execution time， it’s possible only if relocation is dynamic</li>
<li>May be expensive in moving the processes and the holes</li>
</ul>
</li>
<li>paging</li>
<li>segmentation</li>
</ol>
</li>
<li>
<p>Disadvantage of Contiguous Memory Allocation</p>
<ul>
<li>Fragmentation in main memory</li>
<li>Compaction is impossible on the disk</li>
</ul>
</li>
</ul>
<h3 id="paging">paging</h3>
<ul>
<li>
<p>frame: Divide physical memory into fixed-sized blocks</p>
</li>
<li>
<p>page : Divide logical memory into fixed-sized blocks</p>
<ul>
<li>page size is equal to frame size</li>
<li>Finding n free frames for loading a program of size n pages</li>
</ul>
</li>
<li>
<p>Translating logical address to physical address
If the address space is 2^m and the page size is 2^n</p>
<ul>
<li>Every logical address generated by CPU is divided into:
<ol>
<li>Page number (p: 页号)
<ul>
<li>used as an index into a page table</li>
<li>页表中包含每一页在physical memory 的 base address (f:块号)</li>
<li>p =address/2^n   is equal to m-n bit of the address</li>
</ul>
</li>
<li>Page offset (d: 偏移)
<ul>
<li>combined with base address (f:块号) to define the physical memory address that is sent to the memory unit</li>
<li>d =address%2n is equal to n bit of the address</li>
</ul>
</li>
</ol>
</li>
<li>Physical address
<ol>
<li>frame number（f: 帧号、块号)</li>
<li>page offset      (d:页偏移、块偏移)</li>
</ol>
</li>
</ul>
</li>
<li>
<p>page size的选择</p>
<ul>
<li>越大：
<ul>
<li>Disk I/O is more efficient</li>
<li>page table size 越小</li>
</ul>
</li>
<li>越小：
<ul>
<li>internal fragmentation 越小</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Frame table (主存分块表)</p>
<ul>
<li>Has one entry for each physical page frame
Indicating
<ul>
<li>whether the frame is free or it is allocated to which process</li>
</ul>
</li>
</ul>
</li>
<li>
<p>page table</p>
<ul>
<li>each process must maintain a copy of the page table</li>
<li>计算
<ul>
<li>if page-table entry is 4 bytes long
<ul>
<li>Can point to one of 2^32 physical page frames (1比特=8字节)</li>
<li>If frame size(= page size) is 4KB, the system can address 2^44 bytes(2^32×2^12=16TB) of physical memory</li>
</ul>
</li>
<li>对于32位cpu
<ul>
<li>page size: 4k (=2^12)</li>
<li>Table size：2^32/2^12=1M</li>
<li>each entry&rsquo;s size : 4 bytes</li>
<li>page table 的大小为： 4 MB</li>
</ul>
</li>
</ul>
</li>
<li>位置
<ol>
<li>直接存放在寄存器中：
<ul>
<li>Efficient and expensive</li>
<li>当page table is reasonable small 时可以</li>
</ul>
</li>
<li>存放在main memory ，然后用Page-table base register (PTBR：页表基址寄存器)存放其位置
<ul>
<li>进程切换时，加载页表只需要改变PTBR</li>
<li>every data/instruction access requires two memory accesses
<ul>
<li>One for the page table</li>
<li>One for the data/instruction</li>
</ul>
</li>
</ul>
</li>
<li>Translation Look-aside Buffer (TLB) also called Associate Memory(联想寄存器)
<ul>
<li>并行查找</li>
<li>contains only a few of page-table entries</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="structure-of-the-page-table">Structure of the Page Table</h3>
<ul>
<li>问题: The page table can be excessively large</li>
<li>Solution： Divide the page table into smaller pieces
<ol>
<li>Hierarchical Paging （分层页表）</li>
<li>Hashed Page Tables（哈希页表）</li>
<li>Inverted Page Tables（反置页表）</li>
</ol>
</li>
</ul>
<ol>
<li>Hierarchical Paging （分层页表）
<ul>
<li>缺陷：</li>
</ul>
<ol>
<li>需遍历，进程太多</li>
<li>可能有共享，而进程号只能填一个</li>
<li>不适用于64位</li>
</ol>
<ul>
<li>好：
<ol>
<li>需要的空间小</li>
</ol>
</li>
</ul>
</li>
<li>Hashed Page Tables
<ul>
<li>hash table -&gt; 在链表中遍历匹配</li>
</ul>
</li>
<li>Inverted Page Table(反置页表/主存分块表)</li>
</ol>
<ul>
<li>Only a page table in the system</li>
<li>One entry for each real page (or physical frame) of memory</li>
<li>缺点：
<ul>
<li>increases time needed to search the table when a page reference occurs</li>
<li>Lead to memory share difficulty</li>
</ul>
</li>
</ul>
<h3 id="segmentation">segmentation</h3>
<ul>
<li>User’s View of a Program: A program is a collection of segments，a segment is a logical unit such as:
<ul>
<li>main program
<ul>
<li>procedure ，function，method，object</li>
<li>local variables, global   variables</li>
<li>common block</li>
<li>stack</li>
<li>symbol table</li>
<li>arrays</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="chapter-9-virtual-memory">Chapter 9 Virtual Memory</h2>
<ul>
<li>
<p>the entire program is not needed to be in physical memory.这样的好处有：</p>
<ul>
<li>程序的大小不再受内存所限制</li>
<li>更多程序可以同时运行</li>
<li>Less I/O would be needed to load or swap each user program into memory, so program would start to run faster</li>
</ul>
</li>
<li>
<p>Virtual memory management</p>
<ul>
<li>a term used to describe a technique whereby the computer appears to have much more memory than it actually does</li>
</ul>
</li>
<li>
<p>Virtual memory can be implemented via:</p>
<ul>
<li>Demand paging</li>
<li>Demand segmentation</li>
</ul>
</li>
</ul>
<h3 id="demand-paging">Demand paging</h3>
<ul>
<li>
<p>思想： Bring a page into memory only when it is needed</p>
<ul>
<li>Be similar to a paging system with swapping</li>
</ul>
</li>
<li>
<p>Hardware</p>
<ul>
<li>Page table. 需要加一位valid–invalid bit
<ul>
<li>v -》 The page is legal and in memory</li>
</ul>
</li>
<li>Secondary memory
<ul>
<li>A high-speed disk, Swap space</li>
<li>Hold those page that are not present in memory</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Page Fault</p>
<ul>
<li>Access to a page marked invalid causes a page-fault trap</li>
<li>handle
<ol>
<li>Operating system looks at another table (PCB) to decide:
<ul>
<li>Invalid reference -&gt; abort</li>
<li>Just not in memory	（go on to 2））</li>
</ul>
</li>
<li>Get empty frame</li>
<li>Swap the desired page into the frame</li>
<li>modify the page table, Set validation bit = v</li>
<li>Restart the instruction that caused the page fault</li>
</ol>
</li>
<li>特殊：
<ol>
<li>一条指令可产生多个缺页中断</li>
<li>指令复执</li>
<li>在指令执行时中断。</li>
</ol>
</li>
<li>对比普通中断：
<ul>
<li>一条指令在执行完后，检查是否有中断请求
<ul>
<li>有：执行中断</li>
<li>无：执行下一条指令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="page-replacement">Page Replacement</h3>
<p><strong>替换算法</strong></p>
<ol>
<li>
<p>FIFO page Replacement</p>
<ul>
<li>Belady’s Anomaly : more frames -&gt; more page faults</li>
</ul>
</li>
<li>
<p>Optimal Page Replacement (OPT)</p>
<ul>
<li>替换最晚才用的页 或 后面最长时间用不到的页</li>
</ul>
</li>
<li>
<p>Least Recently Used (LRU) Algorithm</p>
<ul>
<li>思想： The recent past as an approximation of the near future</li>
<li>实现：</li>
<li>counters</li>
<li>stack</li>
</ul>
</li>
<li>
<p>LRU Approximation Algorithms</p>
<ol>
<li>Additional-reference-bits algorithm</li>
<li>Second chance (clock)</li>
<li>Enhanced second-chance algorithm</li>
</ol>
</li>
<li>
<p>Counting-Based Page Replacement</p>
<ul>
<li>Least Frequently used</li>
<li>Most Frequently used</li>
</ul>
</li>
<li>
<p>Page-Buffering Algorithm</p>
<ul>
<li>Assistant procedure to a page-replacement algorithm</li>
</ul>
</li>
</ol>
<h3 id="allocation-of-frames">Allocation of Frames</h3>
<ul>
<li>
<p>Two major allocation schemes</p>
<ol>
<li>fixed allocation
<ul>
<li>Equal allocation</li>
<li>Proportional allocation</li>
</ul>
</li>
<li>priority allocation
<ul>
<li>Use a proportional allocation scheme using priorities rather than size</li>
</ul>
</li>
</ol>
</li>
<li>
<p>Global vs. Local Allocation</p>
<ol>
<li>Local replacement
<ul>
<li>To allow a process to select from only its own set of allocated frames.</li>
<li>Cannot increase the number of frames allocated</li>
<li>Not affected by external circumstances</li>
</ul>
</li>
<li>Global replacement
<ul>
<li>To allow a process to select a replacement frame from the set of all frames, even if that frame is currently allocated to some other process</li>
<li>Can increase the number of frames allocated</li>
<li>Cannot control its page-fault rate.</li>
</ul>
</li>
</ol>
<ul>
<li>In general, global replacement is better.</li>
</ul>
</li>
</ul>
<h3 id="thrashing">Thrashing</h3>
<ul>
<li>A process is thrashing （颠簸）if it is spending more time paging than executing</li>
<li>approach
<ol>
<li>Using a local replacement algorithm</li>
<li>Working-set strategy
<ul>
<li>To compute the working-set size for each process in the system</li>
</ul>
</li>
<li>Page-Fault Frequency (PFF) Scheme  (水多了加面，面多了加水)
<ul>
<li>If actual rate too low, remove  a frame from the process</li>
<li>If actual rate too high, allocate another frame to the process</li>
<li>If no frames are free, suspend it</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="other-considerations">Other Considerations</h3>
<ul>
<li>page size 大小的选择要考虑到：
<ol>
<li>内碎片</li>
<li>页表的大小</li>
<li>I/O overhead (seek time, latency time, transfer time)</li>
<li>Locality</li>
<li>Page fault rate
<ul>
<li>顺序访问： page size越大，则缺页中断率越小</li>
<li>随机访问： page size越大，则more paging action could ensue because fewer pages can be kept in memory and more data is transferred per page fault.</li>
</ul>
</li>
</ol>
</li>
<li>Install a faster hard disk, or multiple controllers with multiple hard disks
<ul>
<li>for as the disk bottleneck is removed by faster response and more throughput to the disks, the CPU will get more data more quickly</li>
</ul>
</li>
</ul>
<h2 id="chapter-10-file-system-interface">Chapter 10 File-System Interface</h2>
<ul>
<li>File
<ul>
<li>A file is named collection of related information that is recorded on secondary storage</li>
<li>Six basic operations
<ol>
<li>create</li>
<li>read/write/seek</li>
<li>delete</li>
<li>truncate: to erase the contents of a file but keep its attributes except for it’s length</li>
</ol>
</li>
<li>Assistant operations
<ul>
<li>open(F):
<ol>
<li>search the directory structure on disk for entry F</li>
<li>copy the directory entry into the open-file table</li>
<li>allocate a file descriptor</li>
</ol>
</li>
<li>close(F):
<ol>
<li>copy the directory entry in the open-file table to the directory structure on disk</li>
<li>free the file descriptor</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="access-methods">Access Methods</h3>
<ul>
<li>The information in the file can be accessed in
<ol>
<li>sequentical access</li>
<li>direct access</li>
<li>other access
<ul>
<li>involve the construction of an index for the file</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="directory-structure">Directory Structure</h3>
<ul>
<li>
<p>symbol table</p>
<ul>
<li>The directory can be viewed as a symbol table that translates file names into their directory entries</li>
</ul>
</li>
<li>
<p>Criteria</p>
<ol>
<li>efficiency</li>
<li>naming</li>
<li>grouping</li>
</ol>
</li>
<li>
<p>shemes</p>
<ol>
<li>Single-Level Directory</li>
<li>Two-Level Directory
<ul>
<li>Positive
<ul>
<li>Efficient searching</li>
</ul>
</li>
<li>Negative
<ul>
<li>No grouping capability</li>
<li>Difficult to share file among different users</li>
</ul>
</li>
</ul>
</li>
<li>Tree-Structured Directories
<ul>
<li>Positive
<ul>
<li>Efficient searching</li>
<li>Grouping Capability</li>
</ul>
</li>
<li>Negative
<ul>
<li>Difficult to share file among different users</li>
</ul>
</li>
</ul>
</li>
<li>Acyclic-Graph Directories
<ul>
<li>Tree-structured directory + shared subdirectories or files</li>
<li>Created a new directory entry  called a link to implement sharing</li>
<li>The difficulty is to avoid cycles as new links are added</li>
</ul>
</li>
<li>General Graph Directory
<ul>
<li>Add the links to an existing tree-structure directory</li>
<li>Acyclic-Graph Directories更好</li>
</ul>
</li>
</ol>
</li>
<li>
<p>硬（hard）链接</p>
<ul>
<li><code>ln /usr/local/python3 python</code></li>
<li>目录中仅存储指向文件数据的指针</li>
<li>允许一个文件被多个目录引用.</li>
<li>无法用来链接目录，也不能跨文件系统</li>
<li>通过<code>ls -i</code>查看是否为硬链接</li>
</ul>
</li>
<li>
<p>软 (symbolic) 链接</p>
<ul>
<li>“快捷方式”</li>
<li>软链接也是一个文件</li>
<li><code> ln -s ../p24 p24</code></li>
<li>目录从“树”变为了“图”，还是有环图</li>
</ul>
</li>
<li>
<p>ACL: access-control list</p>
<ul>
<li>Each file or directory has an ACL</li>
</ul>
</li>
</ul>
<h2 id="file-system-implementation">File-System Implementation</h2>
<ul>
<li>File system organized into layers
<ol>
<li>application program</li>
<li>logical file system
<ul>
<li>FCB: file control blocks</li>
</ul>
</li>
<li>file-organizational module</li>
<li>basic file system</li>
<li>I/O control</li>
<li>devices</li>
</ol>
</li>
</ul>
<h3 id="allocation-methods">Allocation Methods</h3>
<ul>
<li>
<p>An allocation method refers to how disk blocks are allocated for files</p>
</li>
<li>
<p>Contiguous allocation</p>
<ul>
<li>Each file occupies a set of contiguous blocks on the disk</li>
<li>Supports both sequential access and direct access （Random access）</li>
<li>问题：
<ol>
<li>External fragmentation</li>
<li>Files cannot grow</li>
</ol>
</li>
</ul>
</li>
<li>
<p>Linked allocation</p>
<ul>
<li>Each file is a linked list of disk blocks: blocks may be scattered anywhere on the disk</li>
<li>优点
<ol>
<li>容易实现</li>
<li>无外碎片</li>
<li>文件增长方便</li>
</ol>
</li>
<li>缺点：
<ol>
<li>No random access</li>
<li>Poor reliability</li>
<li>慢（链表是保存在磁盘上的，所以需要多次查询）</li>
</ol>
</li>
<li>改进： File-allocation table (FAT)
<ul>
<li>把链表信息放到了一个单独的FAT表中，而不是各个数据块中，且进行备份</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Indexed allocation</p>
<ul>
<li>
<p>Bringing all the pointers together into one location: index block</p>
</li>
<li>
<p>Solutions to large files</p>
<ol>
<li>Linked sheme
<ul>
<li>Link blocks of index table</li>
</ul>
</li>
<li>Multilevel index</li>
<li>Combined scheme
<ul>
<li>一部分是 direct pointers ，一部分是multi-indirect block</li>
</ul>
</li>
</ol>
</li>
<li>
<p>Criteria</p>
<ol>
<li>storage utilization efficiency</li>
<li>data block access time</li>
</ol>
<ul>
<li>Contiguous allocation: Good for known-size file</li>
<li>Linked allocation: Good for storage utilization</li>
<li>Indexed allocation: Access time depends on index structure, file size, block position</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="free-space-management">Free-Space Management</h3>
<ul>
<li>The free-space list 的实现
<ol>
<li>Bit vector
<ul>
<li>优点
<ul>
<li>Simple to implement</li>
<li>Efficient to find the first free block</li>
</ul>
</li>
<li>缺点
<ul>
<li>Bit map requires extra space</li>
<li>Inefficient unless the entire vector is kept in main memory</li>
</ul>
</li>
</ul>
</li>
<li>Linked Lists (free list)
<ul>
<li>优点
<ul>
<li>No waste of space</li>
</ul>
</li>
<li>缺点
<ul>
<li>Inefficient when traversing the list</li>
</ul>
</li>
</ul>
</li>
<li>Grouping</li>
</ol>
<ul>
<li>The first free block store the addresses of n free blocks</li>
<li>Easier to find a large number of free blocks</li>
</ul>
</li>
</ul>
<h2 id="mass-storage-systems">Mass-Storage Systems</h2>
<ul>
<li>
<p>Magnetic disk&rsquo;s structure</p>
<ul>
<li>Disk platter</li>
<li>track</li>
<li>sector
<ul>
<li>each track is subdivided into several sectors</li>
</ul>
</li>
<li>cylinder
<ul>
<li>is the set of tracks that are at one arm position</li>
</ul>
</li>
</ul>
</li>
<li>
<p>CLV vs. CAV</p>
<ol>
<li>ClV : constant linear velocity
<ul>
<li>CD-ROM， DVD-ROM</li>
<li>Tracks in the outermost zone hold more sectors</li>
</ul>
</li>
<li>CAV : constant angular velocity
<ul>
<li>Magnetic disk</li>
<li>The density of bits decreases from inner tracks to outer tracks to keep the data rate constant</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="disk-scheduling">Disk Scheduling</h3>
<ul>
<li>Access time
<ol>
<li>Seek time is the time for the disk are to move the heads to the cylinder containing the desired sector
<ul>
<li>Seek time  seek distance</li>
</ul>
</li>
<li>Rotational latency
<ul>
<li>waiting for the disk to rotate the desired sector to the disk head</li>
</ul>
</li>
</ol>
</li>
<li>Disk bandwidth
<ul>
<li>The total number of bytes transferred / the total time  between the first request for service and the completion of the last transfer</li>
</ul>
</li>
</ul>
<ol>
<li>FCFS Scheduling</li>
<li>SSTF：Shortest-seek-time-first (SSTF)
<ul>
<li>最短寻道时间优先</li>
<li>问题：
<ul>
<li>往返跑&mdash;距离很短，但速度不一定很快</li>
<li>may cause starvation of some requests</li>
</ul>
</li>
</ul>
</li>
<li>SCAN</li>
</ol>
<ul>
<li>Sometimes called the elevator algorithm</li>
</ul>
<ol start="4">
<li>C-SCAN (Circular SCAN)</li>
</ol>
<ul>
<li>The head moves from one end of the disk to the other, servicing requests as it goes</li>
<li>When it reaches the other end, however, it immediately returns to the beginning of the disk, without servicing any requests on the return trip</li>
<li>回途不载客</li>
</ul>
<ol start="5">
<li>LOOK / C-LOOK</li>
</ol>
<ul>
<li>
<p>Similar to SCAN/C-SCAN</p>
</li>
<li>
<p>Arm only goes as far as the last request in each direction, then reverses direction immediately, without first going all the way to the end of the disk.</p>
</li>
<li>
<p>选择
<strong>Performance depends on the number and types of requests</strong></p>
<ul>
<li>SCAN and C-SCAN perform better for systems that place a heavy load on the disk</li>
<li>Either SSTF or LOOK is a reasonable choice for the default algorithm</li>
</ul>
</li>
</ul>
<h3 id="disk-management">Disk Management</h3>
<ul>
<li>Disk formatting
<ul>
<li>Low-Level Formatting (physical formatting )
<ul>
<li>Dividing a disk into sectors that the disk controller can read and write</li>
</ul>
</li>
<li>logical Formatting
<ul>
<li>Creation of a file system</li>
<li>Build the metadata structures for a file system</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="raid-structure">RAID Structure</h3>
<ul>
<li>
<p>Redundant Array of Inexpensive Disks (past)</p>
</li>
<li>
<p>Redundant Array of Independent Disks (now)</p>
<ul>
<li>Used for their higher reliability and higher data-transfer rate(performance)</li>
</ul>
</li>
<li>
<p>levels</p>
<ol>
<li>RAID 0
<ul>
<li>Disk arrays with data striping at the level of blocks but without any redundancy</li>
</ul>
</li>
<li>RAID 1
<ul>
<li>Disk mirroring</li>
</ul>
</li>
<li>RAID 2
<ul>
<li>Bit-level striping or Byte-level striping</li>
<li>Memory-style error-correcting-code (ECC)</li>
</ul>
</li>
<li>RAID 3
<ul>
<li>Bit-interleaved parity</li>
</ul>
</li>
<li>RAID 4
<ul>
<li>Block-interleaved parity organization</li>
</ul>
</li>
<li>RAID 5
<ul>
<li>Block-interleaved distributed parity</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="常用单词">常用单词</h2>
<ul>
<li>simultaneously : 同时地</li>
<li>idle : 空闲，懒</li>
<li>reside : 位于，居住</li>
<li>uni-processor : 单处理器</li>
<li>interleave: 交织</li>
<li>allocation : 分配</li>
<li>dashed line ： 虚线</li>
<li>minuscule : 微小的</li>
<li>concrete : 具体的</li>
<li>mandatory: 强制的</li>
<li>mediate : 调解</li>
<li>strip : 脱掉；条</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>软工导论复习笔记</title>
      <link>https://euds63.github.io/2023/%E8%BD%AF%E5%B7%A5%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 16 Jun 2023 18:28:40 +0800</pubDate>
      
      <guid>https://euds63.github.io/2023/%E8%BD%AF%E5%B7%A5%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>没有银弹</description>
      <content:encoded><![CDATA[<h1 id="软工导论复习">软工导论复习</h1>
<h2 id="chapter-0">Chapter 0</h2>
<ul>
<li>
<p>软件工程提出时间：1968年</p>
<p>1968年北大西洋公约组织(NATO)的计
算机科学家在联邦德国召开国际会议，
讨论软件危机问题，正式提出了“软件
工程”。</p>
</li>
</ul>
<h2 id="chapter-1">Chapter 1</h2>
<ul>
<li>The nature of software
Developed / Deteriorates / Custom built/ Complex</li>
</ul>
<h2 id="chapter-2">Chapter 2</h2>
<ul>
<li>
<p>软件工程定义</p>
<ol>
<li>The application of a systematic,
disciplined, quantifiable approach to the
development, operation, and maintenance
of software; that is, the application of
engineering to software.</li>
<li>The study of approaches as in (1).</li>
</ol>
</li>
<li>
<p>Software Process</p>
<ul>
<li>why: 需要及时的反馈</li>
<li>Process framework
<ul>
<li>Framework activities
<ul>
<li>Communication</li>
<li>Planning</li>
<li>Modeling
<ol>
<li>需求分析</li>
<li>设计</li>
</ol>
</li>
<li>Construction
<ol>
<li>代码</li>
<li>测试</li>
</ol>
</li>
<li>Deployment</li>
</ul>
</li>
<li>Umbrella Activities 庇护活动（普适性活动）
<ul>
<li>Software project tracking and control</li>
<li>Risk management</li>
<li>Software quality assurance</li>
<li>Technical reviews</li>
<li>Measurement</li>
<li>Software configuration management</li>
<li>Reusability management</li>
<li>Work product preparation and production</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Software Lifecycle</p>
<ul>
<li>软件有一个孕育、诞生、成长、成熟、
衰亡的生存过程。这个过程即为计算机
软件的生命周期(生存周期)</li>
<li>why need
<ul>
<li>从时间角度对软件开发和维护的复杂问题进行分解，把软件生存的漫长周期依次划分为若干个阶段，每个阶段有相对独立的任务，然后再逐步完成每个阶段的任务。</li>
<li>为软件人提供一个公共的框架，以便软件人的相互交流。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="chapter-4">Chapter 4</h2>
<ul>
<li>Evolutionary Models
<ul>
<li>prototype
<ul>
<li>类型
<ul>
<li>探索型(exploratory prototyping) 弄清需求</li>
<li>实验型(experimental prototyping)  验证方案</li>
<li>演化型(evolutionary prototyping)</li>
</ul>
</li>
<li>特征
<ul>
<li>可实际运行</li>
<li>它没有固定的生存期。它可能被扔掉，或者作为最终产品的一部分。</li>
<li>可为不同目标作原型</li>
<li>快速、廉价</li>
<li>是迭代过程的集成部分，即每次经用户评价后修改、运行，不断重复双方认可。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="chapter-5">Chapter 5</h2>
<ul>
<li>敏捷宣言
<ul>
<li>个体和互动 高于 流程和工具</li>
<li>工作的软件 高于 详尽的文档</li>
<li>客户合作 高于 合同谈判</li>
<li>响应变化 高于 遵循计划</li>
</ul>
</li>
<li></li>
</ul>
<h2 id="chapter-7">Chapter 7</h2>
<h3 id="requirements-engineering">Requirements Engineering</h3>
<ul>
<li>Inception</li>
<li>Elicitation</li>
<li>Elaboration</li>
<li>Negotiation</li>
<li>Specification
<ul>
<li>根据需求调查和需求分析的结果，进一步定义准确无误的产品需求，产生《产品需求规格说明书》</li>
</ul>
</li>
<li>Validation</li>
<li>Requirements management</li>
</ul>
<h3 id="quality-function-deployment">Quality Function Deployment</h3>
<ol>
<li>功能部署——确定系统功能的价值</li>
<li>信息部署——确定数据对象和事件</li>
<li>任务部署——确定系统的行为</li>
<li>价值分析——确定需求的优先级</li>
</ol>
<h3 id="non-functional-requirements">Non-Functional Requirements</h3>
<ul>
<li>quality attribute</li>
<li>performance attribute</li>
<li>security attribute</li>
<li>general system constraint</li>
</ul>
<h3 id="diagrams">diagrams</h3>
<p>Use-case / Class / State / Activity</p>
<h2 id="chapter-11">Chapter 11</h2>
<ul>
<li>Analysis model
<ul>
<li>focus on describing required data, function and behavior</li>
</ul>
</li>
</ul>
<h3 id="design-model">Design model</h3>
<ul>
<li>provide detail about software data structure, architecture, interfaces and components</li>
<li>4 kinds
<ul>
<li>Data/Class design——将分析类转换为实现类和数据结构</li>
<li>Architectural design——定义主要软件结构元素之间的关系</li>
<li>Interface design——定义软件元素、硬件元素和最终用户如何通信</li>
<li>Component-level design——转换结构元素到软件组件的过程描述中</li>
</ul>
</li>
</ul>
<h3 id="concepts">concepts</h3>
<ul>
<li>Architecture-软件的整体结构
<ul>
<li>体现了系统的模块化,抽象和信息隐藏,接口设计</li>
<li>举例
<ul>
<li>客户-服务器架构（Client-Server Architecture）</li>
<li>微服务架构（Microservices Architecture）</li>
<li>事件驱动架构（Event-Driven Architecture）</li>
<li>分层架构（Layered Architecture）</li>
</ul>
</li>
</ul>
</li>
<li>Pattern
<ul>
<li>The goal of a pattern：easy to reuse.</li>
<li>types:
<ul>
<li>Architecture Pattern
<ul>
<li>B/S, C/S</li>
</ul>
</li>
<li>Design Pattern</li>
<li>Idiom
<ul>
<li>a low-level pattern specific to a programming language</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Functional Independence
<ul>
<li>Cohesion 内聚
<ul>
<li>an indication of the relative functional strength of a module</li>
<li>功能内聚 分层内聚 通信内聚 顺序内聚 过程内聚 时间内聚 实用内聚（由高到低排列）</li>
</ul>
</li>
<li>Coupling 耦合
<ul>
<li>an indication of the relative interdependence among modules</li>
<li>非直接耦合 数据耦合 标记耦合 控制耦合 外部耦合 共用耦合 内容耦合 （ 由低到高排列）</li>
</ul>
</li>
<li>goal: 高内聚，低耦合</li>
</ul>
</li>
</ul>
<h2 id="chapter12-behavioral-modeling">Chapter12 Behavioral Modeling</h2>
<ul>
<li>what
the structure of the system, which comprise the software components, the externally visible properties of those components, and the relationships among them</li>
<li>The importance of architecture
<ul>
<li>for communication between all parties (stakeholders)</li>
<li>highlights early design decisions</li>
<li>constitutes a relatively small, intellectually graspable mode</li>
</ul>
</li>
<li>架构有什么用
<ul>
<li>分析设计在满足其规定要求方面的有效性</li>
<li>在进行设计更改仍然相对而言的阶段考虑架构替代方案容易</li>
<li>降低与软件构建相关的风险</li>
</ul>
</li>
</ul>
<h3 id="architecture-style">Architecture Style</h3>
<ul>
<li>定义内容
<ul>
<li>一组执行系统所需功能的构件</li>
<li>一组连接器，可以实现“通信、协调和组件之间的合作”</li>
<li>定义组件如何集成以形成系统的约束</li>
<li>语义模型，使设计人员能够通过分析系统组成部分的已知特性来理解系统的整体属性</li>
</ul>
</li>
<li>种类
<ul>
<li>数据流架构——批处理、管道和过滤器</li>
<li>调用和返回架构——主程序/子程序、面向对象系统、分层系统</li>
<li>独立组件架构——事件系统、触发器、监视器</li>
<li>虚拟机架构——解释器，基于规则的系统</li>
<li>仓库架构——数据库系统，黑板系统等</li>
</ul>
</li>
</ul>
<h2 id="chapter13-component-level-design">Chapter13 Component Level Design</h2>
<ul>
<li>一个模块化的、可部署的、可替换的系统部分，它封装了实现并公开了一组接口。</li>
</ul>
<h3 id="basic-design-principles">Basic Design Principles</h3>
<ol>
<li>开闭原则（OCP）——一个模块 [组件] 应该对扩展开放但对修改关闭</li>
<li>里氏替换原则（LSP）—— “子类应该可以替代它们的基类。</li>
<li>依赖倒置原则（DIP）——依赖于抽象。不要依赖实体
<ul>
<li>高层模块应该依赖于抽象（接口或抽象类）</li>
<li>抽象不应该依赖于具体实现，具体实现应该依赖于抽象</li>
</ul>
</li>
<li>接口分离原则 (ISP)——许多专用的接口都比一个通用接口好</li>
<li>发布重用等效原则 (REP)——重用的粒度就是发布的粒度</li>
<li>共同闭合原则（CCP）——同时修改的类应该放在一起</li>
<li>共同重用原则（CRP）——不能同时复用的类不应该放在一起</li>
</ol>
<h2 id="chapter14-user-interface-design">Chapter14 User Interface Design</h2>
<ul>
<li>黄金规则
<ul>
<li>用户控制操作</li>
<li>减少用户记忆负担</li>
<li>保持界面一致</li>
</ul>
</li>
</ul>
<h2 id="chapter-15-16-software-quality">Chapter 15-16 Software Quality</h2>
<ul>
<li>
<p>什么是软件质量
一个有效的软件过程，其应用方式创造了一个有用的产品，为生产它的人和使用它的人提供可衡量的价值</p>
</li>
<li>
<p>McCall’s Triangle of Quality</p>
<ul>
<li>产品修改</li>
<li>产品转移</li>
<li>产品运行</li>
</ul>
</li>
<li>
<p>The Cost of Quality</p>
<ul>
<li>在测试和维护阶段改正错误和缺陷的成本急剧增高</li>
<li>种类：
<ol>
<li>预防成本（COP）</li>
<li>评估成本（COA）</li>
<li>内部失败成本</li>
<li>外部失败成本</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="chapter-17-19-testing-strategy--techniques">Chapter 17-19. Testing Strategy &amp; Techniques</h2>
<ul>
<li>Verification vs. Validation
<ul>
<li>Verification: 确保软件能实现特定功能 building the product right</li>
<li>Validation: 确保软件可追溯到客户需求 building the right product</li>
</ul>
</li>
<li>测试策略——从小到大
<ul>
<li>单元测试</li>
<li>集成测试</li>
<li>系统测试</li>
<li>验收测试
<ul>
<li>α testing 由最终用户在开发人员站点进行</li>
<li>ß testing 在最终用户站点进行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="测试策略之unit-testing">测试策略之unit testing</h3>
<ul>
<li>内容：
<ul>
<li>接口</li>
<li>局部数据结构</li>
<li>边界条件</li>
<li>独立路径</li>
<li>错误处理路径</li>
</ul>
</li>
<li>stub——代替底层</li>
<li>driver——代替顶层
<ul>
<li>提供了一个框架用于设置输入参数，环境 ，执行单元</li>
</ul>
</li>
</ul>
<h3 id="测试策略之integration-testing">测试策略之integration testing</h3>
<ul>
<li>Top Down Integration
<ul>
<li>Advantage
<ul>
<li>A skeletal version of the program can exist early and allows demonstrations</li>
<li>Design errors may be found sooner.</li>
<li>Reduces the need for test drivers</li>
<li>It tends to make fault location easier</li>
</ul>
</li>
<li>Disadvantage
<ul>
<li>stubs could be expensive to build.</li>
</ul>
</li>
</ul>
</li>
<li>Bottom-Up Integration
<ul>
<li>Advantage
<ul>
<li>Particular useful for objects and reuse.</li>
<li>requiring no structural design information</li>
</ul>
</li>
<li>Disadvantage
<ul>
<li>The program as a whole does not exist until the last module is added.</li>
<li>requires test drivers, not test stubs.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="测试策略之system-testing充分运用基于计算机的系统">测试策略之system testing——充分运用基于计算机的系统</h3>
<ul>
<li>目的：
<ul>
<li>在将要运行的真实环境中测试整个系统</li>
<li>确保系统满足整体工作的要求</li>
<li>还要测试系统功能之外的方面</li>
<li>结果有时用于系统验收</li>
<li>验证软件用户手册</li>
<li>估计可靠性和可维护性</li>
</ul>
</li>
</ul>
<h3 id="测试方法">测试方法</h3>
<ul>
<li>黑盒测试（功能）</li>
<li>白盒测试（结构）</li>
</ul>
<h2 id="chapter-21-software-configuration-management">Chapter 21 Software configuration management</h2>
<h3 id="the-scm-process">The SCM Process</h3>
<ol>
<li>identification</li>
<li>change control</li>
<li>version control</li>
<li>configuration auditing</li>
<li>reporting</li>
</ol>
<ul>
<li>Software configuration item</li>
</ul>
<h2 id="chapter-22--project-management-concept">Chapter 22  Project Management Concept</h2>
<h3 id="4-p">4 p</h3>
<ul>
<li>people</li>
<li>product
<ul>
<li>scopes
<ol>
<li>context</li>
<li>information objectives</li>
<li>function and performance</li>
</ol>
</li>
</ul>
</li>
<li>Process
<ul>
<li>Consider project characteristics</li>
<li>Determine the degree of rigor required</li>
<li>Define a task set for each software engineering activity</li>
</ul>
</li>
<li>Project
<ol>
<li>从正确的基础上开始工作——首先通过努力理解要解决的问题，然后设定现实的目标和期望来实现的</li>
<li>保持动力——项目经理必须提供激励措施，将人员流动率控制在最低限度，团队应在其执行的每项任务中强调质量，高级管理人员应尽一切可能远离团队</li>
<li>跟踪进度——作为质量保证活动的一部分，随着工作产品（例如模型、源代码、测试用例集）的生成和批准（使用正式的技术评审），进度会被跟踪。</li>
<li>做出明智的决定——项目经理和软件团队的决定应该是“保持简单”</li>
<li>进行事后分析——建立一个一致的机制来提取每个项目的经验教训</li>
</ol>
</li>
</ul>
<h3 id="w5hh">W5HH</h3>
<ol>
<li>Why is the system being developed?——为什么</li>
<li>What will be done? ——做什么</li>
<li>When will it be accomplished?——什么时候做</li>
<li>Who is responsible?——谁负责</li>
<li>Where are they organizationally located?——其他人的组织机构位于何处</li>
<li>How will the job be done technically and managerially?——如何完成技术工作和管理工作</li>
<li>How much of each resource (e.g., people, software, tools, database) will be needed?——每种资源需要多少</li>
</ol>
<h3 id="task-set-">Task set =</h3>
<ul>
<li>Software engineering tasks</li>
<li>Work products</li>
<li>Quality assurance points</li>
<li>Milestones</li>
</ul>
<h3 id="software-engineering-activity">software engineering activity</h3>
<ul>
<li>需求分析</li>
<li>设计</li>
<li>软件开发</li>
<li>软件部署</li>
<li>软件维护</li>
<li>项目管理</li>
<li>质量保证</li>
<li>配置管理</li>
<li>文档编写</li>
</ul>
<h2 id="chapter-23-process-and-project-metrics">Chapter 23 Process and Project Metrics</h2>
<ul>
<li>意义
<ol>
<li>评估正在进行的项目的状态</li>
<li>跟踪潜在风险</li>
<li>在问题造成不良影响前发现风险</li>
<li>调整工作流程或任务</li>
<li>评估项目团队控制软件工作产品质量的能力</li>
</ol>
</li>
</ul>
<h3 id="process-measurement">Process Measurement</h3>
<ul>
<li>根据过程中获得的一系列数据或软件工程任务的特性来进行测量。</li>
<li>Software Process Improvement (SPI)</li>
<li>5 Metrics
<ul>
<li>Quality-related</li>
<li>Productivity-related</li>
<li>Statistical SQA data</li>
<li>Defecti removal effciency</li>
<li>Reuse data</li>
</ul>
</li>
</ul>
<h3 id="项目度量">项目度量</h3>
<ul>
<li>三个方面
<ul>
<li>如期</li>
<li>质量</li>
<li>成本</li>
</ul>
</li>
</ul>
<h3 id="chapter-24-25-project-estimation--scheduling">Chapter 24-25 Project Estimation &amp; Scheduling</h3>
<h3 id="scope">scope</h3>
<ul>
<li>Scope refers to all the work involved in creating the
products of the project and the processes used to
create them. It defines what is or is not to be done</li>
<li>项目范围的内容
<ul>
<li>交付给最终用户的功能和特性</li>
<li>输入和输出的数据</li>
<li>由于使用软件而呈现给用户的“内容”</li>
<li>性能、约束、接口、和约束系统的可靠性</li>
</ul>
</li>
</ul>
<h3 id="work-breakdown-structure-wbs">Work Breakdown Structure (WBS)</h3>
<ul>
<li>进行WBS的五种方法
<ol>
<li>使用指南：一些组织提供的指南</li>
<li>类比方法：审查类似项目的 WBS，并根据我们的项目 进行定制。</li>
<li>自上而下的方法：从项目中最大的项目开始，并将它们分解</li>
<li>自下而上的方法：从详细的任务开始，并将它们汇总</li>
<li>思维导图方法：以非线性格式写下任务，然后创建 WBS 结构</li>
</ol>
</li>
</ul>
<h3 id="估计方法">估计方法</h3>
<ul>
<li>基于代码行的估计
<ul>
<li>优点：易于测量、容易自动化</li>
<li>缺点：仅限于代码不能用于设计、依赖于语言、没有考虑功能的复杂性、与设计的好坏挂钩</li>
</ul>
</li>
<li>基于功能点的估计
<ul>
<li>优点：
<ol>
<li>可用于最早的需求阶段</li>
<li>独立于编程语言、产品设计或开发风格</li>
<li>用户视图，而不是实现视图</li>
<li>可用于衡量非编码活动</li>
<li>存在大量历史数据</li>
<li>有据可查</li>
</ol>
</li>
<li>缺点：
<ol>
<li>无法直接计算现有产品（源代码）的 FP 内容</li>
<li>难以自动化</li>
<li>FP 不反映语言、设计或风格差异</li>
<li>FP 设计用于估计商业数据处理应用</li>
<li>主观计数</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="项目调度">项目调度</h3>
<ol>
<li>项目为什么会延期
不切实际的截止日期
需求的变化
低估工作量
不可预测的风险
技术难题
人为困难
沟通不畅
未能认识到项目落后于计划或缺乏纠正问题的行动</li>
<li>调度的原则
划分——定义多个不同的任务
相互依赖性——明确任务的相互关系
工作量确认——确保人力资源可用
确定责任——明确责任承担者
明确输出结果——确定活动产生的结果
确定里程碑——进行质量审查</li>
<li>调度的步骤
<ol>
<li>定义任务集——WBS</li>
<li>安排活动</li>
<li>绘制项目网络图</li>
<li>关键路径分析</li>
<li>使用甘特图进行调度</li>
<li>进度跟踪</li>
</ol>
</li>
</ol>
<h2 id="chapter-26-risk-management">Chapter 26 Risk Management</h2>
<ul>
<li>
<p>Reactive Risk Management</p>
</li>
<li>
<p>Proactive Risk Management</p>
<ul>
<li>formal risk analysis is performed</li>
<li>corrects the root causes of risk</li>
</ul>
</li>
<li>
<p>Risk Management Paradigm</p>
<ol>
<li>Risk identification</li>
<li>Risk analysis</li>
<li>Risk planning</li>
<li>Risk monitoring</li>
</ol>
</li>
<li>
<p>RMMM</p>
<ul>
<li>Mitigation</li>
<li>Monitoring</li>
<li>Management</li>
</ul>
</li>
</ul>
<h2 id="常用图">常用图</h2>
<ul>
<li>用例图</li>
<li>类图</li>
<li>活动图
<ul>
<li>变形：泳道图</li>
</ul>
</li>
<li>顺序图</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>TinyTinyRSS-OPML-to-MD-Table</title>
      <link>https://euds63.github.io/2023/tinytinyrss-opml-to-md-table/</link>
      <pubDate>Sat, 29 Apr 2023 00:59:40 +0800</pubDate>
      
      <guid>https://euds63.github.io/2023/tinytinyrss-opml-to-md-table/</guid>
      <description>记录&lt;a href=&#34;https://github.com/EuDs63/TinyTinyRSS-OPML-to-MD-Table&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34; &gt;EuDs63/TinyTinyRSS-OPML-to-MD-Table&lt;/a&gt; 的过程</description>
      <content:encoded><![CDATA[<h1 id="tinytinyrss-opml-to-md-table">TinyTinyRSS-OPML-to-MD-Table</h1>
<h2 id="需求由来">需求由来：</h2>
<p>我很喜欢读博客。但发现总有些很有趣的博客等着发现。所以我关注了些推荐博客的频道。同时，我也想分享些自己喜欢的博客，但每次去手动复制又显得太麻烦了。所以就想着做一个自动化的方式，顺带着也可以学习下Github Action.</p>
<h2 id="历程">历程</h2>
<ol>
<li>大部分时间是花在了如何获取opml文件上。Tiny Tiny RSS所给的文档较为精简，而网上相关的资料大都仅局限于如何部署。所以这一段只能是自己摸索。
<ul>
<li>TinyTinyRSS的网页版有给一个按钮能导出OPML，而这个按钮所指向的网址是<code>http://example.com/tt-rss/backend.php?op=opml&amp;method=export'</code>。但它是有个鉴权操作的。需要登录。</li>
<li>它的示例中有提供了一个登录的api调用，所以我开始的想法也是顺着这个来。想着直接添加data参数。但尝试了多种添加方式无果。</li>
<li>后来注意到登录成功是会返回session值的，于是先用curl试验了下。
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 登录并获取Session ID</span>
</span></span><span class="line"><span class="cl"><span class="nv">SESSION</span><span class="o">=</span><span class="k">$(</span>curl -s -d <span class="s1">&#39;{&#34;op&#34;:&#34;login&#34;,&#34;user&#34;:&#34;user&#34;,&#34;password&#34;:&#34;password&#34;}&#39;</span> http://example.com/tt-rss/api/ <span class="p">|</span> python -c <span class="s2">&#34;import sys, json; print(json.load(sys.stdin)[&#39;content&#39;][&#39;session_id&#39;])&#34;</span><span class="k">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#获得opml文件</span>
</span></span><span class="line"><span class="cl">curl -o my_tiny_tiny_rss.opml <span class="s1">&#39;http://example.com/tt-rss/backend.php?op=opml&amp;method=export&#39;</span> --cookie <span class="s2">&#34;ttrss_sid=</span><span class="si">${</span><span class="nv">SESSION</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span></code></pre></div></li>
<li>转写成python是用的request。其实现在回头想想，这应该是蛮基础的操作，而且session之前也有接触过。如果早点想起来的话是可以少花些时间的。</li>
</ul>
</li>
<li>opml的解析有现成的库，用就是了。</li>
<li>然后就是把一些个人信息抽出来写在配置文件中。这里踩了一个坑。<code>data = {'op': 'login', 'user': user, 'password': password}</code>,我开始的时候是这样写的<code>data = f&quot;{{'op': 'login', 'user': {user}, 'password': {password}}}&quot;</code>。后者虽然在形式上看着一样，但前者是json对象，后者是字符串。这里也给我提了个醒：Python虽然有动态类型这个特性，但还是要注意类型错误。</li>
<li>最后是使用Github Action。之前也有使用过，但是是直接用的别人写好的workflow。所以也花了些时间学习了下。遇到的几个问题是
<ul>
<li>Yml文件的格式问题。这个可以用<a href="https://codebeautify.org/yaml-validator"  target="_blank" rel="noopener" >YAML Validator</a>来检查。Vscode应该也有相应的插件吧。</li>
<li>运行时需要用到的变量，是用的secret。我之前以为secret的value只能是字符串。但<a href="https://nekokiku.cn/2020/12/22/2020-12-22-Github-Action%E4%B8%ADpython%E8%8E%B7%E5%8F%96%E4%BB%93%E5%BA%93%E7%9A%84secrets/"  target="_blank" rel="noopener" >Github Action中python获取仓库的secrets</a>中提到，可以把一整个yml文件放在value里面。所以我就想那json文件应该也可以。试了下确实能行。这样我的代码需要修改的地方就很少了。</li>
<li>workflow的触发方式,要添加手动触发，需加上<code>workflow_dispatch:</code></li>
</ul>
</li>
</ol>
<h2 id="学到的知识">学到的知识</h2>
<ul>
<li>pipe和python的结合。下面这段是ChatGPT写的，太妙了。
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nv">SESSION</span><span class="o">=</span><span class="k">$(</span>curl -s -d <span class="s1">&#39;{&#34;op&#34;:&#34;login&#34;,&#34;user&#34;:&#34;user&#34;,&#34;password&#34;:&#34;password&#34;}&#39;</span> http://example.com/tt-rss/api/ <span class="p">|</span> python -c <span class="s2">&#34;import sys, json; print(json.load(sys.stdin)[&#39;content&#39;][&#39;session_id&#39;])&#34;</span><span class="k">)</span>
</span></span></code></pre></div></li>
<li>Github Action的使用</li>
<li>python request</li>
</ul>
<h2 id="尾巴">尾巴</h2>
<p>这个项目算是个很小的项目，但我还是花了半天的时间，而且是在ChatGPT的帮助下。之前看到这样一种说法，搜索引擎大幅降低了普通人获取知识的难度，而ChatGPT在此基础上更是降低了十分客观的一个量。结合自己这次的经历，我十分认同这个观点。通过我对背景的补充和提问，ChatGPT让我省去了花费在各种教程和不完善的文档上所要消费的时间。这比搜索引擎所做到的交互要更自然。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://tt-rss.org/wiki/ApiReference"  target="_blank" rel="noopener" >API Reference</a></li>
<li><a href="https://www.cnblogs.com/jiangleads/p/10636696.html"  target="_blank" rel="noopener" >curl命令实现上网认证登录</a></li>
<li><a href="https://nekokiku.cn/2020/12/22/2020-12-22-Github-Action%E4%B8%ADpython%E8%8E%B7%E5%8F%96%E4%BB%93%E5%BA%93%E7%9A%84secrets/"  target="_blank" rel="noopener" >Github Action中python获取仓库的secrets</a></li>
<li><a href="https://codebeautify.org/yaml-validator"  target="_blank" rel="noopener" >YAML Validator</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>感兴趣的知识/待细看</title>
      <link>https://euds63.github.io/2023/%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/%E5%BE%85%E7%BB%86%E7%9C%8B/</link>
      <pubDate>Sun, 16 Apr 2023 16:03:44 +0800</pubDate>
      
      <guid>https://euds63.github.io/2023/%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86/%E5%BE%85%E7%BB%86%E7%9C%8B/</guid>
      <description>记录我感兴趣的知识或者说需要细看的内容</description>
      <content:encoded><![CDATA[<h1 id="感兴趣的知识待细看">感兴趣的知识/待细看</h1>
<p><em>有些知识，我觉得有趣，平时也还算经常看到，但只是一知半解，所以下定决心要将其掌握。我觉得要掌握一个知识，有一个比较好的办法就是写个教程，让不知道的人看了教程后也能对这个知识有相当的了解。所谓教学相长也。又因为知之甚少而难以开一篇专门去叙述，所以权记录于此，作为备忘</em></p>
<p><em>网上冲浪的时候，或主动或被动，常会看到些我感兴趣的内容。有的时候是内容比较深，有的时候是内容让我有些感想。常常，我会选择不关闭它们，想着有时间一定要好好看，并记录下自己的感想。然后&hellip;通常就没有然后了。这并不是件好事。所以我就想着记录在这里，也算是对自己的一种监督，或者说Learn In Public。</em></p>
<h2 id="数字货币">数字货币</h2>
<ul>
<li><input disabled="" type="checkbox"> <a href="https://mp.weixin.qq.com/s/wEzbgXh1BDxYjz-xkHs0Gg"  target="_blank" rel="noopener" >匿名是一种设计</a></li>
<li><input disabled="" type="checkbox"> <a href="https://bitcoin.org/bitcoin.pdf"  target="_blank" rel="noopener" >Bitcoin: A Peer-to-Peer Electronic Cash System</a></li>
</ul>
<h2 id="加密">加密</h2>
<ul>
<li><input disabled="" type="checkbox"> <a href="https://program-think.blogspot.com/2010/02/introduce-digital-certificate-and-ca.html#verify_file"  target="_blank" rel="noopener" >数字证书及 CA 的扫盲介绍</a></li>
<li><input disabled="" type="checkbox"> <a href="https://jysperm.me/2017/09/gpg-and-e2ee/"  target="_blank" rel="noopener" >GPG 与端到端加密：论什么才是可以信任的</a></li>
</ul>
<h2 id="interpreter">interpreter</h2>
<ul>
<li><input disabled="" type="checkbox"> <a href="https://ruslanspivak.com/lsbasi-part1/"  target="_blank" rel="noopener" >https://program-think.blogspot.com/2010/02/introduce-digital-certificate-and-ca.html#verify_file</a></li>
</ul>
<h2 id="gpt">GPT</h2>
<ul>
<li><input disabled="" type="checkbox"> <a href="https://viper.cs.columbia.edu/"  target="_blank" rel="noopener" >ViperGPT: Visual Inference via Python Execution for Reasoning</a></li>
<li><input disabled="" type="checkbox"> <a href="https://arxiv.org/abs/2304.03442"  target="_blank" rel="noopener" >Generative Agents: Interactive Simulacra of Human Behavior</a></li>
</ul>
<h2 id="diffusion">diffusion</h2>
<ul>
<li><input disabled="" type="checkbox"> <a href="https://www.biorxiv.org/content/10.1101/2022.11.18.517004v2.full.pdf"  target="_blank" rel="noopener" >High-resolution image reconstruction with latent diffusion models from humanbrain activity</a></li>
</ul>
<h2 id="神经网络">神经网络</h2>
<ul>
<li><input disabled="" type="checkbox"> <a href="https://zhuanlan.zhihu.com/p/104475016"  target="_blank" rel="noopener" >[干货]深入浅出LSTM及其Python代码实现</a></li>
<li><input disabled="" type="checkbox"> <a href="https://www.cnblogs.com/subconscious/p/5058741.html"  target="_blank" rel="noopener" >神经网络浅讲：从神经元到深度学习</a></li>
</ul>
<h2 id="博客">博客</h2>
<ul>
<li><input checked="" disabled="" type="checkbox"> <a href="https://luolei.org/gfw/"  target="_blank" rel="noopener" >GFW之父方滨兴讲座后杂想</a></li>
<li><input disabled="" type="checkbox"> <a href="https://lutaonan.com/blog/reason-why-your-blog-is-not-alive/"  target="_blank" rel="noopener" >为什么无法坚持写博客</a></li>
<li><input disabled="" type="checkbox"> <a href="https://yzyyz.top/archives/js_snake.html"  target="_blank" rel="noopener" >JS初探，给博客首页添加一个贪吃蛇热力图</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="https://plumz.me/archives/12906/"  target="_blank" rel="noopener" >你所热爱的，就是你的生活</a></li>
<li><input disabled="" type="checkbox"> <a href="https://www.zxch3n.com/local-first/"  target="_blank" rel="noopener" >译：本地优先软件 Local-first software</a></li>
<li><input disabled="" type="checkbox"> <a href="https://densecollections.top/posts/4074/"  target="_blank" rel="noopener" >MIT计算机科学课堂中学不到的知识</a></li>
<li><input disabled="" type="checkbox"> <a href="https://github.com/XXIIVV/webring"  target="_blank" rel="noopener" >XXIIVV/webring</a></li>
</ul>
<h2 id="开源">开源</h2>
<ul>
<li><input disabled="" type="checkbox"> <a href="https://github.com/zloirock/core-js/blob/master/docs/2023-02-14-so-whats-next.md"  target="_blank" rel="noopener" >So, what&rsquo;s next?</a></li>
</ul>
<h2 id="网络">网络</h2>
<ul>
<li><input disabled="" type="checkbox"> <a href="https://plantegg.github.io/2019/05/15/%E5%B0%B1%E6%98%AF%E8%A6%81%E4%BD%A0%E6%87%82%E7%BD%91%E7%BB%9C--%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E5%8C%85%E7%9A%84%E6%97%85%E7%A8%8B/"  target="_blank" rel="noopener" >就是要你懂网络&ndash;一个网络包的旅程</a></li>
<li><input disabled="" type="checkbox"> <a href="https://gfw.report/publications/usenixsecurity23/zh/"  target="_blank" rel="noopener" >中国的防火长城是如何检测和封锁完全加密流量的</a></li>
<li><input disabled="" type="checkbox"> <a href="https://www.iserica.com/posts/network101-socket-function-wrappers/"  target="_blank" rel="noopener" >「网络编程101」来封装一个简单的TCP服务吧！</a></li>
</ul>
<h2 id="机械键盘">机械键盘</h2>
<ul>
<li><input disabled="" type="checkbox"> <a href="https://freemind.pluskid.org/electronics/5x12-keyboard-debugging2/"  target="_blank" rel="noopener" >记一次有意义的熬夜</a></li>
</ul>
<h2 id="前端">前端</h2>
<ul>
<li><input disabled="" type="checkbox"> <a href="https://xlog.daidr.me/card-page"  target="_blank" rel="noopener" >写一个炫酷的个人名片页</a></li>
<li><input disabled="" type="checkbox"> <a href="https://www.joshwcomeau.com/css/interactive-guide-to-flexbox/"  target="_blank" rel="noopener" >An Interactive Guide to Flexbox</a></li>
</ul>
<h2 id="杂">杂</h2>
<ul>
<li><input disabled="" type="checkbox"> <a href="https://www.physics.umd.edu/courses/Phys606/spring_2011/einstein_electrodynamics_of_moving_bodies.pdf"  target="_blank" rel="noopener" >ON THE ELECTRODYNAMICS OF MOVINGBODIES</a></li>
<li><input disabled="" type="checkbox"> <a href="https://en.wikipedia.org/wiki/Theory_of_mind"  target="_blank" rel="noopener" >Theory of mind</a></li>
<li><input disabled="" type="checkbox"> <a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html"  target="_blank" rel="noopener" >GAMES101: 现代计算机图形学入门</a></li>
<li><input disabled="" type="checkbox"> <a href="https://missing-semester-cn.github.io/"  target="_blank" rel="noopener" >The Missing Semester of Your CS Education</a></li>
<li><input disabled="" type="checkbox"> <a href="https://www.amazon.com/When-Brains-Dream-Exploring-Science/dp/1324002832"  target="_blank" rel="noopener" >When Brains Dream: Exploring the science and mystery of sleep</a></li>
<li><input disabled="" type="checkbox"> <a href="https://www.kivinsae.com/2023/05/17/2023-05-17-no_sophism/"  target="_blank" rel="noopener" >关于 初码先生 某推中典型诡辩论部分的拆解</a>
学习下辩论技巧</li>
<li><input disabled="" type="checkbox"> <a href="https://seuite.github.io/blog/2019-04/%E7%BC%96%E7%A8%8B%E8%AD%A6%E5%8F%A5-1301-30/"  target="_blank" rel="noopener" >编程警句 130（1-30）</a> 有趣的句子</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>表单学习</title>
      <link>https://euds63.github.io/2023/%E8%A1%A8%E5%8D%95%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Thu, 30 Mar 2023 23:52:16 +0800</pubDate>
      
      <guid>https://euds63.github.io/2023/%E8%A1%A8%E5%8D%95%E5%AD%A6%E4%B9%A0/</guid>
      <description>发现原来表单要做得符合直觉也是有些学问在里面的，遂记录如下。</description>
      <content:encoded><![CDATA[<h1 id="表单学习">表单学习</h1>
<p><em>偶然间看到了篇不错的文档，<a href="https://www.chromium.org/developers/design-documents/create-amazing-password-forms/"  target="_blank" rel="noopener" >Create Amazing Password Forms</a>,才发现原来表单要做得符合直觉也是有些学问在里面的，遂记录如下。</em></p>
<h2 id="group-related-fields-in-a-single-form">Group related fields in a single form</h2>
<p>我之前习惯把注册和登录分开来做，使用的不少网站也是这样。所以就导致了一种情况，在使用浏览器的密码自动保存时，往往注册完后要登录，就得再输一遍代码。但是我还不知道具体要怎么实现。</p>
<h2 id="use-autocomplete-attributes">Use autocomplete attributes</h2>
<p>autocomplete这个attribute我还是第一次见，查阅文档后，发现这个还蛮有用的。<a href="https://www.chromium.org/developers/design-documents/form-styles-that-chromium-understands/"  target="_blank" rel="noopener" >Password Form Styles that Chromium Understands</a>
e.g. <code>&lt;input name=bc autocomplete=&quot;section-home homeAddress&quot;&gt;</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"> <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;text&#34;</span> <span class="na">autocomplete</span><span class="o">=</span><span class="s">&#34;username&#34;</span><span class="p">&gt;</span> 
</span></span><span class="line"><span class="cl"> <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;password&#34;</span> <span class="na">autocomplete</span><span class="o">=</span><span class="s">&#34;current-password&#34;</span><span class="p">&gt;</span> 
</span></span><span class="line"><span class="cl"> <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;submit&#34;</span> <span class="na">value</span><span class="o">=</span><span class="s">&#34;Sign In!&#34;</span><span class="p">&gt;</span> 
</span></span></code></pre></div><p>而关于autocomplete和autofill的区别</p>
<p>我查了下有这样的回答</p>
<ul>
<li>autocomplete是HTML5新增的属性，用于指定浏览器是否应该启用表单自动完成功能，以及提供有关字段中预期信息类型的指导。</li>
<li>autofill是浏览器自带的自动填充功能，它会根据用户之前输入过的值来预测用户下一次可能输入的值，并在用户输入时自动填充。autofill不仅考虑了之前输入过的值，还考虑了字段的含义和结构。例如，Google Chrome实现了解析输入字段以猜测其类型和结构。</li>
</ul>
<h2 id="use-hidden-fields-for-implicit-information">Use hidden fields for implicit information</h2>
<p>这点对于我来说也是挺新鲜的。才知道尽管有些信息没必要让用户输入，但还是有必要在表单中所包含，以便于密码管理器。</p>
<p>文档中是这样讲的</p>
<blockquote>
<p>the user agent is allowed to provide the user with autocompletion values, but does not provide any further information about what kind of data the user might be expected to enter. User agents would have to use heuristics to decide what autocompletion values to suggest.</p>
</blockquote>
<p>目前我的理解是，autocomplete用来提升浏览器字段的类型，而autofill用来控制是否使用该功能</p>
<h2 id="尾巴">尾巴</h2>
<p>还是第一次看html的文档，不是太能看得下去，因为内容太多了，信息量比较大，但确实有用</p>
<ul>
<li>参考链接
<ul>
<li><a href="https://www.chromium.org/developers/design-documents/create-amazing-password-forms/"  target="_blank" rel="noopener" >Create Amazing Password Forms</a></li>
<li><a href="https://www.chromium.org/developers/design-documents/form-styles-that-chromium-understands/"  target="_blank" rel="noopener" >Password Form Styles that Chromium Understands</a></li>
<li><a href="https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofilling-form-controls%3A-the-autocomplete-attribute"  target="_blank" rel="noopener" >autocomplete</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Linux学习笔记</title>
      <link>https://euds63.github.io/2023/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 19 Mar 2023 18:38:50 +0800</pubDate>
      
      <guid>https://euds63.github.io/2023/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>Linux学习笔记</description>
      <content:encoded><![CDATA[<h2 id="linux命令">Linux命令</h2>
<ul>
<li><code>ctrl + C</code> 打断执行</li>
<li><code>pwd</code> 输出当前位置</li>
<li><code>cmd1;cmd2</code> 首先运行命令1，然后运行命令2</li>
<li><code>cmd1&amp;&amp;cmd2</code> 仅在命令1成功结束时才运行命令2</li>
<li><code>cmd1||cmd2</code> 仅当命令1失败时才运行命令2</li>
<li><code>strace</code>  追踪程序系统调用</li>
<li><code>touch</code> 新建文件,内容为空</li>
<li><code>cat</code>
<ul>
<li><code>cat filename</code> To view a single file</li>
<li><code>cat [filename-whose-contents-is-to-be-copied] &gt; [destination-filename]</code> Copy the contents of one file to another file.</li>
<li><code>cat file1 &gt;&gt; file2</code> Cat command can append the contents of one file to the end of another file.</li>
</ul>
</li>
<li>管道；用<code>|</code>连接两个命令，以前面一个命令的输出作为后面命令的输入
<ul>
<li><code>strace -f gcc a.c 2&gt;&amp;1 | vim -</code> This will pipe both stdout and stderr to vim. The <code>-</code> argument tells vim to read from stdin.</li>
<li><code>strace pmap 152 |&amp; vim - </code>
<code>|&amp;</code> : This is a shorthand for <code>2&gt;&amp;1 |</code> in bash and zsh. It passes both standard output and standard error of one command as input to another.</li>
</ul>
</li>
<li><code>sort -nk 6</code> 依第6列升序排列</li>
<li>执行多次，或循环执行
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1">#for i in {1..5}; do  // while true; do</span>
</span></span><span class="line"><span class="cl">&gt;  <span class="nb">command</span> 
</span></span><span class="line"><span class="cl">&gt;done
</span></span></code></pre></div></li>
<li>crontab的使用
<ul>
<li><code>crontab -e</code></li>
<li>注意：crontab运行的环境并不包含docker命令。需要指定完整的路径。</li>
</ul>
</li>
<li><code>lsof -i:端口号</code>查看端口占用情况</li>
<li><code>kill -9 PID</code> 杀掉对应的进程</li>
<li><code>grep</code> (global regular expression)  用于查找文件里符合条件的字符串或正则表达式</li>
<li><code>which</code> 查找安装路径 如<code>which docker</code></li>
<li><code>ls -l</code> 详细信息</li>
<li><code>~/.bashrc</code>是 Bash shell 在每次启动时都会自动执行的一个脚本文件,可以用于设置环境变量、别名和一些其他 Bash shell 配置。
<ul>
<li><code>source /opt/rh/devtoolset-9/enable</code> 更新gcc版本</li>
<li>export PS1=&rsquo;[][\W]$ []&rsquo; 修改PS1变量，让其更加简洁。PS1的默认设置为<code>\[\][\u@\h \W]\$ \[\]</code></li>
</ul>
</li>
<li><code>tar</code>
<ul>
<li><code>tar cvf file.tar *.c</code> creates a tar file called file.tar which is the Archive of all .c files in current directory.</li>
<li><code>tar xvf file.tar</code> extracts files from Archives.</li>
<li><code>z</code>tells tar command that creates tar file using gzip 即<code>tar.gz</code></li>
</ul>
</li>
<li>可以利用 TAB 补全查看所有可用的命令选项(连按两次 TAB 键)</li>
</ul>
<h2 id="汇编相关">汇编相关</h2>
<ul>
<li><code>objdump -d filename</code> print the assembler content of the sections capable of execution.</li>
<li><code>objdump -s filename</code>  print the complete content of all the sections of the file</li>
</ul>
<h2 id="gcc">gcc</h2>
<ul>
<li><code>gcc - E a.c</code> 对a.c进行宏展开</li>
<li>升级gcc版本到gcc9 <a href="https://blog.csdn.net/xunye_dream/article/details/108918316"  target="_blank" rel="noopener" >CentOS7 升级gcc版本到gcc9</a>
<code>source /opt/rh/devtoolset-9/enable</code></li>
<li><code>-static</code> 静态编译，省去动态链接相关的系统调用</li>
</ul>
<h2 id="vim">vim</h2>
<ul>
<li>cmd模式
<ul>
<li><code>:!cmd </code> execute a shell command from within Vim
<ul>
<li><code>!gcc %</code> 编译</li>
<li><code>!xxd</code>  将当前文件转换为十六进制表示并显示在终端中</li>
<li><code>%!xxd</code> 将当前文件的内容通过管道传递给外部命令xxd，并将其输出替换为当前文件的内容</li>
</ul>
</li>
<li><code>:set nu</code> 显示行号</li>
<li><code>:set wrap</code></li>
<li><code>:%!grep execve</code></li>
<li><code>:%! grep -v ENOENT</code></li>
<li><code>:%s/term/another_term/g </code> 替换</li>
</ul>
</li>
<li>visual模式 按v进入
<ul>
<li><code>y</code> 复制选中内容</li>
<li><code>d</code> 删除</li>
</ul>
</li>
<li><code>u</code> undo</li>
<li></li>
</ul>
<h2 id="gdb">gdb</h2>
<ul>
<li>编译时要带<code>-g</code></li>
<li><code>bt</code> :but trace</li>
</ul>
<hr>
<h2 id="参考链接">参考链接</h2>
<ul>
<li><a href="https://www.geeksforgeeks.org/cat-command-in-linux-with-examples/"  target="_blank" rel="noopener" >Cat command in Linux with examples</a></li>
<li><a href="https://blog.csdn.net/xunye_dream/article/details/108918316"  target="_blank" rel="noopener" >CentOS7 升级gcc版本到gcc9</a></li>
<li><a href="https://jyywiki.cn/OS/2022/"  target="_blank" rel="noopener" >操作系统：设计与实现 (2022 春季学期)</a></li>
<li><a href="https://blog.csdn.net/lc013/article/details/103775702"  target="_blank" rel="noopener" >Linux 定时执行shell 脚本</a></li>
<li><a href="https://www.geeksforgeeks.org/tar-command-linux-examples"  target="_blank" rel="noopener" >tar command in Linux with examples</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>收藏夹的使用</title>
      <link>https://euds63.github.io/2023/%E6%94%B6%E8%97%8F%E5%A4%B9%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 18 Mar 2023 23:45:18 +0800</pubDate>
      
      <guid>https://euds63.github.io/2023/%E6%94%B6%E8%97%8F%E5%A4%B9%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>收藏夹和JavaScript的结合实现实用小功能</description>
      <content:encoded><![CDATA[<h1 id="收藏夹的使用">收藏夹的使用</h1>
<!-- raw HTML omitted -->
<h2 id="bing转google搜索">Bing转Google搜索</h2>
<ul>
<li>描述：我日常搜索引擎是使用bing，但有些时候bing的内容我不是很满意，需要在Google上再次搜索；由于new bing的存在，我不想更换默认搜索引擎，但打开Google，再次搜索这个操作又很麻烦，所以就添加了一条收藏夹</li>
<li>代码详解：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">currentUrl</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span><span class="p">;</span> <span class="c1">//获取当前连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">reg</span> <span class="o">=</span> <span class="sr">/q=([^&amp;]+)/</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">currentUrl</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">reg</span><span class="p">);</span> <span class="c1">//使用正则表达式进行匹配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">googleUrl</span> <span class="o">=</span> <span class="s2">&#34;https://www.google.com/search?q=&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">resultUrl</span> <span class="o">=</span> <span class="nx">googleUrl</span><span class="o">+</span><span class="nx">res</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">//拼接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">window</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="nx">resultUrl</span><span class="p">,</span><span class="s1">&#39;_self&#39;</span><span class="p">).</span><span class="nx">close</span><span class="p">();</span><span class="c1">//打开新网站，并关闭原网站
</span></span></span></code></pre></div></li>
<li>书签URL
{% note success %}
<code>javascript:var currentUrl = window.location.href;var reg = /q=([^&amp;]+)/;var res = currentUrl.match(reg);var googleUrl = &quot;https://www.google.com/search?q=&quot;;var resultUrl = googleUrl+res[1];window.open(resultUrl,'_self').close();</code>
{% endnote %}</li>
<li>注：正则表达式是让new bing写的，感觉有种ntr的美</li>
</ul>
<h2 id="网易云解除歌单限制">网易云解除歌单限制</h2>
<ul>
<li>描述：网易云音乐网页端对歌单显示数量有限制，只显示20条，而我不希望因此下载客户端，于是添加了该书签。</li>
<li>代码：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="line"><span class="cl"><span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span><span class="o">=</span><span class="s2">&#34;os=pc&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">reload</span><span class="p">();</span><span class="c1">//重新加载网页
</span></span></span></code></pre></div></li>
<li>收藏夹URL
{% note success %}
<code>javascript:document.cookie=&quot;os=pc&quot;;window.location.reload();</code>
{% endnote %}</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>博客搭建</title>
      <link>https://euds63.github.io/2023/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Mon, 13 Mar 2023 12:50:17 +0800</pubDate>
      
      <guid>https://euds63.github.io/2023/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</guid>
      <description>记录博客搭建的过程,及途中遇到的问题和解决方式</description>
      <content:encoded><![CDATA[<h2 id="过程">过程</h2>
<p><em>记录博客搭建的过程</em></p>
<ol>
<li>框架是选用的<a href="https://hexo.io/zh-cn/docs/"  target="_blank" rel="noopener" >Hexo</a>,主题选用的是<a href="https://hexo.fluid-dev.com/docs"  target="_blank" rel="noopener" >Fluid</a>,本地部署十分顺利，跟着教程来就行。</li>
<li>调整配置的时候遇到了问题，我刚开始是直接使用<code>npm install --save hexo-theme-fluid</code>，但改配置的时候虽然有文档，但各项配置的位置不知道是怎么嵌套的，就选择了方式二。</li>
<li>本地配置好之后，要部署到Github Pages上。<a href="https://hexo.io/zh-cn/docs/github-pages"  target="_blank" rel="noopener" >Hexo所提供的教程</a>中，所使用的是<code>Github Action</code> 内置的 token 变量<code>GITHUB_TOKEN</code>。根据<a href="https://docs.github.com/en/actions/security-guidesautomatic-token-authentication?query=PA#using-the-github_token-in-a-workflow"  target="_blank" rel="noopener" >官方源文档的描述</a>,为了防止递归构建发生，使用<code>GITHUB_TOKEN</code>推送的代码不会再次触发任何action。而考虑到我希望后续能进一步触发和进一步了解<code>Github Action</code>,我选择自己设置key。</li>
<li>这个花的时间最多。走了不少弯路，最终是参考了<a href="https://vuepress-theme-reco.recoluan.com/views/other/github-actions.html"  target="_blank" rel="noopener" >使用 GitHub Actions 自动部署博客</a>。</li>
<li>action已经跑成功了，但访问时却发现还是404，检查后发现是自己未<a href="https://docs.github.com/en/pages/getting-started-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site"  target="_blank" rel="noopener" >Configuring a publishing source for your GitHub Pages site</a>。</li>
<li>添加谷歌验证：
参考了<a href="https://jactorsue.github.io/blog/2018/04/how-blog-on-githubpages-can-be-searched-by-google.html"  target="_blank" rel="noopener" >让Google搜索到搭建在Github Pages上的博客</a>
<ol>
<li>（前略）验证网站所有权时，选择使用HTML标记方式来验证。fluid主题的head路径为<code>\themes\fluid\layout\_partials\head.ejs</code></li>
</ol>
</li>
<li>减少加载时间，尚未实操，先记录几篇看到的好文
<ul>
<li><a href="https://www.voidking.com/dev-hexo-accelerate/"  target="_blank" rel="noopener" >Hexo加速访问</a></li>
<li><a href="https://www.voidking.com/dev-hexo-gulp/"  target="_blank" rel="noopener" >Hexo使用Gulp压缩静态资源</a></li>
</ul>
</li>
<li>插入图片，这篇写得挺完整的：
<a href="https://fuhailin.github.io/Hexo-images/"  target="_blank" rel="noopener" >在Hexo博客中插入图片的各种方式</a></li>
<li>添加最后修改时间:
T将主题配置文件<code>_config.yml</code>中的<code>post:copyright:update_date:enable:</code>设置为<code>enable</code>即可+08:00</li>
</ol>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ hexo new <span class="s2">&#34;My New Post&#34;</span>
</span></span></code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html"  target="_blank" rel="noopener" >Writing</a></p>
<h3 id="run-server">Run server</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ hexo server
</span></span></code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html"  target="_blank" rel="noopener" >Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ hexo generate
</span></span></code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html"  target="_blank" rel="noopener" >Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ hexo deploy
</span></span></code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html"  target="_blank" rel="noopener" >Deployment</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>network</title>
      <link>https://euds63.github.io/2023/network/</link>
      <pubDate>Sat, 11 Mar 2023 19:32:04 +0800</pubDate>
      
      <guid>https://euds63.github.io/2023/network/</guid>
      <description>网络配置学习</description>
      <content:encoded><![CDATA[<h1 id="网络">网络</h1>
<h2 id="过程">过程</h2>
<ul>
<li>先是看<a href="https://www.jianshu.com/p/53457e21fcd4"  target="_blank" rel="noopener" >如何让国内的阿里云服务器可以高速下载Github代码</a>，但这个是纯命令行的，用的是pm2</li>
<li>因为延迟比较大，想切换节点，首先是研究怎么用命令行实现.确实可以，<a href="https://sakronos.github.io/Note/2021/03/06/%E4%BD%BF%E7%94%A8Clash-APIj%E5%88%87%E6%8D%A2%E8%8A%82%E7%82%B9/"  target="_blank" rel="noopener" >使用Clash-API切换节点</a>有介绍，但我去操作的话不行，返回<code>{&quot;message&quot;:&quot;Body invalid&quot;}  </code>。看也有人提issue，但我还是不能成功更改。加上这样更改的话，就挺麻烦的。于是想着能不能搞个ui。</li>
<li>然后参考<a href="https://blog.zzsqwq.cn/posts/how-to-use-clash-on-linux/"  target="_blank" rel="noopener" >如何在Linux上优雅的使用Clash</a>这篇，docker让这些配置变得简单多了。但我还是遇到了些问题：主要是自作聪明，修改了</li>
</ul>
<pre tabindex="0"><code> - ./config.yaml:/root/.config/clash/config.yaml
 - ./Country.mmdb:/root/.config/clash/Country.mmdb
</code></pre><p>调试后才发现并不用修改。另一个是配置<code>external-controller: :9090</code>时，自己改成了<code>127.0.0.1:9090</code></p>
<ul>
<li>上面那篇文章少了暴露接口这一步，<a href="https://juejin.cn/post/7054941050216906760"  target="_blank" rel="noopener" >如何为实验室服务器配置终端代理</a>，<a href="https://zhuanlan.zhihu.com/p/46973701"  target="_blank" rel="noopener" >Linux 让终端走代理的几种方法</a>,这两篇讲得挺好的</li>
</ul>
<h2 id="收获">收获</h2>
<ul>
<li>了解了配置文件怎么写的</li>
<li>学到了如何检查是处于代理状态：<code>curl cip.cc</code>，但得到的地址和我实际走的节点不一样</li>
</ul>
<h2 id="参考链接">参考链接</h2>
<ul>
<li><a href="https://sakronos.github.io/Note/2021/03/06/%E4%BD%BF%E7%94%A8Clash-APIj%E5%88%87%E6%8D%A2%E8%8A%82%E7%82%B9/"  target="_blank" rel="noopener" >使用Clash-API切换节点</a></li>
<li><a href="https://github.com/Dreamacro/clash/issues/659"  target="_blank" rel="noopener" >通过RESTful API更改节点代理返回{&ldquo;message&rdquo;:&ldquo;Body invalid&rdquo;}</a></li>
<li><a href="https://www.jianshu.com/p/53457e21fcd4"  target="_blank" rel="noopener" >如何让国内的阿里云服务器可以高速下载Github代码</a></li>
<li><a href="https://blog.zzsqwq.cn/posts/how-to-use-clash-on-linux/"  target="_blank" rel="noopener" >如何在Linux上优雅的使用Clash</a></li>
<li><a href="https://juejin.cn/post/7054941050216906760"  target="_blank" rel="noopener" >如何为实验室服务器配置终端代理</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/46973701"  target="_blank" rel="noopener" >Linux 让终端走代理的几种方法</a></li>
<li><a href="https://github.com/Dreamacro/clash/wiki/configuration"  target="_blank" rel="noopener" >Configuration</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>RSS折腾记</title>
      <link>https://euds63.github.io/2023/rss%E6%8A%98%E8%85%BE%E8%AE%B0/</link>
      <pubDate>Wed, 08 Mar 2023 15:59:18 +0800</pubDate>
      
      <guid>https://euds63.github.io/2023/rss%E6%8A%98%E8%85%BE%E8%AE%B0/</guid>
      <description>记录ttrss的搭建过程和rss相关的内容</description>
      <content:encoded><![CDATA[<h1 id="rss折腾记">RSS折腾记</h1>
<p>3月7日，下午没有课，很闲。玩了会吸血鬼幸存者觉得索然无味，就想着试下之前没有成功的服务器。</p>
<p>先是试了下AZURE，但学生验证没过，放弃了。然后尝试阿里云。他有一个飞天加速3.0-高校计划，可以领取七个月的ECS。还是蛮顺利的。</p>
<p>领取后第一个想法是搭自己的RSS服务。基本上是照着<a href="https://sspai.com/post/57498#!"  target="_blank" rel="noopener" >找不到满意的 RSS 服务？你可以自己搭建一个</a>，来完成的。但中间还是有些曲折，踩了一些坑。</p>
<ul>
<li>
<p>首先是网络问题。文中给的地址都是Github上的，但下载速度实在不行。16M的文件要下载半个多小时。这个有两种解决方式是。首先尝试的是用镜像站，但因为尝试的镜像站有问题，再加上我后续还想在服务器上搭telegram机器人。于是选择用代理。参考了<a href="https://www.jianshu.com/p/53457e21fcd4"  target="_blank" rel="noopener" >如何让国内的阿里云服务器可以高速下载Github代码</a>,和所用机场的教程。但关于如何更换节点，还不清楚。现在会了，记录在<a href="https://euds63.github.io/2023/03/11/network/"  target="_blank" rel="noopener" >网络</a></p>
</li>
<li>
<p>其次是文中给的ttrss 的 docker-compose 配置文件有问题，自己修改后下的东西也不对。然后就想到直接复制过来。但对vim的操作实在是不熟悉，加上yml对间隔格式要求很严，在这上面折腾了好一会儿。
(发现是自己愚蠢，GitHub提供了相应的下载方式：点raw，跳转到的就是所需的网址了。比如我这步所需的代码就是<code>curl -fLo a.yml https://raw.githubusercontent.com/HenryQW/Awesome-TTRSS/main/docker-compose.yml</code>)</p>
</li>
<li>
<p>容器启动后，按照描述，我访问<code>{服务器 IP}:181</code>，应该可以直接看到 Tiny Tiny RSS 的 Web 前端。但却报502。后来想到，默认的181端口是不开放的，在安全组中添加了就可以了。</p>
</li>
<li>
<p>阅读器的选择也花了我很多时间，先是试已经使用过一段时间的<code>Fluent Reader</code>,但按照文档里所给的地址不成功，然后是选用<code>TTRSS-Reader</code>,这个就很顺利，但界面比较复古，加上功能不够多，也可能是我还没有发掘出来，就转而使用<code>FeedMe</code>,首先用的是TTRSS的api，但出现的问题是订阅地址能过来，但内容拉取不到，看issue才发现这是好几个月前就出现的bug，还没被修复，解决方法是转用fever api。但这个也是坑。首先是网页给的地址是<code>http:/[您的地址]/plugins.local/fever/</code>,而文档给的地址是<code>https://[您的地址]/plugins/fever</code>。但可能是不同阅读器设置的过滤方法不一样，<code>FeedMe</code>能用的地址是<code>http://[您的地址]/</code>,而<code>Fluent Reader</code>则是<code>http://[您的地址]//plugins/fever/</code>。</p>
</li>
</ul>
<p>以上就是整个搭建过程中所遇到的问题，目前发现<code>FeedMe</code>的功能明显得多，还有RSSHub也想用起来，订阅源想扩大到除了个人博客之外的其他。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>git学习笔记</title>
      <link>https://euds63.github.io/2022/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 04 Sep 2022 12:31:47 +0800</pubDate>
      
      <guid>https://euds63.github.io/2022/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>记录git学习</description>
      <content:encoded><![CDATA[<h1 id="git学习笔记">git学习笔记</h1>
<h2 id="使用技巧">使用技巧</h2>
<h3 id="github项目内搜索">Github项目内搜索</h3>
<p>在仓库页面上按 T ，然后直接输入文件名</p>
<hr>
<h2 id="记录">记录</h2>
<h3 id="gitee配置的记录">Gitee配置的记录</h3>
<p>因为srtp项目是用gitee作托管，所以今天试着配置了下Gitee，还是花了些时间的，记录如下：</p>
<ol>
<li>主要参考的是<a href="https://cloud.tencent.com/developer/article/1774890"  target="_blank" rel="noopener" >Git同时配置Gitee和GitHub</a>,但它上面第一步就是让清除git的全局设置，有点不敢，因为怕清除后自己之前设置的一些东西出错。</li>
<li>又看了几个教程，发现<a href="https://blog.csdn.net/weixin_43894513/article/details/104550377"  target="_blank" rel="noopener" >Github 与 Gitee 共存配置</a>上并没有说要清楚全局设置，于是就跟着上面的一步步走，很顺利地就设置好了。</li>
<li>一个收获是<code>config</code>,<code>id_rsa</code>都是可以用记事本打开并编辑的。</li>
</ol>
<h3 id="多人协作时的流程">多人协作时的流程</h3>
<p>这次小组项目用的是华为云，所以流程也都是基于华为云来说的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 注：代码中的中文请根据实际情况进行替换</span>
</span></span><span class="line"><span class="cl"><span class="c1">#确定好本次代码开发所要完成的任务，开好远程分支x，相关信息(分支名称，描述，关联工作项）要注明好</span>
</span></span><span class="line"><span class="cl">git pull <span class="c1">#确保代码、分支是最新的</span>
</span></span><span class="line"><span class="cl">git checkout -b 本地分支名 origin/远程分支名   <span class="c1">#检出远程分支到本地</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 代码开发</span>
</span></span><span class="line"><span class="cl">git add .
</span></span><span class="line"><span class="cl">git commit -m<span class="s2">&#34;适当的批注&#34;</span>
</span></span><span class="line"><span class="cl">git push <span class="c1">#将代码推送到远程分支，开发过程中这个操作可以频繁点，好处是：代码备份和版本管理</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 完成本次代码开发所要完成的任务后（请确定功能实现，本地调试没问题）</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 接下来进行分支的合并 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># 在华为云中新建合并请求（可设置检视人，评审人，让别人帮忙看看）</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 合并完成后（默认设置是分支合并后，源分支是删除的）</span>
</span></span><span class="line"><span class="cl">git remote prune origin <span class="c1">#当华为云上显示远程分支已经删除，但git branch -r仍然看到所删除的分支，执行该命令</span>
</span></span><span class="line"><span class="cl">git checkout master <span class="c1">#切回master分支（一次任务完成后，建议切回master分支，这样pull的时候可以避免自己写的代码丢失的问题）</span>
</span></span><span class="line"><span class="cl">git branch -d 本地分支名 <span class="c1">#删除本次任务所用的本地分支（也可以不删，当作备份）</span>
</span></span></code></pre></div><h3 id="对remote-branch的认识">对remote branch的认识</h3>
<p>There are potentially three versions of every remote branch:</p>
<ol>
<li>The actual branch on the remote repository</li>
<li>The snapshot of that branch locally</li>
<li>A local branch that might be tracking the remote branch</li>
</ol>
<hr>
<h2 id="常用命令">常用命令</h2>
<h3 id="add">add</h3>
<ul>
<li><code>git add .</code> 会根据。gitignore做过滤</li>
<li><code>git add *</code> 会忽略。gitignore把任何文件都加入</li>
</ul>
<h3 id="推送">推送</h3>
<p>文件推送的三个步骤：</p>
<pre tabindex="0"><code>git add 
git commit -m&#34;输入想说的话&#34;
git push
</code></pre><h3 id="查看状况">查看状况</h3>
<p><code>git status</code></p>
<h3 id="分支">分支</h3>
<ul>
<li>
<p>转到另一个分支 `git checkout {分支名}</p>
</li>
<li>
<p>查看本地分支 <code>git branch</code></p>
</li>
<li>
<p>查看远程分支 <code>git branch -r</code></p>
</li>
<li>
<p>查看本地和远程分支 <code>git branch -a</code></p>
</li>
<li>
<p>删除本地分支 <code>git branch -d {本地分支名}</code></p>
</li>
<li>
<p>强制删除本地分支<code>git branch -D {本地分支名}</code></p>
</li>
<li>
<p>删除远程分支 <code>git push origin --delete {远程分支名}</code></p>
</li>
<li>
<p>已经删除的远程分支但仍<code>git branch -a</code>时仍显示 ：<code>git remote prune origin</code></p>
</li>
</ul>
<h3 id="日志">日志</h3>
<ul>
<li><code>git log</code> 查看分支提交历史</li>
<li><code>git reflog</code> 也是查看日志，主要区别是会显示<code>reset --hard</code></li>
</ul>
<h3 id="代码回退">代码回退</h3>
<ul>
<li><code>git reset --hard {commit_id}</code></li>
<li><code>git reset --hard HEAD^ </code> 回退到上一版本</li>
</ul>
<hr>
<h2 id="submodule">submodule</h2>
<ol>
<li>删除特定的Git子模块</li>
</ol>
<pre tabindex="0"><code class="language-git" data-lang="git"># 以取消themes/PaperMod为例
# 取消子模块的初始化
git submodule deinit -f -- themes/PaperMod
# 从项目中删除子模块的目录
git rm -f themes/PaperMod
# git rm -f themes/PaperMod
rm -rf .git/modules/themes/PaperMod
</code></pre><hr>
<h2 id="报错与解决">报错与解决</h2>
<ol>
<li>
<p>报错：</p>
<blockquote>
<p>Updates were rejected because the remote contains work that you donot have locally.</p>
</blockquote>
<ul>
<li><strong>场景</strong>:在尝试gitee的时候，先是建了个远程仓库。然后在本地新建了个同名的文件夹，然后
<pre tabindex="0"><code>git init 
git remote add origin https://gitee.com/spike23187/hello-gitee.git
</code></pre></li>
</ul>
<p>在文件夹里新建了个文件，<code>push</code>的时候报的错</p>
<ul>
<li><strong>解决</strong>: 根据下方的提示，是我没有先<code>pull</code>，本地文件不是最新的。</li>
</ul>
</li>
<li>
<blockquote>
<p>Updates were rejected because the tip of your current branch is behind its remote counterpart</p>
</blockquote>
<ul>
<li><strong>场景</strong>：上述那个场景中，<code>git pull origin master</code>后报的错</li>
<li><strong>解决</strong>：<code>git pull origin master --rebase</code></li>
<li><strong>参考链接</strong>：<a href="https://blog.csdn.net/weixin_42310154/article/details/118676936"  target="_blank" rel="noopener" >Git常见报错：Updates were rejected because the tip of your current branch is behind</a></li>
<li><strong>收获</strong>：虽然使用GitHub托管代码有段时间了，但一直是用插件简化操作的。这次算是第一次用git bash，就报了两个错，感觉git要用好，还是有段路要走的。</li>
</ul>
</li>
<li></li>
</ol>
<ul>
<li><strong>场景</strong>:push时报错,大意是网络问题</li>
<li><strong>解决</strong>：
<pre tabindex="0"><code>git config --global http.proxy &#39;http://127.0.0.1:7890&#39;
git config --global https.proxy &#39;http://127.0.0.1:7890&#39;
</code></pre></li>
</ul>
<hr>
<h1 id="可供参考的链接">可供参考的链接</h1>
<ul>
<li><a href="https://www.yiibai.com/git"  target="_blank" rel="noopener" >git教程</a></li>
<li><a href="https://www.theserverside.com/video/Git-reflog-vs-log-How-these-commit-history-tools-differ"  target="_blank" rel="noopener" >Git reflog vs. log: How these commit history tools differ</a></li>
<li><a href="http://blog.ch3nyang.top/miscellaneous/git%E5%AD%A6%E4%B9%A0/"  target="_blank" rel="noopener" >【杂】git学习</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/137856034"  target="_blank" rel="noopener" >拜托，不要再问我Git如何回滚代码</a></li>
</ul>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
