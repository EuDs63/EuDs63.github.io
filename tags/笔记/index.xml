<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>笔记 on EuDs&#39;s Blog</title>
    <link>https://euds63.github.io/tags/%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 笔记 on EuDs&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 27 Jun 2023 18:37:47 +0800</lastBuildDate><atom:link href="https://euds63.github.io/tags/%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>《操作系统：设计与实现》笔记</title>
      <link>https://euds63.github.io/2023/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 27 Jun 2023 18:37:47 +0800</pubDate>
      
      <guid>https://euds63.github.io/2023/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/</guid>
      <description>操作系统就是状态机</description>
      <content:encoded><![CDATA[<p><strong><a href="https://space.bilibili.com/202224425/channel/collectiondetail?sid=192498"  target="_blank" rel="noopener" >操作系统：设计与实现 (2022 春季学期)</a>的学习笔记</strong></p>
<h3 id="p3-多处理器编程从入门到放弃-线程库现代处理器和宽松内存模型">p3 多处理器编程：从入门到放弃 (线程库；现代处理器和宽松内存模型)</h3>
<ul>
<li>
<p>并发程序的三个麻烦</p>
<ul>
<li>原子性</li>
<li>顺序</li>
<li>可见性</li>
</ul>
</li>
<li>
<p>gcc 编译</p>
<ul>
<li>不优化,并查看汇编代码
<code>gcc -c -O1 sum.c &amp;&amp; objdump -d sum.o</code></li>
<li><code>asm volatile(&quot;&quot; : : &quot;memory&quot;); // compiler barrier</code></li>
</ul>
</li>
<li>
<p>统计次数
<code> ./a.out | head -n 1000 | sort | uniq -c</code></p>
</li>
<li>
<p>现代处理器</p>
<ul>
<li>也是动态编译器：汇编指令也是由多个uop所组成的。</li>
<li>维护一个uop的“池子” 指令的有向无环图</li>
<li>乱序执行，顺序提交</li>
</ul>
</li>
</ul>
<h3 id="p4-理解并发程序执行-peterson算法模型检验与软件自动化工具">p4 理解并发程序执行 (Peterson算法、模型检验与软件自动化工具)</h3>
<ul>
<li>C语言的形式语义
<ul>
<li>全局变量加多个栈帧；每个栈帧有其局部变量和pc</li>
</ul>
</li>
<li>Peterson算法
<ul>
<li>看上去是谦让的，但其实是自私的</li>
<li>证明正确性：画出状态机
<ul>
<li>困境：不敢不画，不敢乱画</li>
<li>解决： <a href="https://jyywiki.cn/pages/OS/2022/demos/model-checker.py"  target="_blank" rel="noopener" >model-checker</a></li>
<li>把程序的问题变成图论的问题
<ul>
<li>safety 红色状态不可达</li>
<li>liveness : 从任意状态出发，都能到达绿/蓝色状态 强连通分量</li>
</ul>
</li>
</ul>
</li>
<li>许多重要的想法，凝练以后就是概念</li>
</ul>
</li>
<li>并发程序 = 状态机</li>
<li>Python generator
<ul>
<li>e.g.
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">numbers</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">n</span> <span class="o">=</span> <span class="n">init</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">Trye</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">n</span> <span class="o">+=</span> <span class="n">step</span>
</span></span><span class="line"><span class="cl">    <span class="k">yield</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl"><span class="n">g</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">g</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span>
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
<h3 id="p5-并发控制互斥-自旋锁互斥锁和-futex">p5 并发控制：互斥 (自旋锁、互斥锁和 futex)</h3>
<ul>
<li>不能解决问题的时候，可以找到所依赖的假设，并大胆地打破它</li>
<li>spin 线程直接共享 locked</li>
<li>mutex 通过系统调用访问 locked</li>
<li>futex(Fast Userspace muTexes)
<ul>
<li>Fast path: 一条原子指令，上锁成功立即返回</li>
<li>Slow path: 上锁失败，执行系统调用睡眠</li>
</ul>
</li>
</ul>
<h2 id="p6-并发控制同步-条件变量信号量生产者-消费者和哲学家吃饭问题">p6 并发控制：同步 (条件变量、信号量、生产者-消费者和哲♂学家吃饭问题)</h2>
<ul>
<li>思考： 有一堆任务，平均切分成n堆。有x个线程负责完成该任务(x &lt; n) 一个线程一次只能完成一个任务，完成后会自动去做下一个任务。要怎么实现？</li>
<li>有万能的方法，就要用万能的方法。
<ul>
<li>他是这样诠释的。当项目代码量不大（一千行以内），项目还是比较好维护的，这时候用写聪明的写法没问题。但当项目到了几万行甚至几百万行时，这时候就需要多个人来进行协作。而人和人之间最大的障碍就是无法完全沟通，理解对方的心意。</li>
<li>不要试图用聪明的办法解决并发问题</li>
<li>个人想法：第一次听这种说法，有一定道理。</li>
</ul>
</li>
<li>万能同步方法 —— 条件变量(Conditional Variables )
<ul>
<li>API
<ul>
<li>wait(cv, mutex) 💤
调用时必须保证已经获得 mutex
释放 mutex、进入睡眠状态</li>
<li>signal/notify(cv) 💬 私信：走起
如果有线程正在等待 cv，则唤醒其中一个线程</li>
<li>broadcast/notifyAll(cv) 📣 所有人：走起
唤醒全部正在等待 cv 的线程</li>
</ul>
</li>
<li>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 需要等待条件满足时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">cond</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">assert</span><span class="p">(</span><span class="n">cond</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1">// 互斥锁保证了在此期间条件 cond 总是成立
</span></span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 其他线程条件可能被满足时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">);</span>
</span></span></code></pre></div></li>
<li>debug -&gt; 隔离出bug触发的最小条件</li>
</ul>
</li>
</ul>
<h2 id="p7-真实世界的并发编程-高性能计算数据中心人机交互中的并发编程">p7 真实世界的并发编程 (高性能计算/数据中心/人机交互中的并发编程)</h2>
<ul>
<li>谈block chain &gt; 是个很好的技术。但觉得不太对。因为造成了相当大的资源浪费。</li>
<li><a href="https://www.youtube.com/watch?v=FFftmWSzgmk&amp;ab_channel=Numberphile"  target="_blank" rel="noopener" >What&rsquo;s so special about the Mandelbrot Set? - Numberphile</a></li>
<li><a href="https://github.com/atanunq/viu"  target="_blank" rel="noopener" >atanunq/viu</a></li>
<li>搜索降低了知识的获取成本，ChatGPT等再一次降低了成本。</li>
<li>go语言，编程友好、性能优化</li>
<li>博客是web2.0 的第一步</li>
<li>Ajax (Asynchronous JavaScript + XML)</li>
<li>这次课中讲了三种并发编程，根据不同的需要，实现并发的方式也不同。</li>
</ul>
<h2 id="p8-并发-bug-和应对-死锁数据竞争原子性违反防御性编程和动态分析">p8 并发 bug 和应对 (死锁/数据竞争/原子性违反；防御性编程和动态分析)</h2>
<ul>
<li>软件是需求在计算机数字世界的投影。</li>
<li>assert的使用</li>
<li>没有工具不做系统</li>
<li>premature optimization is root of all evil</li>
<li>编程语言的缺陷——对程序员的完全信任：因为计算资源的宝贵</li>
<li>动态分析工具 <code>-fsanitize</code></li>
<li>Canary msvc 中 debug mode 的canary  <code>(b'\xcc' * 80).decode('gb2312')</code></li>
</ul>
<h2 id="p9-操作系统的状态机模型-操作系统的加载-thread-os-代码讲解">p9 操作系统的状态机模型 (操作系统的加载; thread-os 代码讲解)</h2>
<ul>
<li>大学的真正意义:f将已有的知识和方法重新消化，为大家建立好 “台阶”，在有限的时间里迅速赶上数十年来建立起的学科体系。</li>
</ul>
<h2 id="p10-状态机模型的应用-细胞自动机-gdbrrperf-代码验证工具">p10 状态机模型的应用 (细胞自动机; gdb/rr/perf; 代码验证工具)</h2>
<ul>
<li>分布式系统也是一种并发程序，但要更复杂。因为并发程序假设了每个thread都能正常运行，而分布式系统则要考虑节点丢失的情况。</li>
</ul>
<h2 id="p11-操作系统上的进程-最小-linux-fork-execve-和-exit">p11 操作系统上的进程 (最小 Linux; fork, execve 和 exit)</h2>
<ul>
<li>Linux 操作系统启动流程
CPU Reset → Firmware → Loader → Kernel _start() → 第一个程序 /bin/init → 程序 (状态机) 执行 + 系统调用</li>
<li>Fork Bomb:
<code>:(){:|:&amp;};:</code>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">:<span class="o">()</span> <span class="o">{</span>         <span class="c1"># 格式化一下</span>
</span></span><span class="line"><span class="cl">: <span class="p">|</span> : <span class="p">&amp;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span><span class="p">;</span> :
</span></span></code></pre></div></li>
<li>stdout:
终端: line buffer
pipe , file :full buffer (除非显示地调用fflush)
<pre tabindex="0"><code></code></pre></li>
<li><strong>fork</strong>
<ul>
<li>程序就是状态机，正在执行的程序也是状态机，fork创建状态机的副本；</li>
<li>创建的进程返回+1，子进程返回为0</li>
<li>把所有的寄存器和内存都复制</li>
</ul>
</li>
<li><strong>execve</strong>
<ul>
<li>将当前运行的状态机重置成成另一个程序的初始状态</li>
</ul>
</li>
<li><strong>_exit</strong></li>
</ul>
<h2 id="p12-进程的地址空间-pmap-vdso-mmap-游戏修改器外挂">p12 进程的地址空间 (pmap; vdso; mmap; 游戏修改器/外挂)</h2>
<ul>
<li>端序
<ul>
<li>大端 (big endian): 低地址存放<em>高</em>有效字节</li>
<li>小端 (little endian): 低字节存放<em>低</em>有效字节</li>
</ul>
</li>
<li>工具使用
<ul>
<li>gdb</li>
<li>readelf</li>
<li>pmap</li>
</ul>
</li>
<li>计算机世界没有魔法。因为程序就是状态机。</li>
<li>vdso:不进入操作系统内核，实现系统调用</li>
<li>mmap：</li>
<li>文件=字节序列；内存=字节序列； everything is a file</li>
</ul>
<h2 id="p13-系统调用和-shell-freestanding-shell-终端和-job-control">p13 系统调用和 Shell (freestanding shell, 终端和 job control)</h2>
<ul>
<li>cd是内部命令：改变当前目录是用系统调用实现的</li>
<li><code>strace -f gcc a.c 2&gt;&amp;1 | vim -</code> This will pipe both stdout and stderr to vim. The <code>-</code> argument tells vim to read from stdin.</li>
<li><code>strace pmap 152 |&amp; vim - </code>
<code>|&amp;</code> : This is a shorthand for <code>2&gt;&amp;1 |</code> in bash and zsh. It passes both standard output and standard error of one command as input to another.</li>
<li>fish, zsh 和 bash 都是常用的命令行 shell; sh是比较原始的</li>
<li>clear 清屏</li>
<li><code>,./a.out &amp;</code>  后台执行./a.out</li>
</ul>
<h2 id="p14-c-标准库的实现-系统调用的封装内存空间管理">p14 C 标准库的实现 (系统调用的封装；内存空间管理)</h2>
<ul>
<li>文件描述符还是不理解。印象中这是第二次谈到了&quot;everything is a file&quot;
<ul>
<li>os的对象和对象的访问</li>
</ul>
</li>
<li>gdn的使用
<ul>
<li><code>No symbol table is loaded.  Use the &quot;file&quot; command</code>。可能是编译选项未包含debug信息,如gcc没有添加-g选项。</li>
</ul>
</li>
<li>premature optimization is the root of all evil.</li>
<li>脱离workload谈优化就是耍流氓</li>
<li>经典的设计：
<ul>
<li>fast path</li>
<li>slow path</li>
</ul>
</li>
</ul>
<h2 id="p15-fork-的应用-文件描述符的复制写时复制创建平行宇宙的魔法">p15 fork 的应用 (文件描述符的复制；写时复制；创建平行宇宙的魔法)</h2>
<ul>
<li>fork 状态机复制包括持有的所有操作系统对象</li>
<li>包括持有的所有操作系统对象</li>
<li>文件描述符（file discriptor）
<ul>
<li>一个指向操作系统内对象的 “指针”</li>
<li>dup() 的两个文件描述符是共享 offset</li>
</ul>
</li>
<li>访问空指针也会造成缺页中断</li>
<li>“Copy-on-write” 只有被写入的页面才会复制一份
<ul>
<li>被复制后，整个地址空间都被标记为 “只读”</li>
<li>操作系统捕获 Page Fault 后酌情复制页面</li>
<li>fork-execve 效率得到提升</li>
</ul>
</li>
<li>操作系统会维护每个页面的引用计数</li>
<li>定义进程所占用的内存</li>
<li>page是归os所有的，而非进程</li>
<li>使用fork来搜索并行化。</li>
</ul>
<h2 id="p16-什么是可执行文件-调试信息stack-unwinding静态链接中的重定位">p16 什么是可执行文件 (调试信息；Stack Unwinding；静态链接中的重定位)</h2>
<ul>
<li>可执行文件描述了状态机，是一个描述了状态机的初始状态 + 迁移的数据结构</li>
<li>os没有魔法，所有东西都有解释</li>
<li><code>She-bang</code> <code>#! interpreter [optional-arg]</code></li>
<li>GNU binutils
<ul>
<li>生成可执行文件
<ul>
<li>ld (linker), as (assembler)</li>
<li>ar, ranlib</li>
</ul>
</li>
<li>分析可执行文件
<ul>
<li>objcopy/objdump/readelf</li>
<li>addr2line, size, nm</li>
</ul>
</li>
</ul>
</li>
<li><code>objdump -d a.out | less</code> disasm</li>
<li><code>addr2line 401122 a.out</code></li>
<li>elf: 小精灵；dwarf：矮人</li>
<li>将一个 assembly (机器) 状态映射到 “C 世界” 状态很难</li>
<li>gcc等仍存在着许多不完美</li>
<li>编译器，汇编器，链接器</li>
</ul>
<h2 id="p17-动态链接和加载-静态-elf-加载器实现调试-linux-内核动态链接和加载">p17 动态链接和加载 (静态 ELF 加载器实现；调试 Linux 内核；动态链接和加载)</h2>
<ul>
<li>自定义了一个二进制格式文件</li>
<li>GOT ： global offset table</li>
<li>PLT : procedure linkage table</li>
</ul>
<h2 id="p23-1-bit-数据的存储-延迟线磁芯dramsram磁带磁盘光盘flash-ssd">p23 1-Bit 数据的存储 (延迟线/磁芯/DRAM/SRAM/磁带/磁盘/光盘/Flash SSD)</h2>
<ul>
<li>volatile: 确保该变量的实际值与内存中的值一致,每次读取都是最新值,也禁止编译器对其进行优化。</li>
<li>core dumped 磁性内存年代开始的概念。</li>
<li>局部性原理 -&gt; 可以按照大块来读写</li>
</ul>
<h2 id="p24-输入输出设备模型-串口键盘磁盘打印机总线中断控制器dma-和-gpu">p24 输入输出设备模型 (串口/键盘/磁盘/打印机/总线/中断控制器/DMA 和 GPU</h2>
<ul>
<li>DMA: direct memory access : 一个专门执行&quot;memcpy&quot;程序的cpu</li>
<li>IPC: Instruction per second</li>
<li>GPU:
<ul>
<li>一个通用计算设备</li>
<li>大量并行相似的任务</li>
</ul>
</li>
<li>异构计算：都能做，但选那个最合适的。（jjy在22年说的现在已经能感觉到有相关的趋势了。不过倒不是里面举例的挖矿，而是llm模型）</li>
</ul>
<h2 id="p25-设备驱动程序-linux-设备驱动-gpu-和-cuda-存储设备抽象">p25 设备驱动程序 (Linux 设备驱动; GPU 和 CUDA; 存储设备抽象)</h2>
<ul>
<li>设备抽象成 支持各类操作的对象 (文件)
<ul>
<li>read - 从设备某个指定的位置读出数据</li>
<li>write - 向设备某个指定位置写入数据</li>
<li>ioctl - 读取/设置设备的状态</li>
</ul>
</li>
<li><code>stty -a</code></li>
<li>GPU
<ul>
<li>Single Instruction, Multiple Thread</li>
</ul>
</li>
<li>读优先的正确性</li>
</ul>
<h2 id="p26-文件系统-api-设备在应用间的共享目录和文件-api">p26 文件系统 API (设备在应用间的共享；目录和文件 API)</h2>
<ul>
<li>信息的局部性</li>
<li>Windows从c盘开始时是受其前身Dos系统的影响，那个有a、b</li>
<li><code>mount disk.img  /mnt</code></li>
<li><code>umount /mnt</code></li>
<li>硬（hard）链接
<ul>
<li><code>ln /usr/local/python3 python</code></li>
<li>目录中仅存储指向文件数据的指针</li>
<li>允许一个文件被多个目录引用.</li>
<li>无法用来链接目录，也不能跨文件系统</li>
<li>通过<code>ls -i</code>查看是否为硬链接</li>
</ul>
</li>
<li>软 (symbolic) 链接
<ul>
<li>“快捷方式”</li>
<li><code> ln -s ../p24 p24</code></li>
<li>目录从“树”变为了“图”，还是有环图</li>
</ul>
</li>
<li><code>cd</code>的特殊性
<ul>
<li>每个进程都有一个对应的工作目录（pwd），而这个目录只有系统调用才能够修改</li>
</ul>
</li>
</ul>
<h2 id="p27-fat-和-unix-文件系统-数据结构视角的文件系统-fat-手册导读和目录树遍历">p27 FAT 和 UNIX 文件系统 (数据结构视角的文件系统; FAT 手册导读和目录树遍历)</h2>
<ul>
<li>数据结构的假设：数据是以字节来存储的。</li>
<li>RAM 和 block的区别</li>
<li>FAT(File Allocation Table)
<ul>
<li>将指针集中存放在文件系统的某个区域</li>
<li>适合小文件</li>
<li>会产生碎片（fragmentation）</li>
<li>基本假设
<ul>
<li>链表无环且长度和文件大小一致</li>
<li>FREE的cluster不能有入边</li>
</ul>
</li>
</ul>
</li>
<li>cluster</li>
<li>sector</li>
<li>ext2
<ul>
<li>大文件的随机读写性能提升明显 (O(1))</li>
<li>支持链接 (一定程度减少空间浪费)</li>
<li>inode 在磁盘上连续存储，便于缓存/预取</li>
<li>碎片</li>
</ul>
</li>
</ul>
<h2 id="p28-持久数据的可靠性-raid-崩溃一致性-fsck-和日志">p28 持久数据的可靠性 (RAID; 崩溃一致性; FSCK 和日志)</h2>
<ul>
<li>虚拟化
<ul>
<li>cpu的虚拟化：通过分时等技术让多个进程并行，相当于虚拟出了多个cpu</li>
<li>内存的虚拟化：一份内存通过mmu，虚拟成每个进程的地址空间</li>
<li>RAID：反向的虚拟化：多个磁盘虚拟化一个磁盘</li>
</ul>
</li>
<li>RAID
<ul>
<li>RAID0 : 交错排列： 提升容量和带宽</li>
<li>RAID1 : 提升容错和读带宽</li>
<li>RAID4 : 额外的一块校验盘
<ul>
<li>致命缺陷：随机写的性能只能有校验盘性能的一半</li>
</ul>
</li>
<li>RAID5 : Rotating Parity</li>
</ul>
</li>
<li>RAID带来的联想：
多个磁盘虚拟化为一个又大又快又可靠的磁盘，多台电脑虚拟化为一个又大又快又可靠的电脑
那能不能多个神经网络虚拟化为一个更好的神经网络</li>
<li>崩溃一致性  (Crash Consistency)
<ul>
<li>场景：写入的时候突然断电了怎么办？</li>
<li>方法1：按照一定顺序来写，且 “all or nothing”
<ul>
<li>困难：磁盘不提供多块读写 “all or nothing” 的支持，甚至为了性能，没有顺序保证。</li>
</ul>
</li>
<li>方法2： File System Checking (FSCK)
<ul>
<li>根据磁盘上已有的信息，恢复出 “最可能” 的数据结构</li>
<li>困难：难；如果修复的时候再掉一次电？</li>
</ul>
</li>
<li>方法3： 日志</li>
<li>具体：
<ul>
<li>数据结构操作发生时，用 (2) append-only 记录日志</li>
<li>日志落盘后，用 (1) 更新数据结构</li>
<li>崩溃后，重放日志并清除 (称为 redo log；相应也可以 undo log)</li>
</ul>
</li>
<li>优化: journaling (jdb2)</li>
</ul>
</li>
</ul>
<h2 id="p30-现代存储系统-关系数据库和分布式存储系统">p30 现代存储系统 (关系数据库和分布式存储系统)</h2>
<ul>
<li>数据库
<ul>
<li>关键
<ul>
<li>索引</li>
<li>查询优化</li>
</ul>
</li>
<li>magic：你只管写sql语句，相应的搜索优化它来做</li>
<li>要求：acid
<ul>
<li>Atoming</li>
<li>Consistency</li>
<li>Isolation</li>
<li>Durability</li>
</ul>
</li>
</ul>
</li>
<li>图灵奖
<ul>
<li>这门课听下来，听到了好多知识点背后都是获得过图灵奖的研究，甚至开创了一整个产业。</li>
</ul>
</li>
<li>关系型数据库跟不上社交网络的需求</li>
<li>cap theorem
<ul>
<li>Consistency</li>
<li>Availability</li>
<li>Partition Tolerance</li>
</ul>
</li>
<li>分布式存储系统</li>
</ul>
<h2 id="感想">感想</h2>
<p>蒋炎炎这门课还是别人推荐的。第一次看到还不以为意，但出现的次数多了就觉得有必要去看看。发现是一大惊喜。</p>
<h2 id="收获">收获</h2>
<ol>
<li>原版书能看得下来了。大段的英文，之前看着有点怕，现在觉得也能看下来，并且速度还可以。</li>
</ol>
<h2 id="课外资料">课外资料</h2>
<ul>
<li><a href="https://plantegg.github.io/2022/06/05/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E5%BC%80%E9%94%80/"  target="_blank" rel="noopener" >上下文切换的代价</a></li>
<li><a href="https://plantegg.github.io/2021/06/01/CPU%E7%9A%84%E5%88%B6%E9%80%A0%E5%92%8C%E6%A6%82%E5%BF%B5/"  target="_blank" rel="noopener" >CPU的制造和概念</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>操作系统复习笔记</title>
      <link>https://euds63.github.io/2023/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 19 Jun 2023 18:35:11 +0800</pubDate>
      
      <guid>https://euds63.github.io/2023/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>操作系统复习笔记</description>
      <content:encoded><![CDATA[<h1 id="期末复习">期末复习</h1>
<h2 id="chpter-3-process">Chpter 3 Process</h2>
<ul>
<li>操作系统进行任务调度和资源分配的基本单位</li>
<li>Process include:
<ol>
<li>Program code</li>
</ol>
<ul>
<li>text section</li>
</ul>
<ol start="2">
<li>program counter and processors’ registers</li>
<li>Stack</li>
</ol>
<ul>
<li>Function parameters</li>
<li>Return address</li>
<li>Local variables</li>
</ul>
<ol start="4">
<li>data section</li>
</ol>
<ul>
<li>Global variables</li>
</ul>
<ol start="5">
<li>Heap</li>
</ol>
<ul>
<li>Dynamically allocated memory</li>
</ul>
</li>
<li>Process State
<ul>
<li>五态模型
<ul>
<li>new</li>
<li>ready:waiting to be assigned to a processor</li>
<li>waiting: waiting for some event to occur</li>
<li>running</li>
<li>terminated</li>
</ul>
</li>
</ul>
</li>
<li>Process control block（PCB）
<ul>
<li>包含信息有：
<ul>
<li>Process number</li>
<li>Process state</li>
<li>Program counter
<ul>
<li>下条指令的地址</li>
</ul>
</li>
<li>CPU registers</li>
<li>CPU scheduling information</li>
<li>Memory-management information</li>
<li>Accounting information</li>
<li>I/O status information</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="process-scheduling">Process Scheduling</h3>
<ul>
<li>
<p>Scheduling queues</p>
<ol>
<li>Job queue</li>
</ol>
<ul>
<li>set of all processes in the system</li>
<li>As processes/job enter the system，they are put into the job queue</li>
</ul>
<ol start="2">
<li>Ready queue</li>
</ol>
<ul>
<li>set of all processes residing in “(main) memory”, ready and “waiting” to execute</li>
</ul>
<ol start="3">
<li>Device queues</li>
</ol>
<ul>
<li>set of processes waiting for an I/O device</li>
</ul>
</li>
<li>
<p>Scheduler(调度器)</p>
<ol>
<li>Long-term scheduler or job scheduler</li>
</ol>
<ul>
<li>job queue -&gt; ready queue</li>
<li>may  be absent on Time-sharing system such as UNIX  and Windows
<ul>
<li>They put every new process in memory for the short-term scheduler</li>
</ul>
</li>
</ul>
<ol start="2">
<li>Short-term scheduler Or CPU scheduler: 进程调度</li>
</ol>
<ul>
<li>selects which process should be executed next and allocates CPU</li>
<li>因为其执行十分频繁，所以每次选择不能耗时太长，否则就overhead</li>
</ul>
<ol start="3">
<li>Medium-term scheduler Or swapping</li>
</ol>
<ul>
<li>swap out: removes processes from memory to disk and reduces the degree of multiprogramming</li>
<li>swap in: introduce process into memory</li>
</ul>
</li>
<li>
<p>Context Switch</p>
<ul>
<li>CPU switches to another process</li>
</ul>
</li>
</ul>
<h3 id="operations-on-processes">Operations on Processes</h3>
<ol>
<li>fork()
<ul>
<li>The new process consists of a copy of the address space of the original process</li>
<li>The return code for the fork() is zero for the child process</li>
<li>子进程会复制父进程的地址空间和资源，但并不会复制父进程的线程</li>
</ul>
</li>
</ol>
<h3 id="interprocess-communication">Interprocess Communication</h3>
<ul>
<li>Shared memory</li>
<li>Message passing</li>
</ul>
<h3 id="名词解释">名词解释：</h3>
<ul>
<li>multiprogramming： is to have some process running at all times, to maximize CPU utilization</li>
<li>time sharing ： is to switch the CPU among processes so frequently that users can interact with each process</li>
</ul>
<h2 id="chapter-4-thread">Chapter 4 Thread</h2>
<ul>
<li>进程 vs 线程
<ul>
<li>线程是CPU的分布单位</li>
<li>进程是资源的分布单位</li>
<li>线程是进程中的执行单元
<ul>
<li>一个进程可以包含多个线程，它们共享相同的地址空间和系统资源，如open files, signals。</li>
<li>每个线程有自己的栈空间和执行上下文，但它们在同一个进程内共享代码段、数据段和堆等资源。</li>
</ul>
</li>
</ul>
</li>
<li>benefits of multithreaded programming
<ol>
<li>Responsiveness</li>
<li>Resource sharing</li>
<li>Economy</li>
<li>utilization of multiprocessor architectures</li>
</ol>
</li>
</ul>
<h3 id="multithreading-models">Multithreading Models</h3>
<ul>
<li>
<p>两种线程</p>
<ul>
<li>User Threads
<ul>
<li>Provided by a thread library at the user level</li>
</ul>
</li>
<li>Kernel Threads
<ul>
<li>Provided and managed by the OS directly</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Relationship between kernel threads and user threads</p>
<ol>
<li>Many-to-one model</li>
<li>One-to-one model-</li>
<li>Many-to-many model</li>
<li>Two-level Model
<ul>
<li>主体是Many-to-many model</li>
<li>A user thread (important task) can be bound to a kernel thread</li>
</ul>
</li>
</ol>
</li>
<li>
<p>Two versions of fork() in UNIX systems</p>
<ol>
<li>To duplicate all the threads
<ul>
<li>If exec() is not called after forking, then to duplicate all threads</li>
</ul>
</li>
<li>To only duplicate the thread that invoked the fork() system call
<ul>
<li>If exec() is called immediately after forking, then only to duplicate the calling threads</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="chapter-5-cpu-scheduling">Chapter 5 CPU Scheduling</h2>
<h3 id="basic-concepts">Basic Concepts</h3>
<ul>
<li>CPU scheduling decisions may take place when a process:
<ol>
<li>Switches from running to waiting state
<ul>
<li>The result of  an I/O request</li>
<li>An invocation of wait for the termination of one of the child processes （e.g. wait(NULL);）</li>
</ul>
</li>
<li>Switches from running to ready state
<ul>
<li>When a interrupt occurs</li>
</ul>
</li>
<li>Switches from waiting to ready
<ul>
<li>Completion of I/O</li>
</ul>
</li>
<li>Terminates</li>
</ol>
</li>
<li>Non-preemptive (非剥夺)
<ul>
<li>Once the CPU has been allocated to a process, the process keeps the CPU until it releases the CPU</li>
<li>调度只可能发生在情况 1. 和 4.</li>
<li>简单，硬件要求低</li>
</ul>
</li>
<li>Preemptive(剥夺)</li>
</ul>
<h3 id="scheduling-criteria">Scheduling Criteria</h3>
<ol>
<li>CPU utilization</li>
<li>CPU throughout
<ul>
<li>number of processes that complete their execution per time unit.</li>
</ul>
</li>
<li>Process turnaround time
<ul>
<li>From the time of submission of a process to the time of completion, include
<ul>
<li>Waiting to get into memory</li>
<li>Waiting in the ready queue</li>
<li>Executing on the CPU</li>
<li>Doing I/O</li>
</ul>
</li>
</ul>
</li>
<li>Process waiting time (等待时间)
<ul>
<li>amount of time that a process spent waiting in the ready queue.</li>
</ul>
</li>
<li>Process response time (响应时间)
<ul>
<li>amount of the time from the submission of a request until the first response/result is produced</li>
</ul>
</li>
</ol>
<h3 id="scheduling-algorithms">Scheduling Algorithms</h3>
<ol>
<li>First come first served (FCFS)
<ul>
<li>non-preemptive</li>
<li>Convoy effect (护航效应)</li>
</ul>
</li>
<li>Shortest job first (SJF)
<ul>
<li>minimum average waiting time</li>
<li>种类
<ol>
<li>Preemptive SJF allows to preempt the currently executing process</li>
<li>Non-preemptive</li>
</ol>
</li>
<li>比较适用于长程调度</li>
</ul>
</li>
<li>Priority scheduling
<ul>
<li>问题：starvation</li>
<li>解决： Aging (时效) – as time progresses increase the priority of the process</li>
</ul>
</li>
<li>Round robin (RR)
<ul>
<li>Is designed for especially for time-sharing systems</li>
<li>preemptive</li>
<li>time quantum
<ul>
<li>需要保证 80%的cpu bursts &lt; the time quantum</li>
</ul>
</li>
<li>Response time = 2*(n-1)*q</li>
</ul>
</li>
<li>Multilevel queue algorithm</li>
<li>Multilevel feedback queue algorithm
<ul>
<li>the most general scheduling algorithm</li>
</ul>
</li>
</ol>
<h3 id="multiple-processor-scheduling">Multiple-Processor Scheduling</h3>
<ul>
<li>homogeneous vs. heterogeneous CPUs
<ul>
<li>homogeneous: 各处理器都一样</li>
</ul>
</li>
<li>Approaches to multiple-processor scheduling
<ul>
<li>Asymmetric multiprocessing
<ul>
<li>only one processor (the master server) has all scheduling decision, I/O processing</li>
</ul>
</li>
<li>Symmetric multiprocessing
<ul>
<li>each processor is self-scheduling</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="chapter-6-process-synchronization">Chapter 6 Process synchronization</h2>
<ul>
<li>Race condition
<ul>
<li>The situation where several processes access and manipulate shared data concurrently.</li>
<li>The final value of the shared data depends upon which process finishes last.</li>
</ul>
</li>
</ul>
<h3 id="the-critical-section-problem">The Critical-Section Problem</h3>
<ul>
<li>
<p>critical section</p>
<ul>
<li>Each process has a code segment, called critical section, in which the shared data is accessed</li>
<li>有几个共享变量就有几个临界区</li>
</ul>
</li>
<li>
<p>Criteria for the critical section problem solution</p>
<ol>
<li>Mutual exclusion 互斥</li>
<li>progress 空闲让进</li>
<li>Bounded waiting 有限等待</li>
</ol>
</li>
<li>
<p>Peterson’s Solution</p>
<ul>
<li>举手+令牌</li>
</ul>
</li>
<li>
<p>hardware-based solution</p>
<ul>
<li>关中断
<ul>
<li>多处理机不适合</li>
</ul>
</li>
<li>原子操作</li>
</ul>
</li>
</ul>
<h3 id="semaphores">Semaphores</h3>
<ul>
<li>
<p>A Semaphore S – integer variable</p>
<ul>
<li>may be initialized via a non-negative value</li>
<li>Can only be accessed via two indivisible (atomic) operations: P() and V()</li>
</ul>
</li>
<li>
<p>P(): the wait() operation</p>
<pre tabindex="0"><code>wait (S) { 
  while (S.value &lt;= 0) ; 	// no-op
    S.value--;
}
</code></pre></li>
<li>
<p>V() The signal() operation</p>
<pre tabindex="0"><code>signal(S){
  S.value++;
}
</code></pre></li>
<li>
<p>main problem : busy waiting (spinlock)</p>
<ul>
<li>advantages
<ol>
<li>No context switch is required when a process must wait on a lock</li>
<li>If locks are expected to be held for short times, the spinlocks are useful</li>
</ol>
</li>
<li>disadvantages
<ol>
<li>wastes the CPU cycles that can be used by other processes productively</li>
</ol>
</li>
<li>解决：modify the definition of the wait() and signal() <strong>适用于 multiprocessor system</strong>
<ul>
<li>Wait(): the process can block() itself rather than engaging in busy waiting</li>
<li>Signal(): change the blocking process from the waiting state to the ready state</li>
</ul>
</li>
</ul>
</li>
<li>
<p>implementation</p>
<ol>
<li>In a single-processor environment</li>
</ol>
<ul>
<li>Disable interrupt</li>
</ul>
<ol start="2">
<li>In a multi-processor environment</li>
</ol>
<ul>
<li>Critical section can be applied</li>
</ul>
</li>
</ul>
<h2 id="chapter-7-deadlocks">Chapter 7 Deadlocks</h2>
<ul>
<li>Necessary conditions
<ol>
<li>Mutual exclusion</li>
<li>Hold and wait</li>
<li>No preemption</li>
<li>Circular wait</li>
</ol>
</li>
</ul>
<h3 id="methods-for-handling-deadlocks">Methods for Handling Deadlocks</h3>
<ol>
<li>
<p>Prevention</p>
<ul>
<li>Provides a set of methods for ensuring that at least one of necessary conditions cannot be held</li>
<li>针对条件2： all or nothing; 没有资源的时候才去申请</li>
<li>针对条件3： 谦让； 抢夺</li>
<li>针对条件4： 顺序执行</li>
<li>缺点： low device utilization and reduce system throughput.</li>
</ul>
</li>
<li>
<p>Avoidance</p>
<ul>
<li>using the addition information,decide whether the current request can be satisfied or must be delay</li>
<li>方法：
<ol>
<li>Resource-allocation graph
<ul>
<li>有环：处于unsafe state;可能处于死锁状态</li>
</ul>
</li>
<li>Banker&rsquo;s algorithm</li>
</ol>
</li>
</ul>
</li>
<li>
<p>Detection and recovery</p>
<ul>
<li>方法:
<ul>
<li>Wait-for graph
<ul>
<li>not appilcable to a resource-allocation system with multiple instances of each resource type</li>
</ul>
</li>
<li>Banker’s Algorithm</li>
</ul>
</li>
<li>When, and how often, to invoke detection algorithm. it depends on:
<ul>
<li>How often a deadlock is likely to occur?</li>
<li>How many processes will need to be rolled back?</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Ignorance</p>
</li>
</ol>
<h2 id="chapter-8">Chapter 8</h2>
<ul>
<li>
<p>Address may be represented in</p>
<ol>
<li>symbolic address</li>
<li>re-locatable address</li>
<li>absolute address</li>
</ol>
</li>
<li>
<p>address binding</p>
<ul>
<li>转换：
<ul>
<li>symbolic address -&gt; re-locatable address : compiler</li>
<li>re-locatable address -&gt; absolute address : linkage editor or loader</li>
</ul>
</li>
<li>发生的时期
<ol>
<li>Compile time
<ul>
<li>If memory location known at compile time, absolute code can be generated</li>
<li>If memory location is not known at compile time, Must generate re-locatable code</li>
</ul>
</li>
<li>Load time （+linkage time）
<ul>
<li>if memory location is known at load time, absolute code can be generated at this time</li>
</ul>
</li>
<li>Execution time
<ul>
<li>If memory location is not known at compile time and load time, Binding is delayed until run time</li>
<li>absolute code must be generated at run time</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="logical-vs-physical-address-space">Logical vs. Physical Address Space</h3>
<ul>
<li>
<p>Logical address ：CPU</p>
<ul>
<li>also referred to as virtual address</li>
<li>重定位地址和逻辑地址没有直接关系</li>
</ul>
</li>
<li>
<p>Physical address ：memory unit</p>
</li>
<li>
<p>logical (virtual) and physical addresses differ in execution-time address-binding scheme</p>
<ul>
<li>re-locatable code are seen by CPU</li>
<li>absolute code are seen by the memory unit</li>
</ul>
</li>
<li>
<p>Memory-Management Unit (MMU)</p>
<ul>
<li>Hardware device that maps virtual address to physical address in the run-time</li>
</ul>
</li>
<li>
<p>Dynamic load</p>
<ul>
<li>not loaded the entire program and data of a process be in physical memory for the process to execute until it is called</li>
<li>好处：
<ol>
<li>Better memory-space utilization</li>
<li>No special support is required from the operating system</li>
</ol>
</li>
</ul>
</li>
<li>
<p>Dynamic linking</p>
<ul>
<li>Linking is postponed until execution time</li>
<li>requires help from the OS</li>
</ul>
</li>
</ul>
<h3 id="contiguous-memory-allocation">Contiguous Memory Allocation</h3>
<ol>
<li>Fixed-Sized Contiguous Partition
<ul>
<li>Strengths (advantages)
<ul>
<li>Simple to implement</li>
<li>little overhead</li>
</ul>
</li>
<li>Weaknesses(drawbacks)
<ul>
<li>internal fragmentation
<ul>
<li>allocated memory may be larger than requested memory</li>
</ul>
</li>
<li>fixed number of processes</li>
</ul>
</li>
</ul>
</li>
<li>Dynamic Contiguous partition（可变分区）
<ul>
<li>Hole – block of available memory</li>
<li>Allocation algorithms
<ol>
<li>first fit:
<ul>
<li>从头开始，或者是从当前位置开始</li>
</ul>
</li>
<li>best-fit
<ul>
<li>Need to search all entire list, unless the list is ordered by size</li>
<li>produces the smallest leftover hole that may be wasted</li>
</ul>
</li>
<li>worst-fit
<ul>
<li>Need to search all entire list, unless the list is ordered by size</li>
<li>小进程多的 效果好</li>
</ul>
</li>
</ol>
</li>
<li>问题：
<ul>
<li>External Fragmentation</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>
<p>Solutions to fragmentation</p>
<ol>
<li>Compaction(紧凑)
<ul>
<li>To reduce external fragmentation</li>
<li>Shuffle memory contents to place all free memory together in one large block</li>
<li>It is done at execution time， it’s possible only if relocation is dynamic</li>
<li>May be expensive in moving the processes and the holes</li>
</ul>
</li>
<li>paging</li>
<li>segmentation</li>
</ol>
</li>
<li>
<p>Disadvantage of Contiguous Memory Allocation</p>
<ul>
<li>Fragmentation in main memory</li>
<li>Compaction is impossible on the disk</li>
</ul>
</li>
</ul>
<h3 id="paging">paging</h3>
<ul>
<li>
<p>frame: Divide physical memory into fixed-sized blocks</p>
</li>
<li>
<p>page : Divide logical memory into fixed-sized blocks</p>
<ul>
<li>page size is equal to frame size</li>
<li>Finding n free frames for loading a program of size n pages</li>
</ul>
</li>
<li>
<p>Translating logical address to physical address
If the address space is 2^m and the page size is 2^n</p>
<ul>
<li>Every logical address generated by CPU is divided into:
<ol>
<li>Page number (p: 页号)
<ul>
<li>used as an index into a page table</li>
<li>页表中包含每一页在physical memory 的 base address (f:块号)</li>
<li>p =address/2^n   is equal to m-n bit of the address</li>
</ul>
</li>
<li>Page offset (d: 偏移)
<ul>
<li>combined with base address (f:块号) to define the physical memory address that is sent to the memory unit</li>
<li>d =address%2n is equal to n bit of the address</li>
</ul>
</li>
</ol>
</li>
<li>Physical address
<ol>
<li>frame number（f: 帧号、块号)</li>
<li>page offset      (d:页偏移、块偏移)</li>
</ol>
</li>
</ul>
</li>
<li>
<p>page size的选择</p>
<ul>
<li>越大：
<ul>
<li>Disk I/O is more efficient</li>
<li>page table size 越小</li>
</ul>
</li>
<li>越小：
<ul>
<li>internal fragmentation 越小</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Frame table (主存分块表)</p>
<ul>
<li>Has one entry for each physical page frame
Indicating
<ul>
<li>whether the frame is free or it is allocated to which process</li>
</ul>
</li>
</ul>
</li>
<li>
<p>page table</p>
<ul>
<li>each process must maintain a copy of the page table</li>
<li>计算
<ul>
<li>if page-table entry is 4 bytes long
<ul>
<li>Can point to one of 2^32 physical page frames (1比特=8字节)</li>
<li>If frame size(= page size) is 4KB, the system can address 2^44 bytes(2^32×2^12=16TB) of physical memory</li>
</ul>
</li>
<li>对于32位cpu
<ul>
<li>page size: 4k (=2^12)</li>
<li>Table size：2^32/2^12=1M</li>
<li>each entry&rsquo;s size : 4 bytes</li>
<li>page table 的大小为： 4 MB</li>
</ul>
</li>
</ul>
</li>
<li>位置
<ol>
<li>直接存放在寄存器中：
<ul>
<li>Efficient and expensive</li>
<li>当page table is reasonable small 时可以</li>
</ul>
</li>
<li>存放在main memory ，然后用Page-table base register (PTBR：页表基址寄存器)存放其位置
<ul>
<li>进程切换时，加载页表只需要改变PTBR</li>
<li>every data/instruction access requires two memory accesses
<ul>
<li>One for the page table</li>
<li>One for the data/instruction</li>
</ul>
</li>
</ul>
</li>
<li>Translation Look-aside Buffer (TLB) also called Associate Memory(联想寄存器)
<ul>
<li>并行查找</li>
<li>contains only a few of page-table entries</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="structure-of-the-page-table">Structure of the Page Table</h3>
<ul>
<li>问题: The page table can be excessively large</li>
<li>Solution： Divide the page table into smaller pieces
<ol>
<li>Hierarchical Paging （分层页表）</li>
<li>Hashed Page Tables（哈希页表）</li>
<li>Inverted Page Tables（反置页表）</li>
</ol>
</li>
</ul>
<ol>
<li>Hierarchical Paging （分层页表）
<ul>
<li>缺陷：</li>
</ul>
<ol>
<li>需遍历，进程太多</li>
<li>可能有共享，而进程号只能填一个</li>
<li>不适用于64位</li>
</ol>
<ul>
<li>好：
<ol>
<li>需要的空间小</li>
</ol>
</li>
</ul>
</li>
<li>Hashed Page Tables
<ul>
<li>hash table -&gt; 在链表中遍历匹配</li>
</ul>
</li>
<li>Inverted Page Table(反置页表/主存分块表)</li>
</ol>
<ul>
<li>Only a page table in the system</li>
<li>One entry for each real page (or physical frame) of memory</li>
<li>缺点：
<ul>
<li>increases time needed to search the table when a page reference occurs</li>
<li>Lead to memory share difficulty</li>
</ul>
</li>
</ul>
<h3 id="segmentation">segmentation</h3>
<ul>
<li>User’s View of a Program: A program is a collection of segments，a segment is a logical unit such as:
<ul>
<li>main program
<ul>
<li>procedure ，function，method，object</li>
<li>local variables, global   variables</li>
<li>common block</li>
<li>stack</li>
<li>symbol table</li>
<li>arrays</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="chapter-9-virtual-memory">Chapter 9 Virtual Memory</h2>
<ul>
<li>
<p>the entire program is not needed to be in physical memory.这样的好处有：</p>
<ul>
<li>程序的大小不再受内存所限制</li>
<li>更多程序可以同时运行</li>
<li>Less I/O would be needed to load or swap each user program into memory, so program would start to run faster</li>
</ul>
</li>
<li>
<p>Virtual memory management</p>
<ul>
<li>a term used to describe a technique whereby the computer appears to have much more memory than it actually does</li>
</ul>
</li>
<li>
<p>Virtual memory can be implemented via:</p>
<ul>
<li>Demand paging</li>
<li>Demand segmentation</li>
</ul>
</li>
</ul>
<h3 id="demand-paging">Demand paging</h3>
<ul>
<li>
<p>思想： Bring a page into memory only when it is needed</p>
<ul>
<li>Be similar to a paging system with swapping</li>
</ul>
</li>
<li>
<p>Hardware</p>
<ul>
<li>Page table. 需要加一位valid–invalid bit
<ul>
<li>v -》 The page is legal and in memory</li>
</ul>
</li>
<li>Secondary memory
<ul>
<li>A high-speed disk, Swap space</li>
<li>Hold those page that are not present in memory</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Page Fault</p>
<ul>
<li>Access to a page marked invalid causes a page-fault trap</li>
<li>handle
<ol>
<li>Operating system looks at another table (PCB) to decide:
<ul>
<li>Invalid reference -&gt; abort</li>
<li>Just not in memory	（go on to 2））</li>
</ul>
</li>
<li>Get empty frame</li>
<li>Swap the desired page into the frame</li>
<li>modify the page table, Set validation bit = v</li>
<li>Restart the instruction that caused the page fault</li>
</ol>
</li>
<li>特殊：
<ol>
<li>一条指令可产生多个缺页中断</li>
<li>指令复执</li>
<li>在指令执行时中断。</li>
</ol>
</li>
<li>对比普通中断：
<ul>
<li>一条指令在执行完后，检查是否有中断请求
<ul>
<li>有：执行中断</li>
<li>无：执行下一条指令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="page-replacement">Page Replacement</h3>
<p><strong>替换算法</strong></p>
<ol>
<li>
<p>FIFO page Replacement</p>
<ul>
<li>Belady’s Anomaly : more frames -&gt; more page faults</li>
</ul>
</li>
<li>
<p>Optimal Page Replacement (OPT)</p>
<ul>
<li>替换最晚才用的页 或 后面最长时间用不到的页</li>
</ul>
</li>
<li>
<p>Least Recently Used (LRU) Algorithm</p>
<ul>
<li>思想： The recent past as an approximation of the near future</li>
<li>实现：</li>
<li>counters</li>
<li>stack</li>
</ul>
</li>
<li>
<p>LRU Approximation Algorithms</p>
<ol>
<li>Additional-reference-bits algorithm</li>
<li>Second chance (clock)</li>
<li>Enhanced second-chance algorithm</li>
</ol>
</li>
<li>
<p>Counting-Based Page Replacement</p>
<ul>
<li>Least Frequently used</li>
<li>Most Frequently used</li>
</ul>
</li>
<li>
<p>Page-Buffering Algorithm</p>
<ul>
<li>Assistant procedure to a page-replacement algorithm</li>
</ul>
</li>
</ol>
<h3 id="allocation-of-frames">Allocation of Frames</h3>
<ul>
<li>
<p>Two major allocation schemes</p>
<ol>
<li>fixed allocation
<ul>
<li>Equal allocation</li>
<li>Proportional allocation</li>
</ul>
</li>
<li>priority allocation
<ul>
<li>Use a proportional allocation scheme using priorities rather than size</li>
</ul>
</li>
</ol>
</li>
<li>
<p>Global vs. Local Allocation</p>
<ol>
<li>Local replacement
<ul>
<li>To allow a process to select from only its own set of allocated frames.</li>
<li>Cannot increase the number of frames allocated</li>
<li>Not affected by external circumstances</li>
</ul>
</li>
<li>Global replacement
<ul>
<li>To allow a process to select a replacement frame from the set of all frames, even if that frame is currently allocated to some other process</li>
<li>Can increase the number of frames allocated</li>
<li>Cannot control its page-fault rate.</li>
</ul>
</li>
</ol>
<ul>
<li>In general, global replacement is better.</li>
</ul>
</li>
</ul>
<h3 id="thrashing">Thrashing</h3>
<ul>
<li>A process is thrashing （颠簸）if it is spending more time paging than executing</li>
<li>approach
<ol>
<li>Using a local replacement algorithm</li>
<li>Working-set strategy
<ul>
<li>To compute the working-set size for each process in the system</li>
</ul>
</li>
<li>Page-Fault Frequency (PFF) Scheme  (水多了加面，面多了加水)
<ul>
<li>If actual rate too low, remove  a frame from the process</li>
<li>If actual rate too high, allocate another frame to the process</li>
<li>If no frames are free, suspend it</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="other-considerations">Other Considerations</h3>
<ul>
<li>page size 大小的选择要考虑到：
<ol>
<li>内碎片</li>
<li>页表的大小</li>
<li>I/O overhead (seek time, latency time, transfer time)</li>
<li>Locality</li>
<li>Page fault rate
<ul>
<li>顺序访问： page size越大，则缺页中断率越小</li>
<li>随机访问： page size越大，则more paging action could ensue because fewer pages can be kept in memory and more data is transferred per page fault.</li>
</ul>
</li>
</ol>
</li>
<li>Install a faster hard disk, or multiple controllers with multiple hard disks
<ul>
<li>for as the disk bottleneck is removed by faster response and more throughput to the disks, the CPU will get more data more quickly</li>
</ul>
</li>
</ul>
<h2 id="chapter-10-file-system-interface">Chapter 10 File-System Interface</h2>
<ul>
<li>File
<ul>
<li>A file is named collection of related information that is recorded on secondary storage</li>
<li>Six basic operations
<ol>
<li>create</li>
<li>read/write/seek</li>
<li>delete</li>
<li>truncate: to erase the contents of a file but keep its attributes except for it’s length</li>
</ol>
</li>
<li>Assistant operations
<ul>
<li>open(F):
<ol>
<li>search the directory structure on disk for entry F</li>
<li>copy the directory entry into the open-file table</li>
<li>allocate a file descriptor</li>
</ol>
</li>
<li>close(F):
<ol>
<li>copy the directory entry in the open-file table to the directory structure on disk</li>
<li>free the file descriptor</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="access-methods">Access Methods</h3>
<ul>
<li>The information in the file can be accessed in
<ol>
<li>sequentical access</li>
<li>direct access</li>
<li>other access
<ul>
<li>involve the construction of an index for the file</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="directory-structure">Directory Structure</h3>
<ul>
<li>
<p>symbol table</p>
<ul>
<li>The directory can be viewed as a symbol table that translates file names into their directory entries</li>
</ul>
</li>
<li>
<p>Criteria</p>
<ol>
<li>efficiency</li>
<li>naming</li>
<li>grouping</li>
</ol>
</li>
<li>
<p>shemes</p>
<ol>
<li>Single-Level Directory</li>
<li>Two-Level Directory
<ul>
<li>Positive
<ul>
<li>Efficient searching</li>
</ul>
</li>
<li>Negative
<ul>
<li>No grouping capability</li>
<li>Difficult to share file among different users</li>
</ul>
</li>
</ul>
</li>
<li>Tree-Structured Directories
<ul>
<li>Positive
<ul>
<li>Efficient searching</li>
<li>Grouping Capability</li>
</ul>
</li>
<li>Negative
<ul>
<li>Difficult to share file among different users</li>
</ul>
</li>
</ul>
</li>
<li>Acyclic-Graph Directories
<ul>
<li>Tree-structured directory + shared subdirectories or files</li>
<li>Created a new directory entry  called a link to implement sharing</li>
<li>The difficulty is to avoid cycles as new links are added</li>
</ul>
</li>
<li>General Graph Directory
<ul>
<li>Add the links to an existing tree-structure directory</li>
<li>Acyclic-Graph Directories更好</li>
</ul>
</li>
</ol>
</li>
<li>
<p>硬（hard）链接</p>
<ul>
<li><code>ln /usr/local/python3 python</code></li>
<li>目录中仅存储指向文件数据的指针</li>
<li>允许一个文件被多个目录引用.</li>
<li>无法用来链接目录，也不能跨文件系统</li>
<li>通过<code>ls -i</code>查看是否为硬链接</li>
</ul>
</li>
<li>
<p>软 (symbolic) 链接</p>
<ul>
<li>“快捷方式”</li>
<li>软链接也是一个文件</li>
<li><code> ln -s ../p24 p24</code></li>
<li>目录从“树”变为了“图”，还是有环图</li>
</ul>
</li>
<li>
<p>ACL: access-control list</p>
<ul>
<li>Each file or directory has an ACL</li>
</ul>
</li>
</ul>
<h2 id="file-system-implementation">File-System Implementation</h2>
<ul>
<li>File system organized into layers
<ol>
<li>application program</li>
<li>logical file system
<ul>
<li>FCB: file control blocks</li>
</ul>
</li>
<li>file-organizational module</li>
<li>basic file system</li>
<li>I/O control</li>
<li>devices</li>
</ol>
</li>
</ul>
<h3 id="allocation-methods">Allocation Methods</h3>
<ul>
<li>
<p>An allocation method refers to how disk blocks are allocated for files</p>
</li>
<li>
<p>Contiguous allocation</p>
<ul>
<li>Each file occupies a set of contiguous blocks on the disk</li>
<li>Supports both sequential access and direct access （Random access）</li>
<li>问题：
<ol>
<li>External fragmentation</li>
<li>Files cannot grow</li>
</ol>
</li>
</ul>
</li>
<li>
<p>Linked allocation</p>
<ul>
<li>Each file is a linked list of disk blocks: blocks may be scattered anywhere on the disk</li>
<li>优点
<ol>
<li>容易实现</li>
<li>无外碎片</li>
<li>文件增长方便</li>
</ol>
</li>
<li>缺点：
<ol>
<li>No random access</li>
<li>Poor reliability</li>
<li>慢（链表是保存在磁盘上的，所以需要多次查询）</li>
</ol>
</li>
<li>改进： File-allocation table (FAT)
<ul>
<li>把链表信息放到了一个单独的FAT表中，而不是各个数据块中，且进行备份</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Indexed allocation</p>
<ul>
<li>
<p>Bringing all the pointers together into one location: index block</p>
</li>
<li>
<p>Solutions to large files</p>
<ol>
<li>Linked sheme
<ul>
<li>Link blocks of index table</li>
</ul>
</li>
<li>Multilevel index</li>
<li>Combined scheme
<ul>
<li>一部分是 direct pointers ，一部分是multi-indirect block</li>
</ul>
</li>
</ol>
</li>
<li>
<p>Criteria</p>
<ol>
<li>storage utilization efficiency</li>
<li>data block access time</li>
</ol>
<ul>
<li>Contiguous allocation: Good for known-size file</li>
<li>Linked allocation: Good for storage utilization</li>
<li>Indexed allocation: Access time depends on index structure, file size, block position</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="free-space-management">Free-Space Management</h3>
<ul>
<li>The free-space list 的实现
<ol>
<li>Bit vector
<ul>
<li>优点
<ul>
<li>Simple to implement</li>
<li>Efficient to find the first free block</li>
</ul>
</li>
<li>缺点
<ul>
<li>Bit map requires extra space</li>
<li>Inefficient unless the entire vector is kept in main memory</li>
</ul>
</li>
</ul>
</li>
<li>Linked Lists (free list)
<ul>
<li>优点
<ul>
<li>No waste of space</li>
</ul>
</li>
<li>缺点
<ul>
<li>Inefficient when traversing the list</li>
</ul>
</li>
</ul>
</li>
<li>Grouping</li>
</ol>
<ul>
<li>The first free block store the addresses of n free blocks</li>
<li>Easier to find a large number of free blocks</li>
</ul>
</li>
</ul>
<h2 id="mass-storage-systems">Mass-Storage Systems</h2>
<ul>
<li>
<p>Magnetic disk&rsquo;s structure</p>
<ul>
<li>Disk platter</li>
<li>track</li>
<li>sector
<ul>
<li>each track is subdivided into several sectors</li>
</ul>
</li>
<li>cylinder
<ul>
<li>is the set of tracks that are at one arm position</li>
</ul>
</li>
</ul>
</li>
<li>
<p>CLV vs. CAV</p>
<ol>
<li>ClV : constant linear velocity
<ul>
<li>CD-ROM， DVD-ROM</li>
<li>Tracks in the outermost zone hold more sectors</li>
</ul>
</li>
<li>CAV : constant angular velocity
<ul>
<li>Magnetic disk</li>
<li>The density of bits decreases from inner tracks to outer tracks to keep the data rate constant</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="disk-scheduling">Disk Scheduling</h3>
<ul>
<li>Access time
<ol>
<li>Seek time is the time for the disk are to move the heads to the cylinder containing the desired sector
<ul>
<li>Seek time  seek distance</li>
</ul>
</li>
<li>Rotational latency
<ul>
<li>waiting for the disk to rotate the desired sector to the disk head</li>
</ul>
</li>
</ol>
</li>
<li>Disk bandwidth
<ul>
<li>The total number of bytes transferred / the total time  between the first request for service and the completion of the last transfer</li>
</ul>
</li>
</ul>
<ol>
<li>FCFS Scheduling</li>
<li>SSTF：Shortest-seek-time-first (SSTF)
<ul>
<li>最短寻道时间优先</li>
<li>问题：
<ul>
<li>往返跑&mdash;距离很短，但速度不一定很快</li>
<li>may cause starvation of some requests</li>
</ul>
</li>
</ul>
</li>
<li>SCAN</li>
</ol>
<ul>
<li>Sometimes called the elevator algorithm</li>
</ul>
<ol start="4">
<li>C-SCAN (Circular SCAN)</li>
</ol>
<ul>
<li>The head moves from one end of the disk to the other, servicing requests as it goes</li>
<li>When it reaches the other end, however, it immediately returns to the beginning of the disk, without servicing any requests on the return trip</li>
<li>回途不载客</li>
</ul>
<ol start="5">
<li>LOOK / C-LOOK</li>
</ol>
<ul>
<li>
<p>Similar to SCAN/C-SCAN</p>
</li>
<li>
<p>Arm only goes as far as the last request in each direction, then reverses direction immediately, without first going all the way to the end of the disk.</p>
</li>
<li>
<p>选择
<strong>Performance depends on the number and types of requests</strong></p>
<ul>
<li>SCAN and C-SCAN perform better for systems that place a heavy load on the disk</li>
<li>Either SSTF or LOOK is a reasonable choice for the default algorithm</li>
</ul>
</li>
</ul>
<h3 id="disk-management">Disk Management</h3>
<ul>
<li>Disk formatting
<ul>
<li>Low-Level Formatting (physical formatting )
<ul>
<li>Dividing a disk into sectors that the disk controller can read and write</li>
</ul>
</li>
<li>logical Formatting
<ul>
<li>Creation of a file system</li>
<li>Build the metadata structures for a file system</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="raid-structure">RAID Structure</h3>
<ul>
<li>
<p>Redundant Array of Inexpensive Disks (past)</p>
</li>
<li>
<p>Redundant Array of Independent Disks (now)</p>
<ul>
<li>Used for their higher reliability and higher data-transfer rate(performance)</li>
</ul>
</li>
<li>
<p>levels</p>
<ol>
<li>RAID 0
<ul>
<li>Disk arrays with data striping at the level of blocks but without any redundancy</li>
</ul>
</li>
<li>RAID 1
<ul>
<li>Disk mirroring</li>
</ul>
</li>
<li>RAID 2
<ul>
<li>Bit-level striping or Byte-level striping</li>
<li>Memory-style error-correcting-code (ECC)</li>
</ul>
</li>
<li>RAID 3
<ul>
<li>Bit-interleaved parity</li>
</ul>
</li>
<li>RAID 4
<ul>
<li>Block-interleaved parity organization</li>
</ul>
</li>
<li>RAID 5
<ul>
<li>Block-interleaved distributed parity</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="常用单词">常用单词</h2>
<ul>
<li>simultaneously : 同时地</li>
<li>idle : 空闲，懒</li>
<li>reside : 位于，居住</li>
<li>uni-processor : 单处理器</li>
<li>interleave: 交织</li>
<li>allocation : 分配</li>
<li>dashed line ： 虚线</li>
<li>minuscule : 微小的</li>
<li>concrete : 具体的</li>
<li>mandatory: 强制的</li>
<li>mediate : 调解</li>
<li>strip : 脱掉；条</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>软工导论复习笔记</title>
      <link>https://euds63.github.io/2023/%E8%BD%AF%E5%B7%A5%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 16 Jun 2023 18:28:40 +0800</pubDate>
      
      <guid>https://euds63.github.io/2023/%E8%BD%AF%E5%B7%A5%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>没有银弹</description>
      <content:encoded><![CDATA[<h1 id="软工导论复习">软工导论复习</h1>
<h2 id="chapter-0">Chapter 0</h2>
<ul>
<li>
<p>软件工程提出时间：1968年</p>
<p>1968年北大西洋公约组织(NATO)的计
算机科学家在联邦德国召开国际会议，
讨论软件危机问题，正式提出了“软件
工程”。</p>
</li>
</ul>
<h2 id="chapter-1">Chapter 1</h2>
<ul>
<li>The nature of software
Developed / Deteriorates / Custom built/ Complex</li>
</ul>
<h2 id="chapter-2">Chapter 2</h2>
<ul>
<li>
<p>软件工程定义</p>
<ol>
<li>The application of a systematic,
disciplined, quantifiable approach to the
development, operation, and maintenance
of software; that is, the application of
engineering to software.</li>
<li>The study of approaches as in (1).</li>
</ol>
</li>
<li>
<p>Software Process</p>
<ul>
<li>why: 需要及时的反馈</li>
<li>Process framework
<ul>
<li>Framework activities
<ul>
<li>Communication</li>
<li>Planning</li>
<li>Modeling
<ol>
<li>需求分析</li>
<li>设计</li>
</ol>
</li>
<li>Construction
<ol>
<li>代码</li>
<li>测试</li>
</ol>
</li>
<li>Deployment</li>
</ul>
</li>
<li>Umbrella Activities 庇护活动（普适性活动）
<ul>
<li>Software project tracking and control</li>
<li>Risk management</li>
<li>Software quality assurance</li>
<li>Technical reviews</li>
<li>Measurement</li>
<li>Software configuration management</li>
<li>Reusability management</li>
<li>Work product preparation and production</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Software Lifecycle</p>
<ul>
<li>软件有一个孕育、诞生、成长、成熟、
衰亡的生存过程。这个过程即为计算机
软件的生命周期(生存周期)</li>
<li>why need
<ul>
<li>从时间角度对软件开发和维护的复杂问题进行分解，把软件生存的漫长周期依次划分为若干个阶段，每个阶段有相对独立的任务，然后再逐步完成每个阶段的任务。</li>
<li>为软件人提供一个公共的框架，以便软件人的相互交流。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="chapter-4">Chapter 4</h2>
<ul>
<li>Evolutionary Models
<ul>
<li>prototype
<ul>
<li>类型
<ul>
<li>探索型(exploratory prototyping) 弄清需求</li>
<li>实验型(experimental prototyping)  验证方案</li>
<li>演化型(evolutionary prototyping)</li>
</ul>
</li>
<li>特征
<ul>
<li>可实际运行</li>
<li>它没有固定的生存期。它可能被扔掉，或者作为最终产品的一部分。</li>
<li>可为不同目标作原型</li>
<li>快速、廉价</li>
<li>是迭代过程的集成部分，即每次经用户评价后修改、运行，不断重复双方认可。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="chapter-5">Chapter 5</h2>
<ul>
<li>敏捷宣言
<ul>
<li>个体和互动 高于 流程和工具</li>
<li>工作的软件 高于 详尽的文档</li>
<li>客户合作 高于 合同谈判</li>
<li>响应变化 高于 遵循计划</li>
</ul>
</li>
<li></li>
</ul>
<h2 id="chapter-7">Chapter 7</h2>
<h3 id="requirements-engineering">Requirements Engineering</h3>
<ul>
<li>Inception</li>
<li>Elicitation</li>
<li>Elaboration</li>
<li>Negotiation</li>
<li>Specification
<ul>
<li>根据需求调查和需求分析的结果，进一步定义准确无误的产品需求，产生《产品需求规格说明书》</li>
</ul>
</li>
<li>Validation</li>
<li>Requirements management</li>
</ul>
<h3 id="quality-function-deployment">Quality Function Deployment</h3>
<ol>
<li>功能部署——确定系统功能的价值</li>
<li>信息部署——确定数据对象和事件</li>
<li>任务部署——确定系统的行为</li>
<li>价值分析——确定需求的优先级</li>
</ol>
<h3 id="non-functional-requirements">Non-Functional Requirements</h3>
<ul>
<li>quality attribute</li>
<li>performance attribute</li>
<li>security attribute</li>
<li>general system constraint</li>
</ul>
<h3 id="diagrams">diagrams</h3>
<p>Use-case / Class / State / Activity</p>
<h2 id="chapter-11">Chapter 11</h2>
<ul>
<li>Analysis model
<ul>
<li>focus on describing required data, function and behavior</li>
</ul>
</li>
</ul>
<h3 id="design-model">Design model</h3>
<ul>
<li>provide detail about software data structure, architecture, interfaces and components</li>
<li>4 kinds
<ul>
<li>Data/Class design——将分析类转换为实现类和数据结构</li>
<li>Architectural design——定义主要软件结构元素之间的关系</li>
<li>Interface design——定义软件元素、硬件元素和最终用户如何通信</li>
<li>Component-level design——转换结构元素到软件组件的过程描述中</li>
</ul>
</li>
</ul>
<h3 id="concepts">concepts</h3>
<ul>
<li>Architecture-软件的整体结构
<ul>
<li>体现了系统的模块化,抽象和信息隐藏,接口设计</li>
<li>举例
<ul>
<li>客户-服务器架构（Client-Server Architecture）</li>
<li>微服务架构（Microservices Architecture）</li>
<li>事件驱动架构（Event-Driven Architecture）</li>
<li>分层架构（Layered Architecture）</li>
</ul>
</li>
</ul>
</li>
<li>Pattern
<ul>
<li>The goal of a pattern：easy to reuse.</li>
<li>types:
<ul>
<li>Architecture Pattern
<ul>
<li>B/S, C/S</li>
</ul>
</li>
<li>Design Pattern</li>
<li>Idiom
<ul>
<li>a low-level pattern specific to a programming language</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Functional Independence
<ul>
<li>Cohesion 内聚
<ul>
<li>an indication of the relative functional strength of a module</li>
<li>功能内聚 分层内聚 通信内聚 顺序内聚 过程内聚 时间内聚 实用内聚（由高到低排列）</li>
</ul>
</li>
<li>Coupling 耦合
<ul>
<li>an indication of the relative interdependence among modules</li>
<li>非直接耦合 数据耦合 标记耦合 控制耦合 外部耦合 共用耦合 内容耦合 （ 由低到高排列）</li>
</ul>
</li>
<li>goal: 高内聚，低耦合</li>
</ul>
</li>
</ul>
<h2 id="chapter12-behavioral-modeling">Chapter12 Behavioral Modeling</h2>
<ul>
<li>what
the structure of the system, which comprise the software components, the externally visible properties of those components, and the relationships among them</li>
<li>The importance of architecture
<ul>
<li>for communication between all parties (stakeholders)</li>
<li>highlights early design decisions</li>
<li>constitutes a relatively small, intellectually graspable mode</li>
</ul>
</li>
<li>架构有什么用
<ul>
<li>分析设计在满足其规定要求方面的有效性</li>
<li>在进行设计更改仍然相对而言的阶段考虑架构替代方案容易</li>
<li>降低与软件构建相关的风险</li>
</ul>
</li>
</ul>
<h3 id="architecture-style">Architecture Style</h3>
<ul>
<li>定义内容
<ul>
<li>一组执行系统所需功能的构件</li>
<li>一组连接器，可以实现“通信、协调和组件之间的合作”</li>
<li>定义组件如何集成以形成系统的约束</li>
<li>语义模型，使设计人员能够通过分析系统组成部分的已知特性来理解系统的整体属性</li>
</ul>
</li>
<li>种类
<ul>
<li>数据流架构——批处理、管道和过滤器</li>
<li>调用和返回架构——主程序/子程序、面向对象系统、分层系统</li>
<li>独立组件架构——事件系统、触发器、监视器</li>
<li>虚拟机架构——解释器，基于规则的系统</li>
<li>仓库架构——数据库系统，黑板系统等</li>
</ul>
</li>
</ul>
<h2 id="chapter13-component-level-design">Chapter13 Component Level Design</h2>
<ul>
<li>一个模块化的、可部署的、可替换的系统部分，它封装了实现并公开了一组接口。</li>
</ul>
<h3 id="basic-design-principles">Basic Design Principles</h3>
<ol>
<li>开闭原则（OCP）——一个模块 [组件] 应该对扩展开放但对修改关闭</li>
<li>里氏替换原则（LSP）—— “子类应该可以替代它们的基类。</li>
<li>依赖倒置原则（DIP）——依赖于抽象。不要依赖实体
<ul>
<li>高层模块应该依赖于抽象（接口或抽象类）</li>
<li>抽象不应该依赖于具体实现，具体实现应该依赖于抽象</li>
</ul>
</li>
<li>接口分离原则 (ISP)——许多专用的接口都比一个通用接口好</li>
<li>发布重用等效原则 (REP)——重用的粒度就是发布的粒度</li>
<li>共同闭合原则（CCP）——同时修改的类应该放在一起</li>
<li>共同重用原则（CRP）——不能同时复用的类不应该放在一起</li>
</ol>
<h2 id="chapter14-user-interface-design">Chapter14 User Interface Design</h2>
<ul>
<li>黄金规则
<ul>
<li>用户控制操作</li>
<li>减少用户记忆负担</li>
<li>保持界面一致</li>
</ul>
</li>
</ul>
<h2 id="chapter-15-16-software-quality">Chapter 15-16 Software Quality</h2>
<ul>
<li>
<p>什么是软件质量
一个有效的软件过程，其应用方式创造了一个有用的产品，为生产它的人和使用它的人提供可衡量的价值</p>
</li>
<li>
<p>McCall’s Triangle of Quality</p>
<ul>
<li>产品修改</li>
<li>产品转移</li>
<li>产品运行</li>
</ul>
</li>
<li>
<p>The Cost of Quality</p>
<ul>
<li>在测试和维护阶段改正错误和缺陷的成本急剧增高</li>
<li>种类：
<ol>
<li>预防成本（COP）</li>
<li>评估成本（COA）</li>
<li>内部失败成本</li>
<li>外部失败成本</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="chapter-17-19-testing-strategy--techniques">Chapter 17-19. Testing Strategy &amp; Techniques</h2>
<ul>
<li>Verification vs. Validation
<ul>
<li>Verification: 确保软件能实现特定功能 building the product right</li>
<li>Validation: 确保软件可追溯到客户需求 building the right product</li>
</ul>
</li>
<li>测试策略——从小到大
<ul>
<li>单元测试</li>
<li>集成测试</li>
<li>系统测试</li>
<li>验收测试
<ul>
<li>α testing 由最终用户在开发人员站点进行</li>
<li>ß testing 在最终用户站点进行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="测试策略之unit-testing">测试策略之unit testing</h3>
<ul>
<li>内容：
<ul>
<li>接口</li>
<li>局部数据结构</li>
<li>边界条件</li>
<li>独立路径</li>
<li>错误处理路径</li>
</ul>
</li>
<li>stub——代替底层</li>
<li>driver——代替顶层
<ul>
<li>提供了一个框架用于设置输入参数，环境 ，执行单元</li>
</ul>
</li>
</ul>
<h3 id="测试策略之integration-testing">测试策略之integration testing</h3>
<ul>
<li>Top Down Integration
<ul>
<li>Advantage
<ul>
<li>A skeletal version of the program can exist early and allows demonstrations</li>
<li>Design errors may be found sooner.</li>
<li>Reduces the need for test drivers</li>
<li>It tends to make fault location easier</li>
</ul>
</li>
<li>Disadvantage
<ul>
<li>stubs could be expensive to build.</li>
</ul>
</li>
</ul>
</li>
<li>Bottom-Up Integration
<ul>
<li>Advantage
<ul>
<li>Particular useful for objects and reuse.</li>
<li>requiring no structural design information</li>
</ul>
</li>
<li>Disadvantage
<ul>
<li>The program as a whole does not exist until the last module is added.</li>
<li>requires test drivers, not test stubs.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="测试策略之system-testing充分运用基于计算机的系统">测试策略之system testing——充分运用基于计算机的系统</h3>
<ul>
<li>目的：
<ul>
<li>在将要运行的真实环境中测试整个系统</li>
<li>确保系统满足整体工作的要求</li>
<li>还要测试系统功能之外的方面</li>
<li>结果有时用于系统验收</li>
<li>验证软件用户手册</li>
<li>估计可靠性和可维护性</li>
</ul>
</li>
</ul>
<h3 id="测试方法">测试方法</h3>
<ul>
<li>黑盒测试（功能）</li>
<li>白盒测试（结构）</li>
</ul>
<h2 id="chapter-21-software-configuration-management">Chapter 21 Software configuration management</h2>
<h3 id="the-scm-process">The SCM Process</h3>
<ol>
<li>identification</li>
<li>change control</li>
<li>version control</li>
<li>configuration auditing</li>
<li>reporting</li>
</ol>
<ul>
<li>Software configuration item</li>
</ul>
<h2 id="chapter-22--project-management-concept">Chapter 22  Project Management Concept</h2>
<h3 id="4-p">4 p</h3>
<ul>
<li>people</li>
<li>product
<ul>
<li>scopes
<ol>
<li>context</li>
<li>information objectives</li>
<li>function and performance</li>
</ol>
</li>
</ul>
</li>
<li>Process
<ul>
<li>Consider project characteristics</li>
<li>Determine the degree of rigor required</li>
<li>Define a task set for each software engineering activity</li>
</ul>
</li>
<li>Project
<ol>
<li>从正确的基础上开始工作——首先通过努力理解要解决的问题，然后设定现实的目标和期望来实现的</li>
<li>保持动力——项目经理必须提供激励措施，将人员流动率控制在最低限度，团队应在其执行的每项任务中强调质量，高级管理人员应尽一切可能远离团队</li>
<li>跟踪进度——作为质量保证活动的一部分，随着工作产品（例如模型、源代码、测试用例集）的生成和批准（使用正式的技术评审），进度会被跟踪。</li>
<li>做出明智的决定——项目经理和软件团队的决定应该是“保持简单”</li>
<li>进行事后分析——建立一个一致的机制来提取每个项目的经验教训</li>
</ol>
</li>
</ul>
<h3 id="w5hh">W5HH</h3>
<ol>
<li>Why is the system being developed?——为什么</li>
<li>What will be done? ——做什么</li>
<li>When will it be accomplished?——什么时候做</li>
<li>Who is responsible?——谁负责</li>
<li>Where are they organizationally located?——其他人的组织机构位于何处</li>
<li>How will the job be done technically and managerially?——如何完成技术工作和管理工作</li>
<li>How much of each resource (e.g., people, software, tools, database) will be needed?——每种资源需要多少</li>
</ol>
<h3 id="task-set-">Task set =</h3>
<ul>
<li>Software engineering tasks</li>
<li>Work products</li>
<li>Quality assurance points</li>
<li>Milestones</li>
</ul>
<h3 id="software-engineering-activity">software engineering activity</h3>
<ul>
<li>需求分析</li>
<li>设计</li>
<li>软件开发</li>
<li>软件部署</li>
<li>软件维护</li>
<li>项目管理</li>
<li>质量保证</li>
<li>配置管理</li>
<li>文档编写</li>
</ul>
<h2 id="chapter-23-process-and-project-metrics">Chapter 23 Process and Project Metrics</h2>
<ul>
<li>意义
<ol>
<li>评估正在进行的项目的状态</li>
<li>跟踪潜在风险</li>
<li>在问题造成不良影响前发现风险</li>
<li>调整工作流程或任务</li>
<li>评估项目团队控制软件工作产品质量的能力</li>
</ol>
</li>
</ul>
<h3 id="process-measurement">Process Measurement</h3>
<ul>
<li>根据过程中获得的一系列数据或软件工程任务的特性来进行测量。</li>
<li>Software Process Improvement (SPI)</li>
<li>5 Metrics
<ul>
<li>Quality-related</li>
<li>Productivity-related</li>
<li>Statistical SQA data</li>
<li>Defecti removal effciency</li>
<li>Reuse data</li>
</ul>
</li>
</ul>
<h3 id="项目度量">项目度量</h3>
<ul>
<li>三个方面
<ul>
<li>如期</li>
<li>质量</li>
<li>成本</li>
</ul>
</li>
</ul>
<h3 id="chapter-24-25-project-estimation--scheduling">Chapter 24-25 Project Estimation &amp; Scheduling</h3>
<h3 id="scope">scope</h3>
<ul>
<li>Scope refers to all the work involved in creating the
products of the project and the processes used to
create them. It defines what is or is not to be done</li>
<li>项目范围的内容
<ul>
<li>交付给最终用户的功能和特性</li>
<li>输入和输出的数据</li>
<li>由于使用软件而呈现给用户的“内容”</li>
<li>性能、约束、接口、和约束系统的可靠性</li>
</ul>
</li>
</ul>
<h3 id="work-breakdown-structure-wbs">Work Breakdown Structure (WBS)</h3>
<ul>
<li>进行WBS的五种方法
<ol>
<li>使用指南：一些组织提供的指南</li>
<li>类比方法：审查类似项目的 WBS，并根据我们的项目 进行定制。</li>
<li>自上而下的方法：从项目中最大的项目开始，并将它们分解</li>
<li>自下而上的方法：从详细的任务开始，并将它们汇总</li>
<li>思维导图方法：以非线性格式写下任务，然后创建 WBS 结构</li>
</ol>
</li>
</ul>
<h3 id="估计方法">估计方法</h3>
<ul>
<li>基于代码行的估计
<ul>
<li>优点：易于测量、容易自动化</li>
<li>缺点：仅限于代码不能用于设计、依赖于语言、没有考虑功能的复杂性、与设计的好坏挂钩</li>
</ul>
</li>
<li>基于功能点的估计
<ul>
<li>优点：
<ol>
<li>可用于最早的需求阶段</li>
<li>独立于编程语言、产品设计或开发风格</li>
<li>用户视图，而不是实现视图</li>
<li>可用于衡量非编码活动</li>
<li>存在大量历史数据</li>
<li>有据可查</li>
</ol>
</li>
<li>缺点：
<ol>
<li>无法直接计算现有产品（源代码）的 FP 内容</li>
<li>难以自动化</li>
<li>FP 不反映语言、设计或风格差异</li>
<li>FP 设计用于估计商业数据处理应用</li>
<li>主观计数</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="项目调度">项目调度</h3>
<ol>
<li>项目为什么会延期
不切实际的截止日期
需求的变化
低估工作量
不可预测的风险
技术难题
人为困难
沟通不畅
未能认识到项目落后于计划或缺乏纠正问题的行动</li>
<li>调度的原则
划分——定义多个不同的任务
相互依赖性——明确任务的相互关系
工作量确认——确保人力资源可用
确定责任——明确责任承担者
明确输出结果——确定活动产生的结果
确定里程碑——进行质量审查</li>
<li>调度的步骤
<ol>
<li>定义任务集——WBS</li>
<li>安排活动</li>
<li>绘制项目网络图</li>
<li>关键路径分析</li>
<li>使用甘特图进行调度</li>
<li>进度跟踪</li>
</ol>
</li>
</ol>
<h2 id="chapter-26-risk-management">Chapter 26 Risk Management</h2>
<ul>
<li>
<p>Reactive Risk Management</p>
</li>
<li>
<p>Proactive Risk Management</p>
<ul>
<li>formal risk analysis is performed</li>
<li>corrects the root causes of risk</li>
</ul>
</li>
<li>
<p>Risk Management Paradigm</p>
<ol>
<li>Risk identification</li>
<li>Risk analysis</li>
<li>Risk planning</li>
<li>Risk monitoring</li>
</ol>
</li>
<li>
<p>RMMM</p>
<ul>
<li>Mitigation</li>
<li>Monitoring</li>
<li>Management</li>
</ul>
</li>
</ul>
<h2 id="常用图">常用图</h2>
<ul>
<li>用例图</li>
<li>类图</li>
<li>活动图
<ul>
<li>变形：泳道图</li>
</ul>
</li>
<li>顺序图</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>表单学习</title>
      <link>https://euds63.github.io/2023/%E8%A1%A8%E5%8D%95%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Thu, 30 Mar 2023 23:52:16 +0800</pubDate>
      
      <guid>https://euds63.github.io/2023/%E8%A1%A8%E5%8D%95%E5%AD%A6%E4%B9%A0/</guid>
      <description>发现原来表单要做得符合直觉也是有些学问在里面的，遂记录如下。</description>
      <content:encoded><![CDATA[<h1 id="表单学习">表单学习</h1>
<p><em>偶然间看到了篇不错的文档，<a href="https://www.chromium.org/developers/design-documents/create-amazing-password-forms/"  target="_blank" rel="noopener" >Create Amazing Password Forms</a>,才发现原来表单要做得符合直觉也是有些学问在里面的，遂记录如下。</em></p>
<h2 id="group-related-fields-in-a-single-form">Group related fields in a single form</h2>
<p>我之前习惯把注册和登录分开来做，使用的不少网站也是这样。所以就导致了一种情况，在使用浏览器的密码自动保存时，往往注册完后要登录，就得再输一遍代码。但是我还不知道具体要怎么实现。</p>
<h2 id="use-autocomplete-attributes">Use autocomplete attributes</h2>
<p>autocomplete这个attribute我还是第一次见，查阅文档后，发现这个还蛮有用的。<a href="https://www.chromium.org/developers/design-documents/form-styles-that-chromium-understands/"  target="_blank" rel="noopener" >Password Form Styles that Chromium Understands</a>
e.g. <code>&lt;input name=bc autocomplete=&quot;section-home homeAddress&quot;&gt;</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"> <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;text&#34;</span> <span class="na">autocomplete</span><span class="o">=</span><span class="s">&#34;username&#34;</span><span class="p">&gt;</span> 
</span></span><span class="line"><span class="cl"> <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;password&#34;</span> <span class="na">autocomplete</span><span class="o">=</span><span class="s">&#34;current-password&#34;</span><span class="p">&gt;</span> 
</span></span><span class="line"><span class="cl"> <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;submit&#34;</span> <span class="na">value</span><span class="o">=</span><span class="s">&#34;Sign In!&#34;</span><span class="p">&gt;</span> 
</span></span></code></pre></div><p>而关于autocomplete和autofill的区别</p>
<p>我查了下有这样的回答</p>
<ul>
<li>autocomplete是HTML5新增的属性，用于指定浏览器是否应该启用表单自动完成功能，以及提供有关字段中预期信息类型的指导。</li>
<li>autofill是浏览器自带的自动填充功能，它会根据用户之前输入过的值来预测用户下一次可能输入的值，并在用户输入时自动填充。autofill不仅考虑了之前输入过的值，还考虑了字段的含义和结构。例如，Google Chrome实现了解析输入字段以猜测其类型和结构。</li>
</ul>
<h2 id="use-hidden-fields-for-implicit-information">Use hidden fields for implicit information</h2>
<p>这点对于我来说也是挺新鲜的。才知道尽管有些信息没必要让用户输入，但还是有必要在表单中所包含，以便于密码管理器。</p>
<p>文档中是这样讲的</p>
<blockquote>
<p>the user agent is allowed to provide the user with autocompletion values, but does not provide any further information about what kind of data the user might be expected to enter. User agents would have to use heuristics to decide what autocompletion values to suggest.</p>
</blockquote>
<p>目前我的理解是，autocomplete用来提升浏览器字段的类型，而autofill用来控制是否使用该功能</p>
<h2 id="尾巴">尾巴</h2>
<p>还是第一次看html的文档，不是太能看得下去，因为内容太多了，信息量比较大，但确实有用</p>
<ul>
<li>参考链接
<ul>
<li><a href="https://www.chromium.org/developers/design-documents/create-amazing-password-forms/"  target="_blank" rel="noopener" >Create Amazing Password Forms</a></li>
<li><a href="https://www.chromium.org/developers/design-documents/form-styles-that-chromium-understands/"  target="_blank" rel="noopener" >Password Form Styles that Chromium Understands</a></li>
<li><a href="https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofilling-form-controls%3A-the-autocomplete-attribute"  target="_blank" rel="noopener" >autocomplete</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Linux学习笔记</title>
      <link>https://euds63.github.io/2023/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 19 Mar 2023 18:38:50 +0800</pubDate>
      
      <guid>https://euds63.github.io/2023/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>Linux学习笔记</description>
      <content:encoded><![CDATA[<h2 id="linux命令">Linux命令</h2>
<ul>
<li><code>ctrl + C</code> 打断执行</li>
<li><code>pwd</code> 输出当前位置</li>
<li><code>cmd1;cmd2</code> 首先运行命令1，然后运行命令2</li>
<li><code>cmd1&amp;&amp;cmd2</code> 仅在命令1成功结束时才运行命令2</li>
<li><code>cmd1||cmd2</code> 仅当命令1失败时才运行命令2</li>
<li><code>strace</code>  追踪程序系统调用</li>
<li><code>touch</code> 新建文件,内容为空</li>
<li><code>cat</code>
<ul>
<li><code>cat filename</code> To view a single file</li>
<li><code>cat [filename-whose-contents-is-to-be-copied] &gt; [destination-filename]</code> Copy the contents of one file to another file.</li>
<li><code>cat file1 &gt;&gt; file2</code> Cat command can append the contents of one file to the end of another file.</li>
</ul>
</li>
<li>管道；用<code>|</code>连接两个命令，以前面一个命令的输出作为后面命令的输入
<ul>
<li><code>strace -f gcc a.c 2&gt;&amp;1 | vim -</code> This will pipe both stdout and stderr to vim. The <code>-</code> argument tells vim to read from stdin.</li>
<li><code>strace pmap 152 |&amp; vim - </code>
<code>|&amp;</code> : This is a shorthand for <code>2&gt;&amp;1 |</code> in bash and zsh. It passes both standard output and standard error of one command as input to another.</li>
</ul>
</li>
<li><code>sort -nk 6</code> 依第6列升序排列</li>
<li>执行多次，或循环执行
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1">#for i in {1..5}; do  // while true; do</span>
</span></span><span class="line"><span class="cl">&gt;  <span class="nb">command</span> 
</span></span><span class="line"><span class="cl">&gt;done
</span></span></code></pre></div></li>
<li>crontab的使用
<ul>
<li><code>crontab -e</code></li>
<li>注意：crontab运行的环境并不包含docker命令。需要指定完整的路径。</li>
</ul>
</li>
<li><code>lsof -i:端口号</code>查看端口占用情况</li>
<li><code>kill -9 PID</code> 杀掉对应的进程</li>
<li><code>grep</code> (global regular expression)  用于查找文件里符合条件的字符串或正则表达式</li>
<li><code>which</code> 查找安装路径 如<code>which docker</code></li>
<li><code>ls -l</code> 详细信息</li>
<li><code>~/.bashrc</code>是 Bash shell 在每次启动时都会自动执行的一个脚本文件,可以用于设置环境变量、别名和一些其他 Bash shell 配置。
<ul>
<li><code>source /opt/rh/devtoolset-9/enable</code> 更新gcc版本</li>
<li>export PS1=&rsquo;[][\W]$ []&rsquo; 修改PS1变量，让其更加简洁。PS1的默认设置为<code>\[\][\u@\h \W]\$ \[\]</code></li>
</ul>
</li>
<li><code>tar</code>
<ul>
<li><code>tar cvf file.tar *.c</code> creates a tar file called file.tar which is the Archive of all .c files in current directory.</li>
<li><code>tar xvf file.tar</code> extracts files from Archives.</li>
<li><code>z</code>tells tar command that creates tar file using gzip 即<code>tar.gz</code></li>
</ul>
</li>
<li>可以利用 TAB 补全查看所有可用的命令选项(连按两次 TAB 键)</li>
</ul>
<h2 id="汇编相关">汇编相关</h2>
<ul>
<li><code>objdump -d filename</code> print the assembler content of the sections capable of execution.</li>
<li><code>objdump -s filename</code>  print the complete content of all the sections of the file</li>
</ul>
<h2 id="gcc">gcc</h2>
<ul>
<li><code>gcc - E a.c</code> 对a.c进行宏展开</li>
<li>升级gcc版本到gcc9 <a href="https://blog.csdn.net/xunye_dream/article/details/108918316"  target="_blank" rel="noopener" >CentOS7 升级gcc版本到gcc9</a>
<code>source /opt/rh/devtoolset-9/enable</code></li>
<li><code>-static</code> 静态编译，省去动态链接相关的系统调用</li>
</ul>
<h2 id="vim">vim</h2>
<ul>
<li>cmd模式
<ul>
<li><code>:!cmd </code> execute a shell command from within Vim
<ul>
<li><code>!gcc %</code> 编译</li>
<li><code>!xxd</code>  将当前文件转换为十六进制表示并显示在终端中</li>
<li><code>%!xxd</code> 将当前文件的内容通过管道传递给外部命令xxd，并将其输出替换为当前文件的内容</li>
</ul>
</li>
<li><code>:set nu</code> 显示行号</li>
<li><code>:set wrap</code></li>
<li><code>:%!grep execve</code></li>
<li><code>:%! grep -v ENOENT</code></li>
<li><code>:%s/term/another_term/g </code> 替换</li>
</ul>
</li>
<li>visual模式 按v进入
<ul>
<li><code>y</code> 复制选中内容</li>
<li><code>d</code> 删除</li>
</ul>
</li>
<li><code>u</code> undo</li>
<li></li>
</ul>
<h2 id="gdb">gdb</h2>
<ul>
<li>编译时要带<code>-g</code></li>
<li><code>bt</code> :but trace</li>
</ul>
<hr>
<h2 id="参考链接">参考链接</h2>
<ul>
<li><a href="https://www.geeksforgeeks.org/cat-command-in-linux-with-examples/"  target="_blank" rel="noopener" >Cat command in Linux with examples</a></li>
<li><a href="https://blog.csdn.net/xunye_dream/article/details/108918316"  target="_blank" rel="noopener" >CentOS7 升级gcc版本到gcc9</a></li>
<li><a href="https://jyywiki.cn/OS/2022/"  target="_blank" rel="noopener" >操作系统：设计与实现 (2022 春季学期)</a></li>
<li><a href="https://blog.csdn.net/lc013/article/details/103775702"  target="_blank" rel="noopener" >Linux 定时执行shell 脚本</a></li>
<li><a href="https://www.geeksforgeeks.org/tar-command-linux-examples"  target="_blank" rel="noopener" >tar command in Linux with examples</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>network</title>
      <link>https://euds63.github.io/2023/network/</link>
      <pubDate>Sat, 11 Mar 2023 19:32:04 +0800</pubDate>
      
      <guid>https://euds63.github.io/2023/network/</guid>
      <description>网络配置学习</description>
      <content:encoded><![CDATA[<h1 id="网络">网络</h1>
<h2 id="过程">过程</h2>
<ul>
<li>先是看<a href="https://www.jianshu.com/p/53457e21fcd4"  target="_blank" rel="noopener" >如何让国内的阿里云服务器可以高速下载Github代码</a>，但这个是纯命令行的，用的是pm2</li>
<li>因为延迟比较大，想切换节点，首先是研究怎么用命令行实现.确实可以，<a href="https://sakronos.github.io/Note/2021/03/06/%E4%BD%BF%E7%94%A8Clash-APIj%E5%88%87%E6%8D%A2%E8%8A%82%E7%82%B9/"  target="_blank" rel="noopener" >使用Clash-API切换节点</a>有介绍，但我去操作的话不行，返回<code>{&quot;message&quot;:&quot;Body invalid&quot;}  </code>。看也有人提issue，但我还是不能成功更改。加上这样更改的话，就挺麻烦的。于是想着能不能搞个ui。</li>
<li>然后参考<a href="https://blog.zzsqwq.cn/posts/how-to-use-clash-on-linux/"  target="_blank" rel="noopener" >如何在Linux上优雅的使用Clash</a>这篇，docker让这些配置变得简单多了。但我还是遇到了些问题：主要是自作聪明，修改了</li>
</ul>
<pre tabindex="0"><code> - ./config.yaml:/root/.config/clash/config.yaml
 - ./Country.mmdb:/root/.config/clash/Country.mmdb
</code></pre><p>调试后才发现并不用修改。另一个是配置<code>external-controller: :9090</code>时，自己改成了<code>127.0.0.1:9090</code></p>
<ul>
<li>上面那篇文章少了暴露接口这一步，<a href="https://juejin.cn/post/7054941050216906760"  target="_blank" rel="noopener" >如何为实验室服务器配置终端代理</a>，<a href="https://zhuanlan.zhihu.com/p/46973701"  target="_blank" rel="noopener" >Linux 让终端走代理的几种方法</a>,这两篇讲得挺好的</li>
</ul>
<h2 id="收获">收获</h2>
<ul>
<li>了解了配置文件怎么写的</li>
<li>学到了如何检查是处于代理状态：<code>curl cip.cc</code>，但得到的地址和我实际走的节点不一样</li>
</ul>
<h2 id="参考链接">参考链接</h2>
<ul>
<li><a href="https://sakronos.github.io/Note/2021/03/06/%E4%BD%BF%E7%94%A8Clash-APIj%E5%88%87%E6%8D%A2%E8%8A%82%E7%82%B9/"  target="_blank" rel="noopener" >使用Clash-API切换节点</a></li>
<li><a href="https://github.com/Dreamacro/clash/issues/659"  target="_blank" rel="noopener" >通过RESTful API更改节点代理返回{&ldquo;message&rdquo;:&ldquo;Body invalid&rdquo;}</a></li>
<li><a href="https://www.jianshu.com/p/53457e21fcd4"  target="_blank" rel="noopener" >如何让国内的阿里云服务器可以高速下载Github代码</a></li>
<li><a href="https://blog.zzsqwq.cn/posts/how-to-use-clash-on-linux/"  target="_blank" rel="noopener" >如何在Linux上优雅的使用Clash</a></li>
<li><a href="https://juejin.cn/post/7054941050216906760"  target="_blank" rel="noopener" >如何为实验室服务器配置终端代理</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/46973701"  target="_blank" rel="noopener" >Linux 让终端走代理的几种方法</a></li>
<li><a href="https://github.com/Dreamacro/clash/wiki/configuration"  target="_blank" rel="noopener" >Configuration</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>git学习笔记</title>
      <link>https://euds63.github.io/2022/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 04 Sep 2022 12:31:47 +0800</pubDate>
      
      <guid>https://euds63.github.io/2022/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>记录git学习</description>
      <content:encoded><![CDATA[<h1 id="git学习笔记">git学习笔记</h1>
<h2 id="使用技巧">使用技巧</h2>
<h3 id="github项目内搜索">Github项目内搜索</h3>
<p>在仓库页面上按 T ，然后直接输入文件名</p>
<hr>
<h2 id="记录">记录</h2>
<h3 id="gitee配置的记录">Gitee配置的记录</h3>
<p>因为srtp项目是用gitee作托管，所以今天试着配置了下Gitee，还是花了些时间的，记录如下：</p>
<ol>
<li>主要参考的是<a href="https://cloud.tencent.com/developer/article/1774890"  target="_blank" rel="noopener" >Git同时配置Gitee和GitHub</a>,但它上面第一步就是让清除git的全局设置，有点不敢，因为怕清除后自己之前设置的一些东西出错。</li>
<li>又看了几个教程，发现<a href="https://blog.csdn.net/weixin_43894513/article/details/104550377"  target="_blank" rel="noopener" >Github 与 Gitee 共存配置</a>上并没有说要清楚全局设置，于是就跟着上面的一步步走，很顺利地就设置好了。</li>
<li>一个收获是<code>config</code>,<code>id_rsa</code>都是可以用记事本打开并编辑的。</li>
</ol>
<h3 id="多人协作时的流程">多人协作时的流程</h3>
<p>这次小组项目用的是华为云，所以流程也都是基于华为云来说的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 注：代码中的中文请根据实际情况进行替换</span>
</span></span><span class="line"><span class="cl"><span class="c1">#确定好本次代码开发所要完成的任务，开好远程分支x，相关信息(分支名称，描述，关联工作项）要注明好</span>
</span></span><span class="line"><span class="cl">git pull <span class="c1">#确保代码、分支是最新的</span>
</span></span><span class="line"><span class="cl">git checkout -b 本地分支名 origin/远程分支名   <span class="c1">#检出远程分支到本地</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 代码开发</span>
</span></span><span class="line"><span class="cl">git add .
</span></span><span class="line"><span class="cl">git commit -m<span class="s2">&#34;适当的批注&#34;</span>
</span></span><span class="line"><span class="cl">git push <span class="c1">#将代码推送到远程分支，开发过程中这个操作可以频繁点，好处是：代码备份和版本管理</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 完成本次代码开发所要完成的任务后（请确定功能实现，本地调试没问题）</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 接下来进行分支的合并 </span>
</span></span><span class="line"><span class="cl"><span class="c1"># 在华为云中新建合并请求（可设置检视人，评审人，让别人帮忙看看）</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 合并完成后（默认设置是分支合并后，源分支是删除的）</span>
</span></span><span class="line"><span class="cl">git remote prune origin <span class="c1">#当华为云上显示远程分支已经删除，但git branch -r仍然看到所删除的分支，执行该命令</span>
</span></span><span class="line"><span class="cl">git checkout master <span class="c1">#切回master分支（一次任务完成后，建议切回master分支，这样pull的时候可以避免自己写的代码丢失的问题）</span>
</span></span><span class="line"><span class="cl">git branch -d 本地分支名 <span class="c1">#删除本次任务所用的本地分支（也可以不删，当作备份）</span>
</span></span></code></pre></div><h3 id="对remote-branch的认识">对remote branch的认识</h3>
<p>There are potentially three versions of every remote branch:</p>
<ol>
<li>The actual branch on the remote repository</li>
<li>The snapshot of that branch locally</li>
<li>A local branch that might be tracking the remote branch</li>
</ol>
<hr>
<h2 id="常用命令">常用命令</h2>
<h3 id="add">add</h3>
<ul>
<li><code>git add .</code> 会根据。gitignore做过滤</li>
<li><code>git add *</code> 会忽略。gitignore把任何文件都加入</li>
</ul>
<h3 id="推送">推送</h3>
<p>文件推送的三个步骤：</p>
<pre tabindex="0"><code>git add 
git commit -m&#34;输入想说的话&#34;
git push
</code></pre><h3 id="查看状况">查看状况</h3>
<p><code>git status</code></p>
<h3 id="分支">分支</h3>
<ul>
<li>
<p>转到另一个分支 `git checkout {分支名}</p>
</li>
<li>
<p>查看本地分支 <code>git branch</code></p>
</li>
<li>
<p>查看远程分支 <code>git branch -r</code></p>
</li>
<li>
<p>查看本地和远程分支 <code>git branch -a</code></p>
</li>
<li>
<p>删除本地分支 <code>git branch -d {本地分支名}</code></p>
</li>
<li>
<p>强制删除本地分支<code>git branch -D {本地分支名}</code></p>
</li>
<li>
<p>删除远程分支 <code>git push origin --delete {远程分支名}</code></p>
</li>
<li>
<p>已经删除的远程分支但仍<code>git branch -a</code>时仍显示 ：<code>git remote prune origin</code></p>
</li>
</ul>
<h3 id="日志">日志</h3>
<ul>
<li><code>git log</code> 查看分支提交历史</li>
<li><code>git reflog</code> 也是查看日志，主要区别是会显示<code>reset --hard</code></li>
</ul>
<h3 id="代码回退">代码回退</h3>
<ul>
<li><code>git reset --hard {commit_id}</code></li>
<li><code>git reset --hard HEAD^ </code> 回退到上一版本</li>
</ul>
<hr>
<h2 id="submodule">submodule</h2>
<ol>
<li>删除特定的Git子模块</li>
</ol>
<pre tabindex="0"><code class="language-git" data-lang="git"># 以取消themes/PaperMod为例
# 取消子模块的初始化
git submodule deinit -f -- themes/PaperMod
# 从项目中删除子模块的目录
git rm -f themes/PaperMod
# git rm -f themes/PaperMod
rm -rf .git/modules/themes/PaperMod
</code></pre><hr>
<h2 id="报错与解决">报错与解决</h2>
<ol>
<li>
<p>报错：</p>
<blockquote>
<p>Updates were rejected because the remote contains work that you donot have locally.</p>
</blockquote>
<ul>
<li><strong>场景</strong>:在尝试gitee的时候，先是建了个远程仓库。然后在本地新建了个同名的文件夹，然后
<pre tabindex="0"><code>git init 
git remote add origin https://gitee.com/spike23187/hello-gitee.git
</code></pre></li>
</ul>
<p>在文件夹里新建了个文件，<code>push</code>的时候报的错</p>
<ul>
<li><strong>解决</strong>: 根据下方的提示，是我没有先<code>pull</code>，本地文件不是最新的。</li>
</ul>
</li>
<li>
<blockquote>
<p>Updates were rejected because the tip of your current branch is behind its remote counterpart</p>
</blockquote>
<ul>
<li><strong>场景</strong>：上述那个场景中，<code>git pull origin master</code>后报的错</li>
<li><strong>解决</strong>：<code>git pull origin master --rebase</code></li>
<li><strong>参考链接</strong>：<a href="https://blog.csdn.net/weixin_42310154/article/details/118676936"  target="_blank" rel="noopener" >Git常见报错：Updates were rejected because the tip of your current branch is behind</a></li>
<li><strong>收获</strong>：虽然使用GitHub托管代码有段时间了，但一直是用插件简化操作的。这次算是第一次用git bash，就报了两个错，感觉git要用好，还是有段路要走的。</li>
</ul>
</li>
<li></li>
</ol>
<ul>
<li><strong>场景</strong>:push时报错,大意是网络问题</li>
<li><strong>解决</strong>：
<pre tabindex="0"><code>git config --global http.proxy &#39;http://127.0.0.1:7890&#39;
git config --global https.proxy &#39;http://127.0.0.1:7890&#39;
</code></pre></li>
</ul>
<hr>
<h1 id="可供参考的链接">可供参考的链接</h1>
<ul>
<li><a href="https://www.yiibai.com/git"  target="_blank" rel="noopener" >git教程</a></li>
<li><a href="https://www.theserverside.com/video/Git-reflog-vs-log-How-these-commit-history-tools-differ"  target="_blank" rel="noopener" >Git reflog vs. log: How these commit history tools differ</a></li>
<li><a href="http://blog.ch3nyang.top/miscellaneous/git%E5%AD%A6%E4%B9%A0/"  target="_blank" rel="noopener" >【杂】git学习</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/137856034"  target="_blank" rel="noopener" >拜托，不要再问我Git如何回滚代码</a></li>
</ul>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
