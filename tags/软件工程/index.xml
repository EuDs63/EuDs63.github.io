<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>软件工程 on EuDs&#39;s Blog</title>
    <link>https://euds63.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</link>
    <description>Recent content in 软件工程 on EuDs&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 13 Sep 2023 16:00:12 +0800</lastBuildDate><atom:link href="https://euds63.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>暑期项目的感悟</title>
      <link>https://euds63.github.io/2023/%E6%9A%91%E6%9C%9F%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%84%9F%E6%82%9F/</link>
      <pubDate>Wed, 13 Sep 2023 16:00:12 +0800</pubDate>
      
      <guid>https://euds63.github.io/2023/%E6%9A%91%E6%9C%9F%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%84%9F%E6%82%9F/</guid>
      <description>没有银弹</description>
      <content:encoded><![CDATA[<p>这次暑期学校的一个月时间都是用来开发一个项目。说是一个月，但实际用来编码的时间大约在三个星期。更具体的时间是早上八点半到下午五点半。最后这一个礼拜晚上也会拿来编码。</p>
<p>三个礼拜的时间说多不多，但这种经历倒是少有，踩了不少坑，也有不少收获，这里记录一下。</p>
<h2 id="学习新技术">学习新技术</h2>
<p>这次用的几个技术栈都是之前没有接触过的：前端React，后端Flask。项目后期还引入了Redux和useSWR。</p>
<p>我对学习新技术倒是蛮有热情，之所以选用这些也是出于想尝试些之前所没有接触过的事物。并且这次用到的技术栈，上手也都是比较容易的，除了Redux现在还是云里雾里，所以整体的开发体验下来并不会因为都是自己没接触过的技术而寸步难行。</p>
<p>但我还是发现了一个蛮大的问题：因为要赶最后的ddl，所以比较偏向于急于求成，看了看用法和示例就开始写了，虽然最后也确实能写出点东西，但总有种半生不熟的感觉，没有一种确确实实掌握的踏实感。</p>
<p>我还意识到，一个人的时间和精力是有限的，而技术却是日新月异的。所谓庄子所说的：吾生也有涯，而知也无涯。所谓贪多嚼不烂，就是这个道理。</p>
<h2 id="dry与aha">DRY与AHA</h2>
<p>这次项目中，后端几乎是我在负责的。但就是这样一个自己在开发的两千行左右的代码，到第三周的时候就还是偶尔会冒出想推倒重写某个部分的想法。</p>
<p>尤其是action这个部分。在这个项目中，我将用户收藏、评分、评论这三个功能抽象成一个action。自己刚开始写的时候还有点沾沾自喜，认为自己是做到了合理的内聚。</p>
<p>但后来却发现其中的弊端：当我想单独修改其中某一部分，因为其耦合性，导致我需要修改一些本不需要修改的代码。而到了项目后期，前端已经和后端对接已经完成百分之八九十。这时候修改一个核心功能，可谓是牵一发而动全身。改是能改，但是却不敢改，因为承担不起所需的时间成本。最后的解决方式是另外又写了几个方法，这就导致代码变得很丑。这时候就真切体验到了垒屎山是一种什么样的心情了。</p>
<p>回顾过去，思考如何在以后能尽量避免这种情况，我想有两个原则可能会起作用：</p>
<ol>
<li>DRY
&ldquo;Don&rsquo;t repeat yourself&quot;的缩写。我虽然有意识去将一些常用的代码封装为一个方法。但还是有不少代码，我选择了直接复制粘贴原有可用代码，并在其基础上进行些许修改。这样子固然省事，写的时候也很畅快，但后期想要修改时，却就要之前的偷懒付出相当的代价。而如若我之前多花些时间，将其封装，这样我的代码也就更方便修改。</li>
<li>AHA
&ldquo;avoid hasty abstractions&quot;的缩写。这个原则让我不禁想到一句话&quot;premature optimization is root of all evil&rdquo;。还是以action为例，如果我在将三个操作耦合成一个时多想一想，那会好许多。但话又说回来，怎么样才算是不仓促，怎么样才算不是过早。我觉得现阶段的我还是缺乏经验，所以下次遇到类似的情况时，我想我大概率还是会为自己的某个小聪明而沾沾自喜，并毫不犹豫地踏进给自己挖的又一个坑。</li>
</ol>
<h2 id="项目流程">项目流程</h2>
<p>这次的流程是采用瀑布模式，相比于上学期所使用的Scrum总觉得不得劲。我个人感觉最大的差异是在项目前期，连续多天都是花在写一些比较虚的文档。而这些文档：需求文档，设计文档之类，我们这几个甚至连初出茅庐都还不算的新人，没办法考虑得那么周到。而且多日时间上的付出只是一些文字，这样的体验感实在不好。</p>
<p>总的来说，这样的经历在我的学生阶段中算是比较一个独特的经历，一个月的时间也没有怎么白白浪费掉，对自己还是较为满意的。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>软工导论复习笔记</title>
      <link>https://euds63.github.io/2023/%E8%BD%AF%E5%B7%A5%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 16 Jun 2023 18:28:40 +0800</pubDate>
      
      <guid>https://euds63.github.io/2023/%E8%BD%AF%E5%B7%A5%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>没有银弹</description>
      <content:encoded><![CDATA[<h1 id="软工导论复习">软工导论复习</h1>
<h2 id="chapter-0">Chapter 0</h2>
<ul>
<li>
<p>软件工程提出时间：1968年</p>
<p>1968年北大西洋公约组织(NATO)的计
算机科学家在联邦德国召开国际会议，
讨论软件危机问题，正式提出了“软件
工程”。</p>
</li>
</ul>
<h2 id="chapter-1">Chapter 1</h2>
<ul>
<li>The nature of software
Developed / Deteriorates / Custom built/ Complex</li>
</ul>
<h2 id="chapter-2">Chapter 2</h2>
<ul>
<li>
<p>软件工程定义</p>
<ol>
<li>The application of a systematic,
disciplined, quantifiable approach to the
development, operation, and maintenance
of software; that is, the application of
engineering to software.</li>
<li>The study of approaches as in (1).</li>
</ol>
</li>
<li>
<p>Software Process</p>
<ul>
<li>why: 需要及时的反馈</li>
<li>Process framework
<ul>
<li>Framework activities
<ul>
<li>Communication</li>
<li>Planning</li>
<li>Modeling
<ol>
<li>需求分析</li>
<li>设计</li>
</ol>
</li>
<li>Construction
<ol>
<li>代码</li>
<li>测试</li>
</ol>
</li>
<li>Deployment</li>
</ul>
</li>
<li>Umbrella Activities 庇护活动（普适性活动）
<ul>
<li>Software project tracking and control</li>
<li>Risk management</li>
<li>Software quality assurance</li>
<li>Technical reviews</li>
<li>Measurement</li>
<li>Software configuration management</li>
<li>Reusability management</li>
<li>Work product preparation and production</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Software Lifecycle</p>
<ul>
<li>软件有一个孕育、诞生、成长、成熟、
衰亡的生存过程。这个过程即为计算机
软件的生命周期(生存周期)</li>
<li>why need
<ul>
<li>从时间角度对软件开发和维护的复杂问题进行分解，把软件生存的漫长周期依次划分为若干个阶段，每个阶段有相对独立的任务，然后再逐步完成每个阶段的任务。</li>
<li>为软件人提供一个公共的框架，以便软件人的相互交流。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="chapter-4">Chapter 4</h2>
<ul>
<li>Evolutionary Models
<ul>
<li>prototype
<ul>
<li>类型
<ul>
<li>探索型(exploratory prototyping) 弄清需求</li>
<li>实验型(experimental prototyping)  验证方案</li>
<li>演化型(evolutionary prototyping)</li>
</ul>
</li>
<li>特征
<ul>
<li>可实际运行</li>
<li>它没有固定的生存期。它可能被扔掉，或者作为最终产品的一部分。</li>
<li>可为不同目标作原型</li>
<li>快速、廉价</li>
<li>是迭代过程的集成部分，即每次经用户评价后修改、运行，不断重复双方认可。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="chapter-5">Chapter 5</h2>
<ul>
<li>敏捷宣言
<ul>
<li>个体和互动 高于 流程和工具</li>
<li>工作的软件 高于 详尽的文档</li>
<li>客户合作 高于 合同谈判</li>
<li>响应变化 高于 遵循计划</li>
</ul>
</li>
<li></li>
</ul>
<h2 id="chapter-7">Chapter 7</h2>
<h3 id="requirements-engineering">Requirements Engineering</h3>
<ul>
<li>Inception</li>
<li>Elicitation</li>
<li>Elaboration</li>
<li>Negotiation</li>
<li>Specification
<ul>
<li>根据需求调查和需求分析的结果，进一步定义准确无误的产品需求，产生《产品需求规格说明书》</li>
</ul>
</li>
<li>Validation</li>
<li>Requirements management</li>
</ul>
<h3 id="quality-function-deployment">Quality Function Deployment</h3>
<ol>
<li>功能部署——确定系统功能的价值</li>
<li>信息部署——确定数据对象和事件</li>
<li>任务部署——确定系统的行为</li>
<li>价值分析——确定需求的优先级</li>
</ol>
<h3 id="non-functional-requirements">Non-Functional Requirements</h3>
<ul>
<li>quality attribute</li>
<li>performance attribute</li>
<li>security attribute</li>
<li>general system constraint</li>
</ul>
<h3 id="diagrams">diagrams</h3>
<p>Use-case / Class / State / Activity</p>
<h2 id="chapter-11">Chapter 11</h2>
<ul>
<li>Analysis model
<ul>
<li>focus on describing required data, function and behavior</li>
</ul>
</li>
</ul>
<h3 id="design-model">Design model</h3>
<ul>
<li>provide detail about software data structure, architecture, interfaces and components</li>
<li>4 kinds
<ul>
<li>Data/Class design——将分析类转换为实现类和数据结构</li>
<li>Architectural design——定义主要软件结构元素之间的关系</li>
<li>Interface design——定义软件元素、硬件元素和最终用户如何通信</li>
<li>Component-level design——转换结构元素到软件组件的过程描述中</li>
</ul>
</li>
</ul>
<h3 id="concepts">concepts</h3>
<ul>
<li>Architecture-软件的整体结构
<ul>
<li>体现了系统的模块化,抽象和信息隐藏,接口设计</li>
<li>举例
<ul>
<li>客户-服务器架构（Client-Server Architecture）</li>
<li>微服务架构（Microservices Architecture）</li>
<li>事件驱动架构（Event-Driven Architecture）</li>
<li>分层架构（Layered Architecture）</li>
</ul>
</li>
</ul>
</li>
<li>Pattern
<ul>
<li>The goal of a pattern：easy to reuse.</li>
<li>types:
<ul>
<li>Architecture Pattern
<ul>
<li>B/S, C/S</li>
</ul>
</li>
<li>Design Pattern</li>
<li>Idiom
<ul>
<li>a low-level pattern specific to a programming language</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Functional Independence
<ul>
<li>Cohesion 内聚
<ul>
<li>an indication of the relative functional strength of a module</li>
<li>功能内聚 分层内聚 通信内聚 顺序内聚 过程内聚 时间内聚 实用内聚（由高到低排列）</li>
</ul>
</li>
<li>Coupling 耦合
<ul>
<li>an indication of the relative interdependence among modules</li>
<li>非直接耦合 数据耦合 标记耦合 控制耦合 外部耦合 共用耦合 内容耦合 （ 由低到高排列）</li>
</ul>
</li>
<li>goal: 高内聚，低耦合</li>
</ul>
</li>
</ul>
<h2 id="chapter12-behavioral-modeling">Chapter12 Behavioral Modeling</h2>
<ul>
<li>what
the structure of the system, which comprise the software components, the externally visible properties of those components, and the relationships among them</li>
<li>The importance of architecture
<ul>
<li>for communication between all parties (stakeholders)</li>
<li>highlights early design decisions</li>
<li>constitutes a relatively small, intellectually graspable mode</li>
</ul>
</li>
<li>架构有什么用
<ul>
<li>分析设计在满足其规定要求方面的有效性</li>
<li>在进行设计更改仍然相对而言的阶段考虑架构替代方案容易</li>
<li>降低与软件构建相关的风险</li>
</ul>
</li>
</ul>
<h3 id="architecture-style">Architecture Style</h3>
<ul>
<li>定义内容
<ul>
<li>一组执行系统所需功能的构件</li>
<li>一组连接器，可以实现“通信、协调和组件之间的合作”</li>
<li>定义组件如何集成以形成系统的约束</li>
<li>语义模型，使设计人员能够通过分析系统组成部分的已知特性来理解系统的整体属性</li>
</ul>
</li>
<li>种类
<ul>
<li>数据流架构——批处理、管道和过滤器</li>
<li>调用和返回架构——主程序/子程序、面向对象系统、分层系统</li>
<li>独立组件架构——事件系统、触发器、监视器</li>
<li>虚拟机架构——解释器，基于规则的系统</li>
<li>仓库架构——数据库系统，黑板系统等</li>
</ul>
</li>
</ul>
<h2 id="chapter13-component-level-design">Chapter13 Component Level Design</h2>
<ul>
<li>一个模块化的、可部署的、可替换的系统部分，它封装了实现并公开了一组接口。</li>
</ul>
<h3 id="basic-design-principles">Basic Design Principles</h3>
<ol>
<li>开闭原则（OCP）——一个模块 [组件] 应该对扩展开放但对修改关闭</li>
<li>里氏替换原则（LSP）—— “子类应该可以替代它们的基类。</li>
<li>依赖倒置原则（DIP）——依赖于抽象。不要依赖实体
<ul>
<li>高层模块应该依赖于抽象（接口或抽象类）</li>
<li>抽象不应该依赖于具体实现，具体实现应该依赖于抽象</li>
</ul>
</li>
<li>接口分离原则 (ISP)——许多专用的接口都比一个通用接口好</li>
<li>发布重用等效原则 (REP)——重用的粒度就是发布的粒度</li>
<li>共同闭合原则（CCP）——同时修改的类应该放在一起</li>
<li>共同重用原则（CRP）——不能同时复用的类不应该放在一起</li>
</ol>
<h2 id="chapter14-user-interface-design">Chapter14 User Interface Design</h2>
<ul>
<li>黄金规则
<ul>
<li>用户控制操作</li>
<li>减少用户记忆负担</li>
<li>保持界面一致</li>
</ul>
</li>
</ul>
<h2 id="chapter-15-16-software-quality">Chapter 15-16 Software Quality</h2>
<ul>
<li>
<p>什么是软件质量
一个有效的软件过程，其应用方式创造了一个有用的产品，为生产它的人和使用它的人提供可衡量的价值</p>
</li>
<li>
<p>McCall’s Triangle of Quality</p>
<ul>
<li>产品修改</li>
<li>产品转移</li>
<li>产品运行</li>
</ul>
</li>
<li>
<p>The Cost of Quality</p>
<ul>
<li>在测试和维护阶段改正错误和缺陷的成本急剧增高</li>
<li>种类：
<ol>
<li>预防成本（COP）</li>
<li>评估成本（COA）</li>
<li>内部失败成本</li>
<li>外部失败成本</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="chapter-17-19-testing-strategy--techniques">Chapter 17-19. Testing Strategy &amp; Techniques</h2>
<ul>
<li>Verification vs. Validation
<ul>
<li>Verification: 确保软件能实现特定功能 building the product right</li>
<li>Validation: 确保软件可追溯到客户需求 building the right product</li>
</ul>
</li>
<li>测试策略——从小到大
<ul>
<li>单元测试</li>
<li>集成测试</li>
<li>系统测试</li>
<li>验收测试
<ul>
<li>α testing 由最终用户在开发人员站点进行</li>
<li>ß testing 在最终用户站点进行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="测试策略之unit-testing">测试策略之unit testing</h3>
<ul>
<li>内容：
<ul>
<li>接口</li>
<li>局部数据结构</li>
<li>边界条件</li>
<li>独立路径</li>
<li>错误处理路径</li>
</ul>
</li>
<li>stub——代替底层</li>
<li>driver——代替顶层
<ul>
<li>提供了一个框架用于设置输入参数，环境 ，执行单元</li>
</ul>
</li>
</ul>
<h3 id="测试策略之integration-testing">测试策略之integration testing</h3>
<ul>
<li>Top Down Integration
<ul>
<li>Advantage
<ul>
<li>A skeletal version of the program can exist early and allows demonstrations</li>
<li>Design errors may be found sooner.</li>
<li>Reduces the need for test drivers</li>
<li>It tends to make fault location easier</li>
</ul>
</li>
<li>Disadvantage
<ul>
<li>stubs could be expensive to build.</li>
</ul>
</li>
</ul>
</li>
<li>Bottom-Up Integration
<ul>
<li>Advantage
<ul>
<li>Particular useful for objects and reuse.</li>
<li>requiring no structural design information</li>
</ul>
</li>
<li>Disadvantage
<ul>
<li>The program as a whole does not exist until the last module is added.</li>
<li>requires test drivers, not test stubs.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="测试策略之system-testing充分运用基于计算机的系统">测试策略之system testing——充分运用基于计算机的系统</h3>
<ul>
<li>目的：
<ul>
<li>在将要运行的真实环境中测试整个系统</li>
<li>确保系统满足整体工作的要求</li>
<li>还要测试系统功能之外的方面</li>
<li>结果有时用于系统验收</li>
<li>验证软件用户手册</li>
<li>估计可靠性和可维护性</li>
</ul>
</li>
</ul>
<h3 id="测试方法">测试方法</h3>
<ul>
<li>黑盒测试（功能）</li>
<li>白盒测试（结构）</li>
</ul>
<h2 id="chapter-21-software-configuration-management">Chapter 21 Software configuration management</h2>
<h3 id="the-scm-process">The SCM Process</h3>
<ol>
<li>identification</li>
<li>change control</li>
<li>version control</li>
<li>configuration auditing</li>
<li>reporting</li>
</ol>
<ul>
<li>Software configuration item</li>
</ul>
<h2 id="chapter-22--project-management-concept">Chapter 22  Project Management Concept</h2>
<h3 id="4-p">4 p</h3>
<ul>
<li>people</li>
<li>product
<ul>
<li>scopes
<ol>
<li>context</li>
<li>information objectives</li>
<li>function and performance</li>
</ol>
</li>
</ul>
</li>
<li>Process
<ul>
<li>Consider project characteristics</li>
<li>Determine the degree of rigor required</li>
<li>Define a task set for each software engineering activity</li>
</ul>
</li>
<li>Project
<ol>
<li>从正确的基础上开始工作——首先通过努力理解要解决的问题，然后设定现实的目标和期望来实现的</li>
<li>保持动力——项目经理必须提供激励措施，将人员流动率控制在最低限度，团队应在其执行的每项任务中强调质量，高级管理人员应尽一切可能远离团队</li>
<li>跟踪进度——作为质量保证活动的一部分，随着工作产品（例如模型、源代码、测试用例集）的生成和批准（使用正式的技术评审），进度会被跟踪。</li>
<li>做出明智的决定——项目经理和软件团队的决定应该是“保持简单”</li>
<li>进行事后分析——建立一个一致的机制来提取每个项目的经验教训</li>
</ol>
</li>
</ul>
<h3 id="w5hh">W5HH</h3>
<ol>
<li>Why is the system being developed?——为什么</li>
<li>What will be done? ——做什么</li>
<li>When will it be accomplished?——什么时候做</li>
<li>Who is responsible?——谁负责</li>
<li>Where are they organizationally located?——其他人的组织机构位于何处</li>
<li>How will the job be done technically and managerially?——如何完成技术工作和管理工作</li>
<li>How much of each resource (e.g., people, software, tools, database) will be needed?——每种资源需要多少</li>
</ol>
<h3 id="task-set-">Task set =</h3>
<ul>
<li>Software engineering tasks</li>
<li>Work products</li>
<li>Quality assurance points</li>
<li>Milestones</li>
</ul>
<h3 id="software-engineering-activity">software engineering activity</h3>
<ul>
<li>需求分析</li>
<li>设计</li>
<li>软件开发</li>
<li>软件部署</li>
<li>软件维护</li>
<li>项目管理</li>
<li>质量保证</li>
<li>配置管理</li>
<li>文档编写</li>
</ul>
<h2 id="chapter-23-process-and-project-metrics">Chapter 23 Process and Project Metrics</h2>
<ul>
<li>意义
<ol>
<li>评估正在进行的项目的状态</li>
<li>跟踪潜在风险</li>
<li>在问题造成不良影响前发现风险</li>
<li>调整工作流程或任务</li>
<li>评估项目团队控制软件工作产品质量的能力</li>
</ol>
</li>
</ul>
<h3 id="process-measurement">Process Measurement</h3>
<ul>
<li>根据过程中获得的一系列数据或软件工程任务的特性来进行测量。</li>
<li>Software Process Improvement (SPI)</li>
<li>5 Metrics
<ul>
<li>Quality-related</li>
<li>Productivity-related</li>
<li>Statistical SQA data</li>
<li>Defecti removal effciency</li>
<li>Reuse data</li>
</ul>
</li>
</ul>
<h3 id="项目度量">项目度量</h3>
<ul>
<li>三个方面
<ul>
<li>如期</li>
<li>质量</li>
<li>成本</li>
</ul>
</li>
</ul>
<h3 id="chapter-24-25-project-estimation--scheduling">Chapter 24-25 Project Estimation &amp; Scheduling</h3>
<h3 id="scope">scope</h3>
<ul>
<li>Scope refers to all the work involved in creating the
products of the project and the processes used to
create them. It defines what is or is not to be done</li>
<li>项目范围的内容
<ul>
<li>交付给最终用户的功能和特性</li>
<li>输入和输出的数据</li>
<li>由于使用软件而呈现给用户的“内容”</li>
<li>性能、约束、接口、和约束系统的可靠性</li>
</ul>
</li>
</ul>
<h3 id="work-breakdown-structure-wbs">Work Breakdown Structure (WBS)</h3>
<ul>
<li>进行WBS的五种方法
<ol>
<li>使用指南：一些组织提供的指南</li>
<li>类比方法：审查类似项目的 WBS，并根据我们的项目 进行定制。</li>
<li>自上而下的方法：从项目中最大的项目开始，并将它们分解</li>
<li>自下而上的方法：从详细的任务开始，并将它们汇总</li>
<li>思维导图方法：以非线性格式写下任务，然后创建 WBS 结构</li>
</ol>
</li>
</ul>
<h3 id="估计方法">估计方法</h3>
<ul>
<li>基于代码行的估计
<ul>
<li>优点：易于测量、容易自动化</li>
<li>缺点：仅限于代码不能用于设计、依赖于语言、没有考虑功能的复杂性、与设计的好坏挂钩</li>
</ul>
</li>
<li>基于功能点的估计
<ul>
<li>优点：
<ol>
<li>可用于最早的需求阶段</li>
<li>独立于编程语言、产品设计或开发风格</li>
<li>用户视图，而不是实现视图</li>
<li>可用于衡量非编码活动</li>
<li>存在大量历史数据</li>
<li>有据可查</li>
</ol>
</li>
<li>缺点：
<ol>
<li>无法直接计算现有产品（源代码）的 FP 内容</li>
<li>难以自动化</li>
<li>FP 不反映语言、设计或风格差异</li>
<li>FP 设计用于估计商业数据处理应用</li>
<li>主观计数</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="项目调度">项目调度</h3>
<ol>
<li>项目为什么会延期
不切实际的截止日期
需求的变化
低估工作量
不可预测的风险
技术难题
人为困难
沟通不畅
未能认识到项目落后于计划或缺乏纠正问题的行动</li>
<li>调度的原则
划分——定义多个不同的任务
相互依赖性——明确任务的相互关系
工作量确认——确保人力资源可用
确定责任——明确责任承担者
明确输出结果——确定活动产生的结果
确定里程碑——进行质量审查</li>
<li>调度的步骤
<ol>
<li>定义任务集——WBS</li>
<li>安排活动</li>
<li>绘制项目网络图</li>
<li>关键路径分析</li>
<li>使用甘特图进行调度</li>
<li>进度跟踪</li>
</ol>
</li>
</ol>
<h2 id="chapter-26-risk-management">Chapter 26 Risk Management</h2>
<ul>
<li>
<p>Reactive Risk Management</p>
</li>
<li>
<p>Proactive Risk Management</p>
<ul>
<li>formal risk analysis is performed</li>
<li>corrects the root causes of risk</li>
</ul>
</li>
<li>
<p>Risk Management Paradigm</p>
<ol>
<li>Risk identification</li>
<li>Risk analysis</li>
<li>Risk planning</li>
<li>Risk monitoring</li>
</ol>
</li>
<li>
<p>RMMM</p>
<ul>
<li>Mitigation</li>
<li>Monitoring</li>
<li>Management</li>
</ul>
</li>
</ul>
<h2 id="常用图">常用图</h2>
<ul>
<li>用例图</li>
<li>类图</li>
<li>活动图
<ul>
<li>变形：泳道图</li>
</ul>
</li>
<li>顺序图</li>
</ul>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
